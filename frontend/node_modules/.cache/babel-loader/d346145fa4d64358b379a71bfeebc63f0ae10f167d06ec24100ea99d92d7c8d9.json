{"ast":null,"code":"import { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { compressPublicKey, deserializePublicKey, serializePublicKey } from './keys';\nimport { createMessageSignature } from './common';\nimport { bytesToHex, concatArray, hexToBytes } from '@stacks/common';\nexport var AuthFieldType;\n(function (AuthFieldType) {\n  AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n  AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\nexport function deserializeMessageSignature(bytesReader) {\n  return createMessageSignature(bytesToHex(bytesReader.readBytes(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)));\n}\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n  return {\n    pubKeyEncoding: pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents: contents\n  };\n}\nexport function deserializeTransactionAuthField(bytesReader) {\n  var authFieldType = bytesReader.readUInt8Enum(AuthFieldType, function (n) {\n    throw new DeserializationError(\"Could not read \".concat(n, \" as AuthFieldType\"));\n  });\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bytesReader));\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bytesReader));\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bytesReader));\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bytesReader));\n    default:\n      throw new Error(\"Unknown auth field type: \".concat(JSON.stringify(authFieldType)));\n  }\n}\nexport function serializeMessageSignature(messageSignature) {\n  return hexToBytes(messageSignature.data);\n}\nexport function serializeTransactionAuthField(field) {\n  var bytesArray = [];\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bytesArray.push(AuthFieldType.PublicKeyCompressed);\n        bytesArray.push(serializePublicKey(field.contents));\n      } else {\n        bytesArray.push(AuthFieldType.PublicKeyUncompressed);\n        bytesArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n      break;\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bytesArray.push(AuthFieldType.SignatureCompressed);\n      } else {\n        bytesArray.push(AuthFieldType.SignatureUncompressed);\n      }\n      bytesArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n  return concatArray(bytesArray);\n}","map":{"version":3,"names":["DeserializationError","PubKeyEncoding","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","compressPublicKey","deserializePublicKey","serializePublicKey","createMessageSignature","bytesToHex","concatArray","hexToBytes","AuthFieldType","deserializeMessageSignature","bytesReader","readBytes","createTransactionAuthField","pubKeyEncoding","contents","type","TransactionAuthField","deserializeTransactionAuthField","authFieldType","readUInt8Enum","n","concat","PublicKeyCompressed","Compressed","PublicKeyUncompressed","Uncompressed","SignatureCompressed","SignatureUncompressed","Error","JSON","stringify","serializeMessageSignature","messageSignature","data","serializeTransactionAuthField","field","bytesArray","PublicKey","push","MessageSignature"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\signature.ts"],"sourcesContent":["import { BytesReader } from './bytesReader';\nimport { DeserializationError } from './errors';\nimport { PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport {\n  compressPublicKey,\n  deserializePublicKey,\n  serializePublicKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { createMessageSignature, MessageSignature } from './common';\n\n// @ts-ignore\nimport { bytesToHex, concatArray, hexToBytes } from '@stacks/common';\n\nexport enum AuthFieldType {\n  PublicKeyCompressed = 0x00,\n  PublicKeyUncompressed = 0x01,\n  SignatureCompressed = 0x02,\n  SignatureUncompressed = 0x03,\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;\n\nexport function deserializeMessageSignature(bytesReader: BytesReader): MessageSignature {\n  return createMessageSignature(\n    bytesToHex(bytesReader.readBytes(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES))\n  );\n}\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  pubKeyEncoding: PubKeyEncoding;\n  contents: TransactionAuthFieldContents;\n}\n\nexport function createTransactionAuthField(\n  pubKeyEncoding: PubKeyEncoding,\n  contents: TransactionAuthFieldContents\n): TransactionAuthField {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents,\n  };\n}\n\nexport function deserializeTransactionAuthField(bytesReader: BytesReader): TransactionAuthField {\n  const authFieldType = bytesReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializePublicKey(bytesReader)\n      );\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializePublicKey(bytesReader)\n      );\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Compressed,\n        deserializeMessageSignature(bytesReader)\n      );\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(\n        PubKeyEncoding.Uncompressed,\n        deserializeMessageSignature(bytesReader)\n      );\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\n\nexport function serializeMessageSignature(messageSignature: MessageSignature): Uint8Array {\n  return hexToBytes(messageSignature.data);\n}\n\nexport function serializeTransactionAuthField(field: TransactionAuthField): Uint8Array {\n  const bytesArray = [];\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bytesArray.push(AuthFieldType.PublicKeyCompressed);\n        bytesArray.push(serializePublicKey(field.contents));\n      } else {\n        bytesArray.push(AuthFieldType.PublicKeyUncompressed);\n        bytesArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n      break;\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bytesArray.push(AuthFieldType.SignatureCompressed);\n      } else {\n        bytesArray.push(AuthFieldType.SignatureUncompressed);\n      }\n      bytesArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return concatArray(bytesArray);\n}\n"],"mappings":"AACA,SAASA,oBAAoB,QAAQ,UAAU;AAC/C,SAASC,cAAc,EAAEC,kCAAkC,EAAEC,iBAAiB,QAAQ,aAAa;AACnG,SACEC,iBAAiB,EACjBC,oBAAoB,EACpBC,kBAAkB,QAEb,QAAQ;AAEf,SAASC,sBAAsB,QAA0B,UAAU;AAGnE,SAASC,UAAU,EAAEC,WAAW,EAAEC,UAAU,QAAQ,gBAAgB;AAEpE,WAAYC,aAKX;AALD,WAAYA,aAAa;EACvBA,aAAA,CAAAA,aAAA,oDAA0B;EAC1BA,aAAA,CAAAA,aAAA,wDAA4B;EAC5BA,aAAA,CAAAA,aAAA,oDAA0B;EAC1BA,aAAA,CAAAA,aAAA,wDAA4B;AAC9B,CAAC,EALWA,aAAa,KAAbA,aAAa;AAezB,OAAM,SAAUC,2BAA2BA,CAACC,WAAwB;EAClE,OAAON,sBAAsB,CAC3BC,UAAU,CAACK,WAAW,CAACC,SAAS,CAACZ,kCAAkC,CAAC,CAAC,CACtE;AACH;AAQA,OAAM,SAAUa,0BAA0BA,CACxCC,cAA8B,EAC9BC,QAAsC;EAEtC,OAAO;IACLD,cAAc,EAAdA,cAAc;IACdE,IAAI,EAAEf,iBAAiB,CAACgB,oBAAoB;IAC5CF,QAAQ,EAARA;GACD;AACH;AAEA,OAAM,SAAUG,+BAA+BA,CAACP,WAAwB;EACtE,IAAMQ,aAAa,GAAGR,WAAW,CAACS,aAAa,CAACX,aAAa,EAAE,UAAAY,CAAC,EAAG;IACjE,MAAM,IAAIvB,oBAAoB,mBAAAwB,MAAA,CAAmBD,CAAC,sBAAmB,CAAC;EACxE,CAAC,CAAC;EAEF,QAAQF,aAAa;IACnB,KAAKV,aAAa,CAACc,mBAAmB;MACpC,OAAOV,0BAA0B,CAC/Bd,cAAc,CAACyB,UAAU,EACzBrB,oBAAoB,CAACQ,WAAW,CAAC,CAClC;IACH,KAAKF,aAAa,CAACgB,qBAAqB;MACtC,OAAOZ,0BAA0B,CAC/Bd,cAAc,CAAC2B,YAAY,EAC3BvB,oBAAoB,CAACQ,WAAW,CAAC,CAClC;IACH,KAAKF,aAAa,CAACkB,mBAAmB;MACpC,OAAOd,0BAA0B,CAC/Bd,cAAc,CAACyB,UAAU,EACzBd,2BAA2B,CAACC,WAAW,CAAC,CACzC;IACH,KAAKF,aAAa,CAACmB,qBAAqB;MACtC,OAAOf,0BAA0B,CAC/Bd,cAAc,CAAC2B,YAAY,EAC3BhB,2BAA2B,CAACC,WAAW,CAAC,CACzC;IACH;MACE,MAAM,IAAIkB,KAAK,6BAAAP,MAAA,CAA6BQ,IAAI,CAACC,SAAS,CAACZ,aAAa,CAAC,CAAE,CAAC;;AAElF;AAEA,OAAM,SAAUa,yBAAyBA,CAACC,gBAAkC;EAC1E,OAAOzB,UAAU,CAACyB,gBAAgB,CAACC,IAAI,CAAC;AAC1C;AAEA,OAAM,SAAUC,6BAA6BA,CAACC,KAA2B;EACvE,IAAMC,UAAU,GAAG,EAAE;EAErB,QAAQD,KAAK,CAACrB,QAAQ,CAACC,IAAI;IACzB,KAAKf,iBAAiB,CAACqC,SAAS;MAC9B,IAAIF,KAAK,CAACtB,cAAc,IAAIf,cAAc,CAACyB,UAAU,EAAE;QACrDa,UAAU,CAACE,IAAI,CAAC9B,aAAa,CAACc,mBAAmB,CAAC;QAClDc,UAAU,CAACE,IAAI,CAACnC,kBAAkB,CAACgC,KAAK,CAACrB,QAAQ,CAAC,CAAC;OACpD,MAAM;QACLsB,UAAU,CAACE,IAAI,CAAC9B,aAAa,CAACgB,qBAAqB,CAAC;QACpDY,UAAU,CAACE,IAAI,CAACnC,kBAAkB,CAACF,iBAAiB,CAACkC,KAAK,CAACrB,QAAQ,CAACmB,IAAI,CAAC,CAAC,CAAC;;MAE7E;IACF,KAAKjC,iBAAiB,CAACuC,gBAAgB;MACrC,IAAIJ,KAAK,CAACtB,cAAc,IAAIf,cAAc,CAACyB,UAAU,EAAE;QACrDa,UAAU,CAACE,IAAI,CAAC9B,aAAa,CAACkB,mBAAmB,CAAC;OACnD,MAAM;QACLU,UAAU,CAACE,IAAI,CAAC9B,aAAa,CAACmB,qBAAqB,CAAC;;MAEtDS,UAAU,CAACE,IAAI,CAACP,yBAAyB,CAACI,KAAK,CAACrB,QAAQ,CAAC,CAAC;MAC1D;;EAGJ,OAAOR,WAAW,CAAC8B,UAAU,CAAC;AAChC"},"metadata":{},"sourceType":"module","externalDependencies":[]}