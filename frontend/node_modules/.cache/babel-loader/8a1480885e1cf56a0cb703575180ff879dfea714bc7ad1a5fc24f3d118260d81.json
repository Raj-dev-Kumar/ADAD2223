{"ast":null,"code":"import _classCallCheck from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { isSingleSig, nextVerification } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\nexport var TransactionSigner = /*#__PURE__*/function () {\n  function TransactionSigner(transaction) {\n    var _this = this;\n    _classCallCheck(this, TransactionSigner);\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n    var spendingCondition = transaction.auth.spendingCondition;\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (spendingCondition.fields.filter(function (field) {\n        return field.contents.type === StacksMessageType.MessageSignature;\n      }).length >= spendingCondition.signaturesRequired) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n      spendingCondition.fields.forEach(function (field) {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          var signature = field.contents;\n          var nextVerify = nextVerification(_this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, PubKeyEncoding.Compressed, signature);\n          _this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n  _createClass(TransactionSigner, [{\n    key: \"signOrigin\",\n    value: function signOrigin(privateKey) {\n      if (this.checkOverlap && this.originDone) {\n        throw new SigningError('Cannot sign origin after sponsor key');\n      }\n      if (this.transaction.auth === undefined) {\n        throw new SigningError('\"transaction.auth\" is undefined');\n      }\n      if (this.transaction.auth.spendingCondition === undefined) {\n        throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n      }\n      if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n        var spendingCondition = this.transaction.auth.spendingCondition;\n        if (this.checkOversign && spendingCondition.fields.filter(function (field) {\n          return field.contents.type === StacksMessageType.MessageSignature;\n        }).length >= spendingCondition.signaturesRequired) {\n          throw new Error('Origin would have too many signatures');\n        }\n      }\n      var nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n      this.sigHash = nextSighash;\n    }\n  }, {\n    key: \"appendOrigin\",\n    value: function appendOrigin(publicKey) {\n      if (this.checkOverlap && this.originDone) {\n        throw Error('Cannot append public key to origin after sponsor key');\n      }\n      if (this.transaction.auth === undefined) {\n        throw new Error('\"transaction.auth\" is undefined');\n      }\n      if (this.transaction.auth.spendingCondition === undefined) {\n        throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n      }\n      this.transaction.appendPubkey(publicKey);\n    }\n  }, {\n    key: \"signSponsor\",\n    value: function signSponsor(privateKey) {\n      if (this.transaction.auth === undefined) {\n        throw new SigningError('\"transaction.auth\" is undefined');\n      }\n      if (this.transaction.auth.authType !== AuthType.Sponsored) {\n        throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n      }\n      var nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n      this.sigHash = nextSighash;\n      this.originDone = true;\n    }\n  }, {\n    key: \"getTxInComplete\",\n    value: function getTxInComplete() {\n      return cloneDeep(this.transaction);\n    }\n  }, {\n    key: \"resume\",\n    value: function resume(transaction) {\n      this.transaction = cloneDeep(transaction);\n      this.sigHash = transaction.signBegin();\n    }\n  }], [{\n    key: \"createSponsorSigner\",\n    value: function createSponsorSigner(transaction, spendingCondition) {\n      if (transaction.auth.authType != AuthType.Sponsored) {\n        throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n      }\n      var tx = cloneDeep(transaction);\n      tx.setSponsor(spendingCondition);\n      var originSigHash = tx.verifyOrigin();\n      var signer = new this(tx);\n      signer.originDone = true;\n      signer.sigHash = originSigHash;\n      signer.checkOversign = true;\n      signer.checkOverlap = true;\n      return signer;\n    }\n  }]);\n  return TransactionSigner;\n}();","map":{"version":3,"names":["isSingleSig","nextVerification","cloneDeep","AuthType","PubKeyEncoding","StacksMessageType","SigningError","TransactionSigner","transaction","_this","_classCallCheck","sigHash","signBegin","originDone","checkOversign","checkOverlap","spendingCondition","auth","fields","filter","field","contents","type","MessageSignature","length","signaturesRequired","Error","forEach","signature","nextVerify","authType","fee","nonce","Compressed","nextSigHash","_createClass","key","value","signOrigin","privateKey","undefined","nextSighash","signNextOrigin","appendOrigin","publicKey","appendPubkey","signSponsor","Sponsored","signNextSponsor","getTxInComplete","resume","createSponsorSigner","tx","setSponsor","originSigHash","verifyOrigin","signer"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\signer.ts"],"sourcesContent":["import { StacksTransaction } from './transaction';\n\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\nimport { isSingleSig, nextVerification, SpendingConditionOpts } from './authorization';\nimport { cloneDeep } from './utils';\nimport { AuthType, PubKeyEncoding, StacksMessageType } from './constants';\nimport { SigningError } from './errors';\n\nexport class TransactionSigner {\n  transaction: StacksTransaction;\n  sigHash: string;\n  originDone: boolean;\n  checkOversign: boolean;\n  checkOverlap: boolean;\n\n  constructor(transaction: StacksTransaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n\n    // If multi-sig spending condition exists, iterate over\n    // auth fields and reconstruct sigHash\n    const spendingCondition = transaction.auth.spendingCondition;\n    if (spendingCondition && !isSingleSig(spendingCondition)) {\n      if (\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('SpendingCondition has more signatures than are expected');\n      }\n\n      spendingCondition.fields.forEach(field => {\n        if (field.contents.type === StacksMessageType.MessageSignature) {\n          const signature = field.contents;\n          const nextVerify = nextVerification(\n            this.sigHash,\n            transaction.auth.authType,\n            spendingCondition.fee,\n            spendingCondition.nonce,\n            PubKeyEncoding.Compressed, // always compressed for multisig\n            signature\n          );\n          this.sigHash = nextVerify.nextSigHash;\n        }\n      });\n    }\n  }\n\n  static createSponsorSigner(\n    transaction: StacksTransaction,\n    spendingCondition: SpendingConditionOpts\n  ) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx: StacksTransaction = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey: StacksPrivateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n      if (\n        this.checkOversign &&\n        spendingCondition.fields.filter(\n          field => field.contents.type === StacksMessageType.MessageSignature\n        ).length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey: StacksPublicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey: StacksPrivateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.authType !== AuthType.Sponsored) {\n      throw new SigningError('\"transaction.auth.authType\" is not AuthType.Sponsored');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete(): StacksTransaction {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction: StacksTransaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}