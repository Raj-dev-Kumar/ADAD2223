{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { bytesToHex, hexToBytes, intToBigInt } from '@stacks/common';\nimport { StacksNetwork, StacksMainnet, StacksTestnet, createFetchFn } from '@stacks/network';\nimport { c32address } from 'c32check';\nimport { createMultiSigSpendingCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStandardAuth } from './authorization';\nimport { deserializeCV, serializeCV } from './clarity';\nimport { AddressHashMode, AddressVersion, PayloadType, PostConditionMode, TransactionVersion, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, ClarityVersion } from './constants';\nimport { validateContractCall } from './contract-abi';\nimport { NoEstimateAvailableError } from './errors';\nimport { createStacksPrivateKey, getPublicKey, pubKeyfromPrivKey, publicKeyFromBytes, publicKeyToAddress, publicKeyToString } from './keys';\nimport { createContractCallPayload, createSmartContractPayload, createTokenTransferPayload, serializePayload } from './payload';\nimport { createFungiblePostCondition, createNonFungiblePostCondition, createSTXPostCondition } from './postcondition';\nimport { createContractPrincipal, createStandardPrincipal } from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\nexport function getNonce(_x, _x2) {\n  return _getNonce.apply(this, arguments);\n}\nfunction _getNonce() {\n  _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(address, network) {\n    var derivedNetwork, url, response, msg, responseText, result;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : new StacksMainnet());\n          url = derivedNetwork.getAccountApiUrl(address);\n          _context.next = 4;\n          return derivedNetwork.fetchFn(url);\n        case 4:\n          response = _context.sent;\n          if (response.ok) {\n            _context.next = 16;\n            break;\n          }\n          msg = '';\n          _context.prev = 7;\n          _context.next = 10;\n          return response.text();\n        case 10:\n          msg = _context.sent;\n          _context.next = 15;\n          break;\n        case 13:\n          _context.prev = 13;\n          _context.t0 = _context[\"catch\"](7);\n        case 15:\n          throw new Error(\"Error fetching nonce. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n        case 16:\n          _context.next = 18;\n          return response.text();\n        case 18:\n          responseText = _context.sent;\n          result = JSON.parse(responseText);\n          return _context.abrupt(\"return\", BigInt(result.nonce));\n        case 21:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[7, 13]]);\n  }));\n  return _getNonce.apply(this, arguments);\n}\nexport function estimateTransfer(_x3, _x4) {\n  return _estimateTransfer.apply(this, arguments);\n}\nfunction _estimateTransfer() {\n  _estimateTransfer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(transaction, network) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(transaction.payload.payloadType !== PayloadType.TokenTransfer)) {\n            _context2.next = 2;\n            break;\n          }\n          throw new Error(\"Transaction fee estimation only possible with \".concat(PayloadType[PayloadType.TokenTransfer], \" transactions. Invoked with: \").concat(PayloadType[transaction.payload.payloadType]));\n        case 2:\n          return _context2.abrupt(\"return\", estimateTransferUnsafe(transaction, network));\n        case 3:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _estimateTransfer.apply(this, arguments);\n}\nexport function estimateTransferUnsafe(_x5, _x6) {\n  return _estimateTransferUnsafe.apply(this, arguments);\n}\nfunction _estimateTransferUnsafe() {\n  _estimateTransferUnsafe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(transaction, network) {\n    var requestHeaders, fetchOptions, derivedNetwork, url, response, msg, feeRateResult, txBytes, feeRate;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          requestHeaders = {\n            Accept: 'application/text'\n          };\n          fetchOptions = {\n            method: 'GET',\n            headers: requestHeaders\n          };\n          derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n          url = derivedNetwork.getTransferFeeEstimateApiUrl();\n          _context3.next = 6;\n          return derivedNetwork.fetchFn(url, fetchOptions);\n        case 6:\n          response = _context3.sent;\n          if (response.ok) {\n            _context3.next = 18;\n            break;\n          }\n          msg = '';\n          _context3.prev = 9;\n          _context3.next = 12;\n          return response.text();\n        case 12:\n          msg = _context3.sent;\n          _context3.next = 17;\n          break;\n        case 15:\n          _context3.prev = 15;\n          _context3.t0 = _context3[\"catch\"](9);\n        case 17:\n          throw new Error(\"Error estimating transaction fee. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n        case 18:\n          _context3.next = 20;\n          return response.text();\n        case 20:\n          feeRateResult = _context3.sent;\n          txBytes = BigInt(transaction.serialize().byteLength);\n          feeRate = BigInt(feeRateResult);\n          return _context3.abrupt(\"return\", feeRate * txBytes);\n        case 24:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[9, 15]]);\n  }));\n  return _estimateTransferUnsafe.apply(this, arguments);\n}\nexport function estimateTransaction(_x7, _x8, _x9) {\n  return _estimateTransaction.apply(this, arguments);\n}\nfunction _estimateTransaction() {\n  _estimateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transactionPayload, estimatedLen, network) {\n    var options, derivedNetwork, url, response, body, _body$reason_data$mes, _body$reason_data, data;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          options = {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(_objectSpread({\n              transaction_payload: bytesToHex(serializePayload(transactionPayload))\n            }, estimatedLen ? {\n              estimated_len: estimatedLen\n            } : {}))\n          };\n          derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : new StacksMainnet());\n          url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n          _context4.next = 5;\n          return derivedNetwork.fetchFn(url, options);\n        case 5:\n          response = _context4.sent;\n          if (response.ok) {\n            _context4.next = 13;\n            break;\n          }\n          _context4.next = 9;\n          return response.json().catch(function () {\n            return {};\n          });\n        case 9:\n          body = _context4.sent;\n          if (!((body === null || body === void 0 ? void 0 : body.reason) === 'NoEstimateAvailable')) {\n            _context4.next = 12;\n            break;\n          }\n          throw new NoEstimateAvailableError((_body$reason_data$mes = body === null || body === void 0 || (_body$reason_data = body.reason_data) === null || _body$reason_data === void 0 ? void 0 : _body$reason_data.message) !== null && _body$reason_data$mes !== void 0 ? _body$reason_data$mes : '');\n        case 12:\n          throw new Error(\"Error estimating transaction fee. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(body, \"\\\"\"));\n        case 13:\n          _context4.next = 15;\n          return response.json();\n        case 15:\n          data = _context4.sent;\n          return _context4.abrupt(\"return\", data.estimations);\n        case 17:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _estimateTransaction.apply(this, arguments);\n}\nexport function broadcastTransaction(_x10, _x11, _x12) {\n  return _broadcastTransaction.apply(this, arguments);\n}\nfunction _broadcastTransaction() {\n  _broadcastTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(transaction, network, attachment) {\n    var rawTx, derivedNetwork, url;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          rawTx = transaction.serialize();\n          derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n          url = derivedNetwork.getBroadcastApiUrl();\n          return _context5.abrupt(\"return\", broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn));\n        case 4:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return _broadcastTransaction.apply(this, arguments);\n}\nexport function broadcastRawTransaction(_x13, _x14, _x15) {\n  return _broadcastRawTransaction.apply(this, arguments);\n}\nfunction _broadcastRawTransaction() {\n  _broadcastRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(rawTx, url, attachment) {\n    var fetchFn,\n      options,\n      response,\n      text,\n      txid,\n      _args6 = arguments;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          fetchFn = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : createFetchFn();\n          options = {\n            method: 'POST',\n            headers: {\n              'Content-Type': attachment ? 'application/json' : 'application/octet-stream'\n            },\n            body: attachment ? JSON.stringify({\n              tx: bytesToHex(rawTx),\n              attachment: bytesToHex(attachment)\n            }) : rawTx\n          };\n          _context6.next = 4;\n          return fetchFn(url, options);\n        case 4:\n          response = _context6.sent;\n          if (response.ok) {\n            _context6.next = 15;\n            break;\n          }\n          _context6.prev = 6;\n          _context6.next = 9;\n          return response.json();\n        case 9:\n          return _context6.abrupt(\"return\", _context6.sent);\n        case 12:\n          _context6.prev = 12;\n          _context6.t0 = _context6[\"catch\"](6);\n          throw Error(\"Failed to broadcast transaction: \".concat(_context6.t0.message));\n        case 15:\n          _context6.next = 17;\n          return response.text();\n        case 17:\n          text = _context6.sent;\n          txid = text.replace(/[\"]+/g, '');\n          if (validateTxId(txid)) {\n            _context6.next = 21;\n            break;\n          }\n          throw new Error(text);\n        case 21:\n          return _context6.abrupt(\"return\", {\n            txid: txid\n          });\n        case 22:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6, null, [[6, 12]]);\n  }));\n  return _broadcastRawTransaction.apply(this, arguments);\n}\nexport function getAbi(_x16, _x17, _x18) {\n  return _getAbi.apply(this, arguments);\n}\nfunction _getAbi() {\n  _getAbi = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(address, contractName, network) {\n    var options, derivedNetwork, url, response, msg;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) switch (_context7.prev = _context7.next) {\n        case 0:\n          options = {\n            method: 'GET'\n          };\n          derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n          url = derivedNetwork.getAbiApiUrl(address, contractName);\n          _context7.next = 5;\n          return derivedNetwork.fetchFn(url, options);\n        case 5:\n          response = _context7.sent;\n          if (response.ok) {\n            _context7.next = 11;\n            break;\n          }\n          _context7.next = 9;\n          return response.text().catch(function () {\n            return '';\n          });\n        case 9:\n          msg = _context7.sent;\n          throw new Error(\"Error fetching contract ABI for contract \\\"\".concat(contractName, \"\\\" at address \").concat(address, \". Response \").concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n        case 11:\n          _context7.t0 = JSON;\n          _context7.next = 14;\n          return response.text();\n        case 14:\n          _context7.t1 = _context7.sent;\n          return _context7.abrupt(\"return\", _context7.t0.parse.call(_context7.t0, _context7.t1));\n        case 16:\n        case \"end\":\n          return _context7.stop();\n      }\n    }, _callee7);\n  }));\n  return _getAbi.apply(this, arguments);\n}\nfunction deriveNetwork(transaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\nexport function makeUnsignedSTXTokenTransfer(_x19) {\n  return _makeUnsignedSTXTokenTransfer.apply(this, arguments);\n}\nfunction _makeUnsignedSTXTokenTransfer() {\n  _makeUnsignedSTXTokenTransfer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(txOptions) {\n    var defaultOptions, options, payload, authorization, spendingCondition, network, transaction, fee, addressVersion, senderAddress, txNonce;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          defaultOptions = {\n            fee: BigInt(0),\n            nonce: BigInt(0),\n            network: new StacksMainnet(),\n            memo: '',\n            sponsored: false\n          };\n          options = Object.assign(defaultOptions, txOptions);\n          payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n          authorization = null;\n          spendingCondition = null;\n          if ('publicKey' in options) {\n            spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n          } else {\n            spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n          }\n          if (options.sponsored) {\n            authorization = createSponsoredAuth(spendingCondition);\n          } else {\n            authorization = createStandardAuth(spendingCondition);\n          }\n          network = StacksNetwork.fromNameOrNetwork(options.network);\n          transaction = new StacksTransaction(network.version, authorization, payload, undefined, undefined, options.anchorMode, network.chainId);\n          if (!(txOptions.fee === undefined || txOptions.fee === null)) {\n            _context8.next = 14;\n            break;\n          }\n          _context8.next = 12;\n          return estimateTransactionFeeWithFallback(transaction, network);\n        case 12:\n          fee = _context8.sent;\n          transaction.setFee(fee);\n        case 14:\n          if (!(txOptions.nonce === undefined || txOptions.nonce === null)) {\n            _context8.next = 21;\n            break;\n          }\n          addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n          senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n          _context8.next = 19;\n          return getNonce(senderAddress, options.network);\n        case 19:\n          txNonce = _context8.sent;\n          transaction.setNonce(txNonce);\n        case 21:\n          return _context8.abrupt(\"return\", transaction);\n        case 22:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return _makeUnsignedSTXTokenTransfer.apply(this, arguments);\n}\nexport function makeSTXTokenTransfer(_x20) {\n  return _makeSTXTokenTransfer.apply(this, arguments);\n}\nfunction _makeSTXTokenTransfer() {\n  _makeSTXTokenTransfer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(txOptions) {\n    var publicKey, options, transaction, privKey, signer, _options, _transaction, _signer, pubKeys, _iterator, _step, _loop, _iterator2, _step2, key;\n    return _regeneratorRuntime().wrap(function _callee9$(_context10) {\n      while (1) switch (_context10.prev = _context10.next) {\n        case 0:\n          if (!('senderKey' in txOptions)) {\n            _context10.next = 12;\n            break;\n          }\n          publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n          options = omit(txOptions, 'senderKey');\n          _context10.next = 5;\n          return makeUnsignedSTXTokenTransfer(_objectSpread({\n            publicKey: publicKey\n          }, options));\n        case 5:\n          transaction = _context10.sent;\n          privKey = createStacksPrivateKey(txOptions.senderKey);\n          signer = new TransactionSigner(transaction);\n          signer.signOrigin(privKey);\n          return _context10.abrupt(\"return\", transaction);\n        case 12:\n          _options = omit(txOptions, 'signerKeys');\n          _context10.next = 15;\n          return makeUnsignedSTXTokenTransfer(_options);\n        case 15:\n          _transaction = _context10.sent;\n          _signer = new TransactionSigner(_transaction);\n          pubKeys = txOptions.publicKeys;\n          _iterator = _createForOfIteratorHelper(txOptions.signerKeys);\n          _context10.prev = 19;\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var key, pubKey;\n            return _regeneratorRuntime().wrap(function _loop$(_context9) {\n              while (1) switch (_context9.prev = _context9.next) {\n                case 0:\n                  key = _step.value;\n                  pubKey = pubKeyfromPrivKey(key);\n                  pubKeys = pubKeys.filter(function (pk) {\n                    return pk !== bytesToHex(pubKey.data);\n                  });\n                  _signer.signOrigin(createStacksPrivateKey(key));\n                case 4:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }, _loop);\n          });\n          _iterator.s();\n        case 22:\n          if ((_step = _iterator.n()).done) {\n            _context10.next = 26;\n            break;\n          }\n          return _context10.delegateYield(_loop(), \"t0\", 24);\n        case 24:\n          _context10.next = 22;\n          break;\n        case 26:\n          _context10.next = 31;\n          break;\n        case 28:\n          _context10.prev = 28;\n          _context10.t1 = _context10[\"catch\"](19);\n          _iterator.e(_context10.t1);\n        case 31:\n          _context10.prev = 31;\n          _iterator.f();\n          return _context10.finish(31);\n        case 34:\n          _iterator2 = _createForOfIteratorHelper(pubKeys);\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              key = _step2.value;\n              _signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          return _context10.abrupt(\"return\", _transaction);\n        case 37:\n        case \"end\":\n          return _context10.stop();\n      }\n    }, _callee9, null, [[19, 28, 31, 34]]);\n  }));\n  return _makeSTXTokenTransfer.apply(this, arguments);\n}\nexport function estimateContractDeploy(_x21, _x22) {\n  return _estimateContractDeploy.apply(this, arguments);\n}\nfunction _estimateContractDeploy() {\n  _estimateContractDeploy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(transaction, network) {\n    var requestHeaders, fetchOptions, derivedNetwork, url, response, msg, feeRateResult, txBytes, feeRate;\n    return _regeneratorRuntime().wrap(function _callee10$(_context11) {\n      while (1) switch (_context11.prev = _context11.next) {\n        case 0:\n          if (!(transaction.payload.payloadType !== PayloadType.SmartContract && transaction.payload.payloadType !== PayloadType.VersionedSmartContract)) {\n            _context11.next = 2;\n            break;\n          }\n          throw new Error(\"Contract deploy fee estimation only possible with \".concat(PayloadType[PayloadType.SmartContract], \" transactions. Invoked with: \").concat(PayloadType[transaction.payload.payloadType]));\n        case 2:\n          requestHeaders = {\n            Accept: 'application/text'\n          };\n          fetchOptions = {\n            method: 'GET',\n            headers: requestHeaders\n          };\n          derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n          url = derivedNetwork.getTransferFeeEstimateApiUrl();\n          _context11.next = 8;\n          return derivedNetwork.fetchFn(url, fetchOptions);\n        case 8:\n          response = _context11.sent;\n          if (response.ok) {\n            _context11.next = 14;\n            break;\n          }\n          _context11.next = 12;\n          return response.text().catch(function () {\n            return '';\n          });\n        case 12:\n          msg = _context11.sent;\n          throw new Error(\"Error estimating contract deploy fee. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n        case 14:\n          _context11.next = 16;\n          return response.text();\n        case 16:\n          feeRateResult = _context11.sent;\n          txBytes = intToBigInt(transaction.serialize().byteLength, false);\n          feeRate = intToBigInt(feeRateResult, false);\n          return _context11.abrupt(\"return\", feeRate * txBytes);\n        case 20:\n        case \"end\":\n          return _context11.stop();\n      }\n    }, _callee10);\n  }));\n  return _estimateContractDeploy.apply(this, arguments);\n}\nexport function makeContractDeploy(_x23) {\n  return _makeContractDeploy.apply(this, arguments);\n}\nfunction _makeContractDeploy() {\n  _makeContractDeploy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(txOptions) {\n    var publicKey, options, transaction, privKey, signer, _options2, _transaction2, _signer2, pubKeys, _iterator3, _step3, _loop2, _iterator4, _step4, key;\n    return _regeneratorRuntime().wrap(function _callee11$(_context13) {\n      while (1) switch (_context13.prev = _context13.next) {\n        case 0:\n          if (!('senderKey' in txOptions)) {\n            _context13.next = 12;\n            break;\n          }\n          publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n          options = omit(txOptions, 'senderKey');\n          _context13.next = 5;\n          return makeUnsignedContractDeploy(_objectSpread({\n            publicKey: publicKey\n          }, options));\n        case 5:\n          transaction = _context13.sent;\n          privKey = createStacksPrivateKey(txOptions.senderKey);\n          signer = new TransactionSigner(transaction);\n          signer.signOrigin(privKey);\n          return _context13.abrupt(\"return\", transaction);\n        case 12:\n          _options2 = omit(txOptions, 'signerKeys');\n          _context13.next = 15;\n          return makeUnsignedContractDeploy(_options2);\n        case 15:\n          _transaction2 = _context13.sent;\n          _signer2 = new TransactionSigner(_transaction2);\n          pubKeys = txOptions.publicKeys;\n          _iterator3 = _createForOfIteratorHelper(txOptions.signerKeys);\n          _context13.prev = 19;\n          _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n            var key, pubKey;\n            return _regeneratorRuntime().wrap(function _loop2$(_context12) {\n              while (1) switch (_context12.prev = _context12.next) {\n                case 0:\n                  key = _step3.value;\n                  pubKey = pubKeyfromPrivKey(key);\n                  pubKeys = pubKeys.filter(function (pk) {\n                    return pk !== bytesToHex(pubKey.data);\n                  });\n                  _signer2.signOrigin(createStacksPrivateKey(key));\n                case 4:\n                case \"end\":\n                  return _context12.stop();\n              }\n            }, _loop2);\n          });\n          _iterator3.s();\n        case 22:\n          if ((_step3 = _iterator3.n()).done) {\n            _context13.next = 26;\n            break;\n          }\n          return _context13.delegateYield(_loop2(), \"t0\", 24);\n        case 24:\n          _context13.next = 22;\n          break;\n        case 26:\n          _context13.next = 31;\n          break;\n        case 28:\n          _context13.prev = 28;\n          _context13.t1 = _context13[\"catch\"](19);\n          _iterator3.e(_context13.t1);\n        case 31:\n          _context13.prev = 31;\n          _iterator3.f();\n          return _context13.finish(31);\n        case 34:\n          _iterator4 = _createForOfIteratorHelper(pubKeys);\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              key = _step4.value;\n              _signer2.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          return _context13.abrupt(\"return\", _transaction2);\n        case 37:\n        case \"end\":\n          return _context13.stop();\n      }\n    }, _callee11, null, [[19, 28, 31, 34]]);\n  }));\n  return _makeContractDeploy.apply(this, arguments);\n}\nexport function makeUnsignedContractDeploy(_x24) {\n  return _makeUnsignedContractDeploy.apply(this, arguments);\n}\nfunction _makeUnsignedContractDeploy() {\n  _makeUnsignedContractDeploy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(txOptions) {\n    var defaultOptions, options, payload, authorization, spendingCondition, network, postConditions, lpPostConditions, transaction, fee, addressVersion, senderAddress, txNonce;\n    return _regeneratorRuntime().wrap(function _callee12$(_context14) {\n      while (1) switch (_context14.prev = _context14.next) {\n        case 0:\n          defaultOptions = {\n            fee: BigInt(0),\n            nonce: BigInt(0),\n            network: new StacksMainnet(),\n            postConditionMode: PostConditionMode.Deny,\n            sponsored: false,\n            clarityVersion: ClarityVersion.Clarity2\n          };\n          options = Object.assign(defaultOptions, txOptions);\n          payload = createSmartContractPayload(options.contractName, options.codeBody, options.clarityVersion);\n          authorization = null;\n          spendingCondition = null;\n          if ('publicKey' in options) {\n            spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n          } else {\n            spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n          }\n          if (options.sponsored) {\n            authorization = createSponsoredAuth(spendingCondition);\n          } else {\n            authorization = createStandardAuth(spendingCondition);\n          }\n          network = StacksNetwork.fromNameOrNetwork(options.network);\n          postConditions = [];\n          if (options.postConditions && options.postConditions.length > 0) {\n            options.postConditions.forEach(function (postCondition) {\n              postConditions.push(postCondition);\n            });\n          }\n          lpPostConditions = createLPList(postConditions);\n          transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n          if (!(txOptions.fee === undefined || txOptions.fee === null)) {\n            _context14.next = 17;\n            break;\n          }\n          _context14.next = 15;\n          return estimateTransactionFeeWithFallback(transaction, network);\n        case 15:\n          fee = _context14.sent;\n          transaction.setFee(fee);\n        case 17:\n          if (!(txOptions.nonce === undefined || txOptions.nonce === null)) {\n            _context14.next = 24;\n            break;\n          }\n          addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n          senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n          _context14.next = 22;\n          return getNonce(senderAddress, options.network);\n        case 22:\n          txNonce = _context14.sent;\n          transaction.setNonce(txNonce);\n        case 24:\n          return _context14.abrupt(\"return\", transaction);\n        case 25:\n        case \"end\":\n          return _context14.stop();\n      }\n    }, _callee12);\n  }));\n  return _makeUnsignedContractDeploy.apply(this, arguments);\n}\nexport function estimateContractFunctionCall(_x25, _x26) {\n  return _estimateContractFunctionCall.apply(this, arguments);\n}\nfunction _estimateContractFunctionCall() {\n  _estimateContractFunctionCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(transaction, network) {\n    var requestHeaders, fetchOptions, derivedNetwork, url, response, msg, feeRateResult, txBytes, feeRate;\n    return _regeneratorRuntime().wrap(function _callee13$(_context15) {\n      while (1) switch (_context15.prev = _context15.next) {\n        case 0:\n          if (!(transaction.payload.payloadType !== PayloadType.ContractCall)) {\n            _context15.next = 2;\n            break;\n          }\n          throw new Error(\"Contract call fee estimation only possible with \".concat(PayloadType[PayloadType.ContractCall], \" transactions. Invoked with: \").concat(PayloadType[transaction.payload.payloadType]));\n        case 2:\n          requestHeaders = {\n            Accept: 'application/text'\n          };\n          fetchOptions = {\n            method: 'GET',\n            headers: requestHeaders\n          };\n          derivedNetwork = StacksNetwork.fromNameOrNetwork(network !== null && network !== void 0 ? network : deriveNetwork(transaction));\n          url = derivedNetwork.getTransferFeeEstimateApiUrl();\n          _context15.next = 8;\n          return derivedNetwork.fetchFn(url, fetchOptions);\n        case 8:\n          response = _context15.sent;\n          if (response.ok) {\n            _context15.next = 14;\n            break;\n          }\n          _context15.next = 12;\n          return response.text().catch(function () {\n            return '';\n          });\n        case 12:\n          msg = _context15.sent;\n          throw new Error(\"Error estimating contract call fee. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n        case 14:\n          _context15.next = 16;\n          return response.text();\n        case 16:\n          feeRateResult = _context15.sent;\n          txBytes = intToBigInt(transaction.serialize().byteLength, false);\n          feeRate = intToBigInt(feeRateResult, false);\n          return _context15.abrupt(\"return\", feeRate * txBytes);\n        case 20:\n        case \"end\":\n          return _context15.stop();\n      }\n    }, _callee13);\n  }));\n  return _estimateContractFunctionCall.apply(this, arguments);\n}\nexport function makeUnsignedContractCall(_x27) {\n  return _makeUnsignedContractCall.apply(this, arguments);\n}\nfunction _makeUnsignedContractCall() {\n  _makeUnsignedContractCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(txOptions) {\n    var defaultOptions, options, payload, abi, spendingCondition, authorization, network, postConditions, lpPostConditions, transaction, fee, addressVersion, senderAddress, txNonce;\n    return _regeneratorRuntime().wrap(function _callee14$(_context16) {\n      while (1) switch (_context16.prev = _context16.next) {\n        case 0:\n          defaultOptions = {\n            fee: BigInt(0),\n            nonce: BigInt(0),\n            network: new StacksMainnet(),\n            postConditionMode: PostConditionMode.Deny,\n            sponsored: false\n          };\n          options = Object.assign(defaultOptions, txOptions);\n          payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n          if (!(options !== null && options !== void 0 && options.validateWithAbi)) {\n            _context16.next = 16;\n            break;\n          }\n          if (!(typeof options.validateWithAbi === 'boolean')) {\n            _context16.next = 14;\n            break;\n          }\n          if (!(options !== null && options !== void 0 && options.network)) {\n            _context16.next = 11;\n            break;\n          }\n          _context16.next = 8;\n          return getAbi(options.contractAddress, options.contractName, options.network);\n        case 8:\n          abi = _context16.sent;\n          _context16.next = 12;\n          break;\n        case 11:\n          throw new Error('Network option must be provided in order to validate with ABI');\n        case 12:\n          _context16.next = 15;\n          break;\n        case 14:\n          abi = options.validateWithAbi;\n        case 15:\n          validateContractCall(payload, abi);\n        case 16:\n          spendingCondition = null;\n          authorization = null;\n          if ('publicKey' in options) {\n            spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n          } else {\n            spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n          }\n          if (options.sponsored) {\n            authorization = createSponsoredAuth(spendingCondition);\n          } else {\n            authorization = createStandardAuth(spendingCondition);\n          }\n          network = StacksNetwork.fromNameOrNetwork(options.network);\n          postConditions = [];\n          if (options.postConditions && options.postConditions.length > 0) {\n            options.postConditions.forEach(function (postCondition) {\n              postConditions.push(postCondition);\n            });\n          }\n          lpPostConditions = createLPList(postConditions);\n          transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n          if (!(txOptions.fee === undefined || txOptions.fee === null)) {\n            _context16.next = 30;\n            break;\n          }\n          _context16.next = 28;\n          return estimateTransactionFeeWithFallback(transaction, network);\n        case 28:\n          fee = _context16.sent;\n          transaction.setFee(fee);\n        case 30:\n          if (!(txOptions.nonce === undefined || txOptions.nonce === null)) {\n            _context16.next = 37;\n            break;\n          }\n          addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n          senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n          _context16.next = 35;\n          return getNonce(senderAddress, network);\n        case 35:\n          txNonce = _context16.sent;\n          transaction.setNonce(txNonce);\n        case 37:\n          return _context16.abrupt(\"return\", transaction);\n        case 38:\n        case \"end\":\n          return _context16.stop();\n      }\n    }, _callee14);\n  }));\n  return _makeUnsignedContractCall.apply(this, arguments);\n}\nexport function makeContractCall(_x28) {\n  return _makeContractCall.apply(this, arguments);\n}\nfunction _makeContractCall() {\n  _makeContractCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(txOptions) {\n    var publicKey, options, transaction, privKey, signer, _options3, _transaction3, _signer3, pubKeys, _iterator5, _step5, _loop3, _iterator6, _step6, key;\n    return _regeneratorRuntime().wrap(function _callee15$(_context18) {\n      while (1) switch (_context18.prev = _context18.next) {\n        case 0:\n          if (!('senderKey' in txOptions)) {\n            _context18.next = 12;\n            break;\n          }\n          publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n          options = omit(txOptions, 'senderKey');\n          _context18.next = 5;\n          return makeUnsignedContractCall(_objectSpread({\n            publicKey: publicKey\n          }, options));\n        case 5:\n          transaction = _context18.sent;\n          privKey = createStacksPrivateKey(txOptions.senderKey);\n          signer = new TransactionSigner(transaction);\n          signer.signOrigin(privKey);\n          return _context18.abrupt(\"return\", transaction);\n        case 12:\n          _options3 = omit(txOptions, 'signerKeys');\n          _context18.next = 15;\n          return makeUnsignedContractCall(_options3);\n        case 15:\n          _transaction3 = _context18.sent;\n          _signer3 = new TransactionSigner(_transaction3);\n          pubKeys = txOptions.publicKeys;\n          _iterator5 = _createForOfIteratorHelper(txOptions.signerKeys);\n          _context18.prev = 19;\n          _loop3 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop3() {\n            var key, pubKey;\n            return _regeneratorRuntime().wrap(function _loop3$(_context17) {\n              while (1) switch (_context17.prev = _context17.next) {\n                case 0:\n                  key = _step5.value;\n                  pubKey = pubKeyfromPrivKey(key);\n                  pubKeys = pubKeys.filter(function (pk) {\n                    return pk !== bytesToHex(pubKey.data);\n                  });\n                  _signer3.signOrigin(createStacksPrivateKey(key));\n                case 4:\n                case \"end\":\n                  return _context17.stop();\n              }\n            }, _loop3);\n          });\n          _iterator5.s();\n        case 22:\n          if ((_step5 = _iterator5.n()).done) {\n            _context18.next = 26;\n            break;\n          }\n          return _context18.delegateYield(_loop3(), \"t0\", 24);\n        case 24:\n          _context18.next = 22;\n          break;\n        case 26:\n          _context18.next = 31;\n          break;\n        case 28:\n          _context18.prev = 28;\n          _context18.t1 = _context18[\"catch\"](19);\n          _iterator5.e(_context18.t1);\n        case 31:\n          _context18.prev = 31;\n          _iterator5.f();\n          return _context18.finish(31);\n        case 34:\n          _iterator6 = _createForOfIteratorHelper(pubKeys);\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              key = _step6.value;\n              _signer3.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n          return _context18.abrupt(\"return\", _transaction3);\n        case 37:\n        case \"end\":\n          return _context18.stop();\n      }\n    }, _callee15, null, [[19, 28, 31, 34]]);\n  }));\n  return _makeContractCall.apply(this, arguments);\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n  return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetId) {\n  return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetId);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetId) {\n  return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetId);\n}\nexport function callReadOnlyFunction(_x29) {\n  return _callReadOnlyFunction.apply(this, arguments);\n}\nfunction _callReadOnlyFunction() {\n  _callReadOnlyFunction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(readOnlyFunctionOptions) {\n    var defaultOptions, options, contractName, contractAddress, functionName, functionArgs, senderAddress, network, url, args, body, response, msg;\n    return _regeneratorRuntime().wrap(function _callee16$(_context19) {\n      while (1) switch (_context19.prev = _context19.next) {\n        case 0:\n          defaultOptions = {\n            network: new StacksMainnet()\n          };\n          options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n          contractName = options.contractName, contractAddress = options.contractAddress, functionName = options.functionName, functionArgs = options.functionArgs, senderAddress = options.senderAddress;\n          network = StacksNetwork.fromNameOrNetwork(options.network);\n          url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n          args = functionArgs.map(function (arg) {\n            return cvToHex(arg);\n          });\n          body = JSON.stringify({\n            sender: senderAddress,\n            arguments: args\n          });\n          _context19.next = 9;\n          return network.fetchFn(url, {\n            method: 'POST',\n            body: body,\n            headers: {\n              'Content-Type': 'application/json'\n            }\n          });\n        case 9:\n          response = _context19.sent;\n          if (response.ok) {\n            _context19.next = 15;\n            break;\n          }\n          _context19.next = 13;\n          return response.text().catch(function () {\n            return '';\n          });\n        case 13:\n          msg = _context19.sent;\n          throw new Error(\"Error calling read-only function. Response \".concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n        case 15:\n          return _context19.abrupt(\"return\", response.json().then(function (responseJson) {\n            return parseReadOnlyResponse(responseJson);\n          }));\n        case 16:\n        case \"end\":\n          return _context19.stop();\n      }\n    }, _callee16);\n  }));\n  return _callReadOnlyFunction.apply(this, arguments);\n}\nexport function getContractMapEntry(_x30) {\n  return _getContractMapEntry.apply(this, arguments);\n}\nfunction _getContractMapEntry() {\n  _getContractMapEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(getContractMapEntryOptions) {\n    var defaultOptions, _Object$assign, contractAddress, contractName, mapName, mapKey, network, derivedNetwork, url, serializedKeyBytes, serializedKeyHex, fetchOptions, response, msg, responseBody, responseJson, deserializedCv;\n    return _regeneratorRuntime().wrap(function _callee17$(_context20) {\n      while (1) switch (_context20.prev = _context20.next) {\n        case 0:\n          defaultOptions = {\n            network: new StacksMainnet()\n          };\n          _Object$assign = Object.assign(defaultOptions, getContractMapEntryOptions), contractAddress = _Object$assign.contractAddress, contractName = _Object$assign.contractName, mapName = _Object$assign.mapName, mapKey = _Object$assign.mapKey, network = _Object$assign.network;\n          derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n          url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);\n          serializedKeyBytes = serializeCV(mapKey);\n          serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);\n          fetchOptions = {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              Accept: 'application/json'\n            },\n            body: JSON.stringify(serializedKeyHex)\n          };\n          _context20.next = 9;\n          return derivedNetwork.fetchFn(url, fetchOptions);\n        case 9:\n          response = _context20.sent;\n          if (response.ok) {\n            _context20.next = 15;\n            break;\n          }\n          _context20.next = 13;\n          return response.text().catch(function () {\n            return '';\n          });\n        case 13:\n          msg = _context20.sent;\n          throw new Error(\"Error fetching map entry for map \\\"\".concat(mapName, \"\\\" in contract \\\"\").concat(contractName, \"\\\" at address \").concat(contractAddress, \", using map key \\\"\").concat(serializedKeyHex, \"\\\". Response \").concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the message: \\\"\").concat(msg, \"\\\"\"));\n        case 15:\n          _context20.next = 17;\n          return response.text();\n        case 17:\n          responseBody = _context20.sent;\n          responseJson = JSON.parse(responseBody);\n          if (responseJson.data) {\n            _context20.next = 21;\n            break;\n          }\n          throw new Error(\"Error fetching map entry for map \\\"\".concat(mapName, \"\\\" in contract \\\"\").concat(contractName, \"\\\" at address \").concat(contractAddress, \", using map key \\\"\").concat(serializedKeyHex, \"\\\". Response \").concat(response.status, \": \").concat(response.statusText, \". Attempted to fetch \").concat(url, \" and failed with the response: \\\"\").concat(responseBody, \"\\\"\"));\n        case 21:\n          _context20.prev = 21;\n          deserializedCv = deserializeCV(responseJson.data);\n          _context20.next = 28;\n          break;\n        case 25:\n          _context20.prev = 25;\n          _context20.t0 = _context20[\"catch\"](21);\n          throw new Error(\"Error deserializing Clarity value \\\"\".concat(responseJson.data, \"\\\": \").concat(_context20.t0));\n        case 28:\n          return _context20.abrupt(\"return\", deserializedCv);\n        case 29:\n        case \"end\":\n          return _context20.stop();\n      }\n    }, _callee17, null, [[21, 25]]);\n  }));\n  return _getContractMapEntry.apply(this, arguments);\n}\nexport function sponsorTransaction(_x31) {\n  return _sponsorTransaction.apply(this, arguments);\n}\nfunction _sponsorTransaction() {\n  _sponsorTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(sponsorOptions) {\n    var defaultOptions, options, network, sponsorPubKey, txFee, estimatedLen, addressVersion, senderAddress, sponsorNonce, sponsorSpendingCondition, privKey, signer;\n    return _regeneratorRuntime().wrap(function _callee18$(_context21) {\n      while (1) switch (_context21.prev = _context21.next) {\n        case 0:\n          defaultOptions = {\n            fee: 0,\n            sponsorNonce: 0,\n            sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,\n            network: sponsorOptions.transaction.version === TransactionVersion.Mainnet ? new StacksMainnet() : new StacksTestnet()\n          };\n          options = Object.assign(defaultOptions, sponsorOptions);\n          network = StacksNetwork.fromNameOrNetwork(options.network);\n          sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n          if (!(sponsorOptions.fee === undefined || sponsorOptions.fee === null)) {\n            _context21.next = 23;\n            break;\n          }\n          txFee = 0;\n          _context21.t0 = options.transaction.payload.payloadType;\n          _context21.next = _context21.t0 === PayloadType.TokenTransfer ? 9 : _context21.t0 === PayloadType.SmartContract ? 9 : _context21.t0 === PayloadType.VersionedSmartContract ? 9 : _context21.t0 === PayloadType.ContractCall ? 9 : 20;\n          break;\n        case 9:\n          estimatedLen = estimateTransactionByteLength(options.transaction);\n          _context21.prev = 10;\n          _context21.next = 13;\n          return estimateTransaction(options.transaction.payload, estimatedLen, network);\n        case 13:\n          txFee = _context21.sent[1].fee;\n          _context21.next = 19;\n          break;\n        case 16:\n          _context21.prev = 16;\n          _context21.t1 = _context21[\"catch\"](10);\n          throw _context21.t1;\n        case 19:\n          return _context21.abrupt(\"break\", 21);\n        case 20:\n          throw new Error(\"Sponsored transactions not supported for transaction type \".concat(PayloadType[options.transaction.payload.payloadType]));\n        case 21:\n          options.transaction.setFee(txFee);\n          options.fee = txFee;\n        case 23:\n          if (!(sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null)) {\n            _context21.next = 30;\n            break;\n          }\n          addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n          senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n          _context21.next = 28;\n          return getNonce(senderAddress, network);\n        case 28:\n          sponsorNonce = _context21.sent;\n          options.sponsorNonce = sponsorNonce;\n        case 30:\n          sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n          options.transaction.setSponsor(sponsorSpendingCondition);\n          privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n          signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n          signer.signSponsor(privKey);\n          return _context21.abrupt(\"return\", signer.transaction);\n        case 36:\n        case \"end\":\n          return _context21.stop();\n      }\n    }, _callee18, null, [[10, 16]]);\n  }));\n  return _sponsorTransaction.apply(this, arguments);\n}\nexport function estimateTransactionByteLength(transaction) {\n  var hashMode = transaction.auth.spendingCondition.hashMode;\n  var multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n  if (multiSigHashModes.includes(hashMode)) {\n    var multiSigSpendingCondition = transaction.auth.spendingCondition;\n    var existingSignatures = multiSigSpendingCondition.fields.filter(function (field) {\n      return field.contents.type === StacksMessageType.MessageSignature;\n    }).length;\n    var totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) * (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    return transaction.serialize().byteLength;\n  }\n}\nexport function estimateTransactionFeeWithFallback(_x32, _x33) {\n  return _estimateTransactionFeeWithFallback.apply(this, arguments);\n}\nfunction _estimateTransactionFeeWithFallback() {\n  _estimateTransactionFeeWithFallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(transaction, network) {\n    var estimatedLen;\n    return _regeneratorRuntime().wrap(function _callee19$(_context22) {\n      while (1) switch (_context22.prev = _context22.next) {\n        case 0:\n          _context22.prev = 0;\n          estimatedLen = estimateTransactionByteLength(transaction);\n          _context22.next = 4;\n          return estimateTransaction(transaction.payload, estimatedLen, network);\n        case 4:\n          return _context22.abrupt(\"return\", _context22.sent[1].fee);\n        case 7:\n          _context22.prev = 7;\n          _context22.t0 = _context22[\"catch\"](0);\n          if (!(_context22.t0 instanceof NoEstimateAvailableError)) {\n            _context22.next = 13;\n            break;\n          }\n          _context22.next = 12;\n          return estimateTransferUnsafe(transaction, network);\n        case 12:\n          return _context22.abrupt(\"return\", _context22.sent);\n        case 13:\n          throw _context22.t0;\n        case 14:\n        case \"end\":\n          return _context22.stop();\n      }\n    }, _callee19, null, [[0, 7]]);\n  }));\n  return _estimateTransactionFeeWithFallback.apply(this, arguments);\n}","map":{"version":3,"names":["bytesToHex","hexToBytes","intToBigInt","StacksNetwork","StacksMainnet","StacksTestnet","createFetchFn","c32address","createMultiSigSpendingCondition","createSingleSigSpendingCondition","createSponsoredAuth","createStandardAuth","deserializeCV","serializeCV","AddressHashMode","AddressVersion","PayloadType","PostConditionMode","TransactionVersion","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","ClarityVersion","validateContractCall","NoEstimateAvailableError","createStacksPrivateKey","getPublicKey","pubKeyfromPrivKey","publicKeyFromBytes","publicKeyToAddress","publicKeyToString","createContractCallPayload","createSmartContractPayload","createTokenTransferPayload","serializePayload","createFungiblePostCondition","createNonFungiblePostCondition","createSTXPostCondition","createContractPrincipal","createStandardPrincipal","TransactionSigner","StacksTransaction","createLPList","cvToHex","omit","parseReadOnlyResponse","validateTxId","getNonce","_x","_x2","_getNonce","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","address","network","derivedNetwork","url","response","msg","responseText","result","wrap","_callee$","_context","prev","next","fromNameOrNetwork","getAccountApiUrl","fetchFn","sent","ok","text","t0","Error","concat","status","statusText","JSON","parse","abrupt","BigInt","nonce","stop","estimateTransfer","_x3","_x4","_estimateTransfer","_callee2","transaction","_callee2$","_context2","payload","payloadType","TokenTransfer","estimateTransferUnsafe","_x5","_x6","_estimateTransferUnsafe","_callee3","requestHeaders","fetchOptions","feeRateResult","txBytes","feeRate","_callee3$","_context3","Accept","method","headers","deriveNetwork","getTransferFeeEstimateApiUrl","serialize","byteLength","estimateTransaction","_x7","_x8","_x9","_estimateTransaction","_callee4","transactionPayload","estimatedLen","options","body","_body$reason_data$mes","_body$reason_data","data","_callee4$","_context4","stringify","_objectSpread","transaction_payload","estimated_len","getTransactionFeeEstimateApiUrl","json","catch","reason","reason_data","message","estimations","broadcastTransaction","_x10","_x11","_x12","_broadcastTransaction","_callee5","attachment","rawTx","_callee5$","_context5","getBroadcastApiUrl","broadcastRawTransaction","_x13","_x14","_x15","_broadcastRawTransaction","_callee6","txid","_args6","_callee6$","_context6","length","undefined","tx","replace","getAbi","_x16","_x17","_x18","_getAbi","_callee7","contractName","_callee7$","_context7","getAbiApiUrl","t1","call","version","Mainnet","Testnet","makeUnsignedSTXTokenTransfer","_x19","_makeUnsignedSTXTokenTransfer","_callee8","txOptions","defaultOptions","authorization","spendingCondition","fee","addressVersion","senderAddress","txNonce","_callee8$","_context8","memo","sponsored","Object","assign","recipient","amount","SerializeP2PKH","publicKey","SerializeP2SH","numSignatures","publicKeys","anchorMode","chainId","estimateTransactionFeeWithFallback","setFee","MainnetSingleSig","TestnetSingleSig","auth","signer","setNonce","makeSTXTokenTransfer","_x20","_makeSTXTokenTransfer","_callee9","privKey","_options","_transaction","_signer","pubKeys","_iterator","_step","_loop","_iterator2","_step2","key","_callee9$","_context10","senderKey","signOrigin","_createForOfIteratorHelper","signerKeys","pubKey","_loop$","_context9","value","filter","pk","s","n","done","delegateYield","e","f","finish","appendOrigin","err","estimateContractDeploy","_x21","_x22","_estimateContractDeploy","_callee10","_callee10$","_context11","SmartContract","VersionedSmartContract","makeContractDeploy","_x23","_makeContractDeploy","_callee11","_options2","_transaction2","_signer2","_iterator3","_step3","_loop2","_iterator4","_step4","_callee11$","_context13","makeUnsignedContractDeploy","_loop2$","_context12","_x24","_makeUnsignedContractDeploy","_callee12","postConditions","lpPostConditions","_callee12$","_context14","postConditionMode","Deny","clarityVersion","Clarity2","codeBody","forEach","postCondition","push","estimateContractFunctionCall","_x25","_x26","_estimateContractFunctionCall","_callee13","_callee13$","_context15","ContractCall","makeUnsignedContractCall","_x27","_makeUnsignedContractCall","_callee14","abi","_callee14$","_context16","contractAddress","functionName","functionArgs","validateWithAbi","makeContractCall","_x28","_makeContractCall","_callee15","_options3","_transaction3","_signer3","_iterator5","_step5","_loop3","_iterator6","_step6","_callee15$","_context18","_loop3$","_context17","makeStandardSTXPostCondition","conditionCode","makeContractSTXPostCondition","makeStandardFungiblePostCondition","assetInfo","makeContractFungiblePostCondition","makeStandardNonFungiblePostCondition","assetId","makeContractNonFungiblePostCondition","callReadOnlyFunction","_x29","_callReadOnlyFunction","_callee16","readOnlyFunctionOptions","args","_callee16$","_context19","getReadOnlyFunctionCallApiUrl","map","arg","sender","then","responseJson","getContractMapEntry","_x30","_getContractMapEntry","_callee17","getContractMapEntryOptions","_Object$assign","mapName","mapKey","serializedKeyBytes","serializedKeyHex","responseBody","deserializedCv","_callee17$","_context20","getMapEntryUrl","sponsorTransaction","_x31","_sponsorTransaction","_callee18","sponsorOptions","sponsorPubKey","txFee","sponsorNonce","sponsorSpendingCondition","_callee18$","_context21","sponsorAddressHashmode","sponsorPrivateKey","estimateTransactionByteLength","setSponsor","createSponsorSigner","signSponsor","hashMode","multiSigHashModes","SerializeP2WSH","includes","multiSigSpendingCondition","existingSignatures","fields","field","contents","type","MessageSignature","totalSignatureLength","signaturesRequired","_x32","_x33","_estimateTransactionFeeWithFallback","_callee19","_callee19$","_context22"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\builders.ts"],"sourcesContent":["import { bytesToHex, hexToBytes, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  StacksNetwork,\n  StacksMainnet,\n  StacksNetworkName,\n  StacksTestnet,\n  FetchFn,\n  createFetchFn,\n} from '@stacks/network';\nimport { c32address } from 'c32check';\nimport {\n  Authorization,\n  createMultiSigSpendingCondition,\n  createSingleSigSpendingCondition,\n  createSponsoredAuth,\n  createStandardAuth,\n  SpendingCondition,\n  MultiSigSpendingCondition,\n} from './authorization';\nimport { ClarityValue, deserializeCV, NoneCV, PrincipalCV, serializeCV } from './clarity';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  AnchorMode,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PayloadType,\n  PostConditionMode,\n  SingleSigHashMode,\n  TransactionVersion,\n  TxRejectedReason,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n  ClarityVersion,\n  AnchorModeName,\n} from './constants';\nimport { ClarityAbi, validateContractCall } from './contract-abi';\nimport { NoEstimateAvailableError } from './errors';\nimport {\n  createStacksPrivateKey,\n  getPublicKey,\n  pubKeyfromPrivKey,\n  publicKeyFromBytes,\n  publicKeyToAddress,\n  publicKeyToString,\n} from './keys';\nimport {\n  createContractCallPayload,\n  createSmartContractPayload,\n  createTokenTransferPayload,\n  Payload,\n  serializePayload,\n} from './payload';\nimport {\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n  createSTXPostCondition,\n} from './postcondition';\nimport {\n  AssetInfo,\n  createContractPrincipal,\n  createStandardPrincipal,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  PostCondition,\n  STXPostCondition,\n} from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\n\n/**\n * Lookup the nonce for an address from a core node\n *\n * @param {string} address - the c32check address to look up\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to look up address on\n *\n * @return a promise that resolves to an integer\n */\nexport async function getNonce(\n  address: string,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText) as { nonce: string };\n  return BigInt(result.nonce);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function instead.\n *\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  return estimateTransferUnsafe(transaction, network);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function instead.\n * @internal\n */\nexport async function estimateTransferUnsafe(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\n\ninterface FeeEstimation {\n  fee: number;\n  fee_rate: number;\n}\ninterface FeeEstimateResponse {\n  cost_scalar_change_by_byte: bigint;\n  estimated_cost: {\n    read_count: bigint;\n    read_length: bigint;\n    runtime: bigint;\n    write_count: bigint;\n    write_length: bigint;\n  };\n  estimated_cost_scalar: bigint;\n  estimations: [FeeEstimation, FeeEstimation, FeeEstimation];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a Stacks transaction\n *\n * @param {StacksTransaction} transaction - the transaction to estimate fees for\n * @param {number} estimatedLen - is an optional argument that provides the endpoint with an\n * estimation of the final length (in bytes) of the transaction, including any post-conditions\n * and signatures\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction fees for\n *\n * @return a promise that resolves to FeeEstimate\n */\nexport async function estimateTransaction(\n  transactionPayload: Payload,\n  estimatedLen?: number,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<[FeeEstimation, FeeEstimation, FeeEstimation]> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      transaction_payload: bytesToHex(serializePayload(transactionPayload)),\n      ...(estimatedLen ? { estimated_len: estimatedLen } : {}),\n    }),\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, options);\n\n  if (!response.ok) {\n    const body = await response.json().catch(() => ({}));\n\n    if (body?.reason === 'NoEstimateAvailable') {\n      throw new NoEstimateAvailableError(body?.reason_data?.message ?? '');\n    }\n\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${body}\"`\n    );\n  }\n\n  const data: FeeEstimateResponse = await response.json();\n  return data.estimations;\n}\n\nexport type SerializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Serialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type DeserializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Deserialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type SignatureValidationRejection = {\n  error: string;\n  reason: TxRejectedReason.SignatureValidation;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type BadNonceRejection = {\n  error: string;\n  reason: TxRejectedReason.BadNonce;\n  reason_data: {\n    expected: number;\n    actual: number;\n    is_origin: boolean;\n    principal: boolean;\n  };\n  txid: string;\n};\n\nexport type FeeTooLowRejection = {\n  error: string;\n  reason: TxRejectedReason.FeeTooLow;\n  reason_data: {\n    expected: number;\n    actual: number;\n  };\n  txid: string;\n};\n\nexport type NotEnoughFundsRejection = {\n  error: string;\n  reason: TxRejectedReason.NotEnoughFunds;\n  reason_data: {\n    expected: string;\n    actual: string;\n  };\n  txid: string;\n};\n\nexport type NoSuchContractRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchContract;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoSuchPublicFunctionRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchPublicFunction;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadFunctionArgumentRejection = {\n  error: string;\n  reason: TxRejectedReason.BadFunctionArgument;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ContractAlreadyExistsRejection = {\n  error: string;\n  reason: TxRejectedReason.ContractAlreadyExists;\n  reason_data: {\n    contract_identifier: string;\n  };\n  txid: string;\n};\n\nexport type PoisonMicroblocksDoNotConflictRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblocksDoNotConflict;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockHasUnknownPubKeyHashRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockHasUnknownPubKeyHash;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockIsInvalidRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockIsInvalid;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadAddressVersionByteRejection = {\n  error: string;\n  reason: TxRejectedReason.BadAddressVersionByte;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoCoinbaseViaMempoolRejection = {\n  error: string;\n  reason: TxRejectedReason.NoCoinbaseViaMempool;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureNoSuchChainTipRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureNoSuchChainTip;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureDatabaseRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureDatabase;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ServerFailureOtherRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureOther;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type TxBroadcastResultOk = {\n  txid: string;\n  error?: undefined;\n  reason?: undefined;\n  reason_data?: undefined;\n};\n\nexport type TxBroadcastResultRejected =\n  | SerializationRejection\n  | DeserializationRejection\n  | SignatureValidationRejection\n  | BadNonceRejection\n  | FeeTooLowRejection\n  | NotEnoughFundsRejection\n  | NoSuchContractRejection\n  | NoSuchPublicFunctionRejection\n  | BadFunctionArgumentRejection\n  | ContractAlreadyExistsRejection\n  | PoisonMicroblocksDoNotConflictRejection\n  | PoisonMicroblockHasUnknownPubKeyHashRejection\n  | PoisonMicroblockIsInvalidRejection\n  | BadAddressVersionByteRejection\n  | NoCoinbaseViaMempoolRejection\n  | ServerFailureNoSuchChainTipRejection\n  | ServerFailureDatabaseRejection\n  | ServerFailureOtherRejection;\n\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork,\n  attachment?: Uint8Array\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Uint8Array} rawTx - the raw serialized transaction bytes to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Uint8Array,\n  url: string,\n  attachment?: Uint8Array,\n  fetchFn: FetchFn = createFetchFn()\n): Promise<TxBroadcastResult> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n    body: attachment\n      ? JSON.stringify({\n          tx: bytesToHex(rawTx),\n          attachment: bytesToHex(attachment),\n        })\n      : rawTx,\n  };\n\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  // Replace extra quotes around txid string\n  const txid = text.replace(/[\"]+/g, '');\n  if (!validateTxId(txid)) throw new Error(text);\n  return { txid } as TxBroadcastResult;\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetworkName | StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nfunction deriveNetwork(transaction: StacksTransaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\n\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\n/**\n * STX token transfer transaction options\n */\nexport interface TokenTransferOptions {\n  /** the address of the recipient of the token transfer */\n  recipient: string | PrincipalCV;\n  /** the amount to be transfered in microstacks */\n  amount: IntegerType;\n  /** the transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** an arbitrary string to include in the transaction, must be less than 34 bytes */\n  memo?: string;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization: Authorization | null = null;\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    undefined, // no post conditions on STX transfers (see SIP-005)\n    undefined, // no post conditions on STX transfers (see SIP-005)\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // txOptions is SignedTokenTransferOptions\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // txOptions is SignedMultiSigTokenTransferOptions\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n */\nexport interface BaseContractDeployOptions {\n  clarityVersion?: ClarityVersion;\n  contractName: string;\n  /** the Clarity code to be deployed */\n  codeBody: string;\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the public key of the transaction sender */\n  publicKey: string;\n}\n\nexport interface SignedContractDeployOptions extends BaseContractDeployOptions {\n  senderKey: string;\n}\n\n/** @deprecated Use {@link SignedContractDeployOptions} or {@link UnsignedContractDeployOptions} instead. */\nexport interface ContractDeployOptions extends SignedContractDeployOptions {}\n\nexport interface UnsignedMultiSigContractDeployOptions extends BaseContractDeployOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractDeployOptions extends BaseContractDeployOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (\n    transaction.payload.payloadType !== PayloadType.SmartContract &&\n    transaction.payload.payloadType !== PayloadType.VersionedSmartContract\n  ) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param {SignedContractDeployOptions | SignedMultiSigContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: SignedContractDeployOptions | SignedMultiSigContractDeployOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // txOptions is SignedContractDeployOptions\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractDeploy({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // txOptions is SignedMultiSigContractDeployOptions\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractDeploy(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n\n    return transaction;\n  }\n}\n\nexport async function makeUnsignedContractDeploy(\n  txOptions: UnsignedContractDeployOptions | UnsignedMultiSigContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n    clarityVersion: ClarityVersion.Clarity2,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(\n    options.contractName,\n    options.codeBody,\n    options.clarityVersion\n  );\n\n  let authorization: Authorization | null = null;\n\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n */\nexport interface ContractCallOptions {\n  /** the Stacks address of the contract */\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  feeEstimateApiUrl?: string;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the Stacks blockchain network that will ultimately be used to broadcast this transaction */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true to validate that the supplied function args match those specified in\n   * the published contract */\n  validateWithAbi?: boolean | ClarityAbi;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition: SpendingCondition | null = null;\n  let authorization: Authorization | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens (denoted in micro-STX)\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address of the contract\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens (denoted in micro-STX)\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens (in their respective base unit)\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens (in their respective base unit)\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param {String} address - the c32check address\n * @param {FungibleConditionCode} conditionCode - the condition code\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetId: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetId\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param {String} address - the c32check address\n * @param {String} contractName - the name of the contract\n * @param {FungibleConditionCode} conditionCode - the condition code\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetId: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetId\n  );\n}\n\n/**\n * Read only function options\n *\n * @param {String} contractAddress - the c32check address of the contract\n * @param {String} contractName - the contract name\n * @param {String} functionName - name of the function to be called\n * @param {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** the network that the contract which contains the function is deployed to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** address of the sender */\n  senderAddress: string;\n}\n\n/**\n * Calls a function as read-only from a contract interface\n * It is not necessary that the function is defined as read-only in the contract\n *\n * @param {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\nexport interface GetContractMapEntryOptions {\n  /** the contracts address */\n  contractAddress: string;\n  /** the contracts name */\n  contractName: string;\n  /** the map name */\n  mapName: string;\n  /** key to lookup in the map */\n  mapKey: ClarityValue;\n  /** the network that has the contract */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Fetch data from a contract data map.\n * @param getContractMapEntryOptions - the options object\n * @returns\n * Promise that resolves to a ClarityValue if the operation succeeds.\n * Resolves to NoneCV if the map does not contain the given key, if the map does not exist, or if the contract prinicipal does not exist\n */\nexport async function getContractMapEntry<T extends ClarityValue = ClarityValue>(\n  getContractMapEntryOptions: GetContractMapEntryOptions\n): Promise<T | NoneCV> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n  const { contractAddress, contractName, mapName, mapKey, network } = Object.assign(\n    defaultOptions,\n    getContractMapEntryOptions\n  );\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);\n\n  const serializedKeyBytes = serializeCV(mapKey);\n  const serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);\n\n  const fetchOptions: RequestInit = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n    },\n    body: JSON.stringify(serializedKeyHex), // endpoint expects a JSON string atom (quote wrapped string)\n  };\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseBody = await response.text();\n  const responseJson: { data?: string } = JSON.parse(responseBody);\n  if (!responseJson.data) {\n    throw new Error(\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: \"${responseBody}\"`\n    );\n  }\n  let deserializedCv: T;\n  try {\n    deserializedCv = deserializeCV<T>(responseJson.data);\n  } catch (error) {\n    throw new Error(`Error deserializing Clarity value \"${responseJson.data}\": ${error}`);\n  }\n  return deserializedCv;\n}\n\n/**\n * Sponsored transaction options\n */\nexport interface SponsorOptionsOpts {\n  /** the origin-signed transaction */\n  transaction: StacksTransaction;\n  /** the sponsor's private key */\n  sponsorPrivateKey: string;\n  /** the transaction fee amount to sponsor */\n  fee?: IntegerType;\n  /** the nonce of the sponsor account */\n  sponsorNonce?: IntegerType;\n  /** the hashmode of the sponsor's address */\n  sponsorAddressHashmode?: AddressHashMode;\n  /** the Stacks blockchain network that this transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param {SponsorOptionsOpts} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptionsOpts\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: 0 as IntegerType,\n    sponsorNonce: 0 as IntegerType,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n    network:\n      sponsorOptions.transaction.version === TransactionVersion.Mainnet\n        ? new StacksMainnet()\n        : new StacksTestnet(),\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.VersionedSmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]\n            .fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(\n          `Sponsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return signer.transaction;\n}\n\n/**\n * Estimates transaction byte length\n * Context:\n * 1) Multi-sig transaction byte length increases by adding signatures\n *    which causes the incorrect fee estimation because the fee value is set while creating unsigned transaction\n * 2) Single-sig transaction byte length remain same due to empty message signature which allocates the space for signature\n * @param {transaction} - StacksTransaction object to be estimated\n * @return {number} Estimated transaction byte length\n */\nexport function estimateTransactionByteLength(transaction: StacksTransaction): number {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  // List of Multi-sig transaction hash modes\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n\n  // Check if its a Multi-sig transaction\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition: MultiSigSpendingCondition = transaction.auth\n      .spendingCondition as MultiSigSpendingCondition;\n\n    // Find number of existing signatures if the transaction is signed or partially signed\n    const existingSignatures = multiSigSpendingCondition.fields.filter(\n      field => field.contents.type === StacksMessageType.MessageSignature\n    ).length; // existingSignatures will be 0 if its a unsigned transaction\n\n    // Estimate total signature bytes size required for this multi-sig transaction\n    // Formula: totalSignatureLength = (signaturesRequired - existingSignatures) * (SIG_LEN_BYTES + 1 byte of type of signature)\n    const totalSignatureLength =\n      (multiSigSpendingCondition.signaturesRequired - existingSignatures) *\n      (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    // Single-sig transaction\n    // Signature space already allocated by empty message signature\n    return transaction.serialize().byteLength;\n  }\n}\n\n/**\n * Estimates the fee using {@link estimateTransfer} as a fallback if\n * {@link estimateTransaction} does not get an estimation due to the\n * {@link NoEstimateAvailableError} error.\n */\nexport async function estimateTransactionFeeWithFallback(\n  transaction: StacksTransaction,\n  network: StacksNetwork\n): Promise<bigint | number> {\n  try {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;\n  } catch (error) {\n    if (error instanceof NoEstimateAvailableError) {\n      return await estimateTransferUnsafe(transaction, network);\n    }\n    throw error;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}