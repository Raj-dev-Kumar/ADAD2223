{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nvar sha256_1 = require(\"@noble/hashes/sha256\");\nvar utils_1 = require(\"@noble/hashes/utils\");\nvar encoding_1 = require(\"./encoding\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n  var dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));\n  var checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));\n  return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n  if (version < 0 || version >= 32) {\n    throw new Error('Invalid version (must be between 0 and 31)');\n  }\n  if (!data.match(/^[0-9a-fA-F]*$/)) {\n    throw new Error('Invalid data (not a hex string)');\n  }\n  data = data.toLowerCase();\n  if (data.length % 2 !== 0) {\n    data = \"0\".concat(data);\n  }\n  var versionHex = version.toString(16);\n  if (versionHex.length === 1) {\n    versionHex = \"0\".concat(versionHex);\n  }\n  var checksumHex = c32checksum(\"\".concat(versionHex).concat(data));\n  var c32str = (0, encoding_1.c32encode)(\"\".concat(data).concat(checksumHex));\n  return \"\".concat(encoding_1.c32[version]).concat(c32str);\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n  c32data = (0, encoding_1.c32normalize)(c32data);\n  var dataHex = (0, encoding_1.c32decode)(c32data.slice(1));\n  var versionChar = c32data[0];\n  var version = encoding_1.c32.indexOf(versionChar);\n  var checksum = dataHex.slice(-8);\n  var versionHex = version.toString(16);\n  if (versionHex.length === 1) {\n    versionHex = \"0\".concat(versionHex);\n  }\n  if (c32checksum(\"\".concat(versionHex).concat(dataHex.substring(0, dataHex.length - 8))) !== checksum) {\n    throw new Error('Invalid c32check string: checksum mismatch');\n  }\n  return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;","map":{"version":3,"names":["Object","defineProperty","exports","value","c32checkDecode","c32checkEncode","sha256_1","require","utils_1","encoding_1","c32checksum","dataHex","dataHash","sha256","hexToBytes","checksum","bytesToHex","slice","version","data","Error","match","toLowerCase","length","concat","versionHex","toString","checksumHex","c32str","c32encode","c32","c32data","c32normalize","c32decode","versionChar","indexOf","substring"],"sources":["C:/Users/rajde/gitrep/deploy/frontend/node_modules/c32check/lib/checksum.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst encoding_1 = require(\"./encoding\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n    const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));\n    const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error('Invalid version (must be between 0 and 31)');\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Invalid data (not a hex string)');\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = `0${data}`;\n    }\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    const checksumHex = c32checksum(`${versionHex}${data}`);\n    const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);\n    return `${encoding_1.c32[version]}${c32str}`;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n    c32data = (0, encoding_1.c32normalize)(c32data);\n    const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));\n    const versionChar = c32data[0];\n    const version = encoding_1.c32.indexOf(versionChar);\n    const checksum = dataHex.slice(-8);\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {\n        throw new Error('Invalid c32check string: checksum mismatch');\n    }\n    return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}