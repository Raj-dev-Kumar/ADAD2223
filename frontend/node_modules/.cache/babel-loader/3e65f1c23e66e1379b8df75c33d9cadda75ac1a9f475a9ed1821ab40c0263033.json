{"ast":null,"code":"\"use strict\";\n\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nvar _createForOfIteratorHelper = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n  if (!Number.isSafeInteger(n)) throw new Error(\"Wrong integer: \".concat(n));\n}\nexports.assertNumber = assertNumber;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain() {\n  // Wrap call in closure so JIT can inline calls\n  var wrap = function wrap(a, b) {\n    return function (c) {\n      return a(b(c));\n    };\n  };\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var encode = Array.from(args).reverse().reduce(function (acc, i) {\n    return acc ? wrap(acc, i.encode) : i.encode;\n  }, undefined);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  var decode = args.reduce(function (acc, i) {\n    return acc ? wrap(acc, i.decode) : i.decode;\n  }, undefined);\n  return {\n    encode: encode,\n    decode: decode\n  };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n  return {\n    encode: function encode(digits) {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map(function (i) {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length) throw new Error(\"Digit index outside alphabet: \".concat(i, \" (alphabet: \").concat(alphabet.length, \")\"));\n        return alphabet[i];\n      });\n    },\n    decode: function decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n      return input.map(function (letter) {\n        if (typeof letter !== 'string') throw new Error(\"alphabet.decode: not string element=\".concat(letter));\n        var index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(\"Unknown letter: \\\"\".concat(letter, \"\\\". Allowed: \").concat(alphabet));\n        return index;\n      });\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join() {\n  var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: function encode(from) {\n      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n      var _iterator = _createForOfIteratorHelper(from),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var i = _step.value;\n          if (typeof i !== 'string') throw new Error(\"join.encode: non-string input=\".concat(i));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return from.join(separator);\n    },\n    decode: function decode(to) {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    }\n  };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits) {\n  var chr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '=';\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode: function encode(data) {\n      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      var _iterator2 = _createForOfIteratorHelper(data),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var i = _step2.value;\n          if (typeof i !== 'string') throw new Error(\"padding.encode: non-string input=\".concat(i));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      while (data.length * bits % 8) data.push(chr);\n      return data;\n    },\n    decode: function decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      var _iterator3 = _createForOfIteratorHelper(input),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var i = _step3.value;\n          if (typeof i !== 'string') throw new Error(\"padding.decode: non-string input=\".concat(i));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var end = input.length;\n      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return {\n    encode: function encode(from) {\n      return from;\n    },\n    decode: function decode(to) {\n      return fn(to);\n    }\n  };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n  // base 1 is impossible\n  if (from < 2) throw new Error(\"convertRadix: wrong from=\".concat(from, \", base cannot be less than 2\"));\n  if (to < 2) throw new Error(\"convertRadix: wrong to=\".concat(to, \", base cannot be less than 2\"));\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  var pos = 0;\n  var res = [];\n  var digits = Array.from(data);\n  digits.forEach(function (d) {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(\"Wrong integer: \".concat(d));\n  });\n  while (true) {\n    var carry = 0;\n    var done = true;\n    for (var i = pos; i < digits.length; i++) {\n      var digit = digits[i];\n      var digitBase = from * carry + digit;\n      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      var rounded = Math.floor(digitBase / to);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n      if (!done) continue;else if (!rounded) pos = i;else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (var _i = 0; _i < data.length - 1 && data[_i] === 0; _i++) res.push(0);\n  return res.reverse();\n}\nvar gcd = /* @__NO_SIDE_EFFECTS__ */function gcd(a, b) {\n  return !b ? a : gcd(b, a % b);\n};\nvar radix2carry = /*@__NO_SIDE_EFFECTS__ */function radix2carry(from, to) {\n  return from + (to - gcd(from, to));\n};\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(\"convertRadix2: wrong from=\".concat(from));\n  if (to <= 0 || to > 32) throw new Error(\"convertRadix2: wrong to=\".concat(to));\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\"convertRadix2: carry overflow from=\".concat(from, \" to=\").concat(to, \" carryBits=\").concat(radix2carry(from, to)));\n  }\n  var carry = 0;\n  var pos = 0; // bitwise position in current element\n  var mask = Math.pow(2, to) - 1;\n  var res = [];\n  var _iterator4 = _createForOfIteratorHelper(data),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var n = _step4.value;\n      assertNumber(n);\n      if (n >= Math.pow(2, from)) throw new Error(\"convertRadix2: invalid data word=\".concat(n, \" from=\").concat(from));\n      carry = carry << from | n;\n      if (pos + from > 32) throw new Error(\"convertRadix2: carry overflow pos=\".concat(pos, \" from=\").concat(from));\n      pos += from;\n      for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);\n      carry &= Math.pow(2, pos) - 1; // clean carry, otherwise it will cause overflow\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  carry = carry << to - pos & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(\"Non-zero padding: \".concat(carry));\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n  assertNumber(num);\n  return {\n    encode: function encode(bytes) {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), Math.pow(2, 8), num);\n    },\n    decode: function decode(digits) {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of strings');\n      return Uint8Array.from(convertRadix(digits, num, Math.pow(2, 8)));\n    }\n  };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits) {\n  var revPadding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n  return {\n    encode: function encode(bytes) {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: function decode(digits) {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of strings');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    }\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function () {\n    try {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode: function encode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array');\n      var checksum = fn(data).slice(0, len);\n      var res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode: function decode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array');\n      var payload = data.slice(0, -len);\n      var newChecksum = fn(payload).slice(0, len);\n      var oldChecksum = data.slice(-len);\n      for (var i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    }\n  };\n}\nexports.utils = {\n  alphabet: alphabet,\n  chain: chain,\n  checksum: checksum,\n  radix: radix,\n  radix2: radix2,\n  join: join,\n  padding: padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(function (s) {\n  return s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1');\n}));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nvar genBase58 = function genBase58(abc) {\n  return chain(radix(58), alphabet(abc), join(''));\n};\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nvar XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n  encode: function encode(data) {\n    var res = '';\n    for (var i = 0; i < data.length; i += 8) {\n      var block = data.subarray(i, i + 8);\n      res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n    }\n    return res;\n  },\n  decode: function decode(str) {\n    var res = [];\n    for (var i = 0; i < str.length; i += 11) {\n      var slice = str.slice(i, i + 11);\n      var blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      var block = exports.base58.decode(slice);\n      for (var j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  }\n};\nvar base58check = function base58check(sha256) {\n  return chain(checksum(4, function (data) {\n    return sha256(sha256(data));\n  }), exports.base58);\n};\nexports.base58check = base58check;\nvar BECH_ALPHABET = /* @__PURE__ */chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nvar POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n  var b = pre >> 25;\n  var chk = (pre & 0x1ffffff) << 5;\n  for (var i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n  }\n  return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words) {\n  var encodingConst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var len = prefix.length;\n  var chk = 1;\n  for (var i = 0; i < len; i++) {\n    var c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(\"Invalid prefix (\".concat(prefix, \")\"));\n    chk = bech32Polymod(chk) ^ c >> 5;\n  }\n  chk = bech32Polymod(chk);\n  for (var _i2 = 0; _i2 < len; _i2++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(_i2) & 0x1f;\n  var _iterator5 = _createForOfIteratorHelper(words),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var v = _step5.value;\n      chk = bech32Polymod(chk) ^ v;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  for (var _i3 = 0; _i3 < 6; _i3++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % Math.pow(2, 30)], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n  var ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  var _words = radix2(5);\n  var fromWords = _words.decode;\n  var toWords = _words.encode;\n  var fromWordsUnsafe = unsafeWrapper(fromWords);\n  function encode(prefix, words) {\n    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 90;\n    if (typeof prefix !== 'string') throw new Error(\"bech32.encode prefix should be string, not \".concat(typeof prefix));\n    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(\"bech32.encode words should be array of numbers, not \".concat(typeof words));\n    var actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit) throw new TypeError(\"Length \".concat(actualLength, \" exceeds limit \").concat(limit));\n    var lowered = prefix.toLowerCase();\n    var sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return \"\".concat(lowered, \"1\").concat(BECH_ALPHABET.encode(words)).concat(sum);\n  }\n  function decode(str) {\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 90;\n    if (typeof str !== 'string') throw new Error(\"bech32.decode input should be string, not \".concat(typeof str));\n    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(\"Wrong string length: \".concat(str.length, \" (\").concat(str, \"). Expected (8..\").concat(limit, \")\"));\n    // don't allow mixed case\n    var lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase()) throw new Error(\"String must be lowercase or uppercase\");\n    str = lowered;\n    var sepIndex = str.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1) throw new Error(\"Letter \\\"1\\\" must be present between prefix and data only\");\n    var prefix = str.slice(0, sepIndex);\n    var _words = str.slice(sepIndex + 1);\n    if (_words.length < 6) throw new Error('Data must be at least 6 characters long');\n    var words = BECH_ALPHABET.decode(_words).slice(0, -6);\n    var sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!_words.endsWith(sum)) throw new Error(\"Invalid checksum in \".concat(str, \": expected \\\"\").concat(sum, \"\\\"\"));\n    return {\n      prefix: prefix,\n      words: words\n    };\n  }\n  var decodeUnsafe = unsafeWrapper(decode);\n  function decodeToBytes(str) {\n    var _decode = decode(str, false),\n      prefix = _decode.prefix,\n      words = _decode.words;\n    return {\n      prefix: prefix,\n      words: words,\n      bytes: fromWords(words)\n    };\n  }\n  return {\n    encode: encode,\n    decode: decode,\n    decodeToBytes: decodeToBytes,\n    decodeUnsafe: decodeUnsafe,\n    fromWords: fromWords,\n    fromWordsUnsafe: fromWordsUnsafe,\n    toWords: toWords\n  };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n  encode: function encode(data) {\n    return new TextDecoder().decode(data);\n  },\n  decode: function decode(str) {\n    return new TextEncoder().encode(str);\n  }\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(function (s) {\n  if (typeof s !== 'string' || s.length % 2) throw new TypeError(\"hex.decode: expected string, got \".concat(typeof s, \" with length \").concat(s.length));\n  return s.toLowerCase();\n}));\n// prettier-ignore\nvar CODERS = {\n  utf8: exports.utf8,\n  hex: exports.hex,\n  base16: exports.base16,\n  base32: exports.base32,\n  base64: exports.base64,\n  base64url: exports.base64url,\n  base58: exports.base58,\n  base58xmr: exports.base58xmr\n};\nvar coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nvar bytesToString = function bytesToString(type, bytes) {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!(bytes instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\nvar stringToBytes = function stringToBytes(type, str) {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;","map":{"version":3,"names":["_createForOfIteratorHelper","require","default","Object","defineProperty","exports","value","bytes","stringToBytes","str","bytesToString","hex","utf8","bech32m","bech32","base58check","base58xmr","base58xrp","base58flickr","base58","base64urlnopad","base64url","base64","base32crockford","base32hex","base32","base16","utils","assertNumber","n","Number","isSafeInteger","Error","concat","chain","wrap","a","b","c","_len","arguments","length","args","Array","_key","encode","from","reverse","reduce","acc","i","undefined","decode","alphabet","digits","isArray","map","input","letter","index","indexOf","join","separator","_iterator","_step","s","done","err","e","f","to","split","padding","bits","chr","data","_iterator2","_step2","push","_iterator3","_step3","end","slice","normalize","fn","convertRadix","pos","res","forEach","d","carry","digit","digitBase","rounded","Math","floor","gcd","radix2carry","convertRadix2","mask","pow","_iterator4","_step4","radix","num","Uint8Array","radix2","revPadding","unsafeWrapper","_len2","_key2","apply","checksum","len","set","payload","newChecksum","oldChecksum","toUpperCase","replace","genBase58","abc","XMR_BLOCK_LEN","block","subarray","padStart","blockLen","j","sha256","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","charCodeAt","_iterator5","_step5","v","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","actualLength","TypeError","lowered","toLowerCase","sum","sepIndex","lastIndexOf","endsWith","decodeUnsafe","decodeToBytes","_decode","TextDecoder","TextEncoder","CODERS","coderTypeError","type","hasOwnProperty"],"sources":["C:/Users/rajde/gitrep/deploy/frontend/node_modules/@scure/base/lib/index.js"],"sourcesContent":["\"use strict\";\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\n// RFC 4648 aka RFC 3548\n// ---------------------\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}