{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { utf8ToBytes } from '@stacks/common';\nimport { decryptECIES, encryptECIES, signECDSA } from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\nexport function encryptContent(_x, _x2) {\n  return _encryptContent.apply(this, arguments);\n}\nfunction _encryptContent() {\n  _encryptContent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(content, options) {\n    var opts, privateKey, wasString, contentBytes, cipherObject, cipherPayload, signatureObject, signedCipherObject;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          opts = Object.assign({}, options);\n          if (opts.publicKey) {\n            _context.next = 5;\n            break;\n          }\n          if (opts.privateKey) {\n            _context.next = 4;\n            break;\n          }\n          throw new Error('Either public key or private key must be supplied for encryption.');\n        case 4:\n          opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n        case 5:\n          wasString = typeof opts.wasString === 'boolean' ? opts.wasString : typeof content === 'string';\n          contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n          _context.next = 9;\n          return encryptECIES(opts.publicKey, contentBytes, wasString, opts.cipherTextEncoding);\n        case 9:\n          cipherObject = _context.sent;\n          cipherPayload = JSON.stringify(cipherObject);\n          if (opts.sign) {\n            if (typeof opts.sign === 'string') {\n              privateKey = opts.sign;\n            } else if (!privateKey) {\n              privateKey = opts.privateKey;\n            }\n            signatureObject = signECDSA(privateKey, cipherPayload);\n            signedCipherObject = {\n              signature: signatureObject.signature,\n              publicKey: signatureObject.publicKey,\n              cipherText: cipherPayload\n            };\n            cipherPayload = JSON.stringify(signedCipherObject);\n          }\n          return _context.abrupt(\"return\", cipherPayload);\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _encryptContent.apply(this, arguments);\n}\nexport function decryptContent(content, options) {\n  var opts = Object.assign({}, options);\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n  try {\n    var cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"names":["utf8ToBytes","decryptECIES","encryptECIES","signECDSA","getPublicKeyFromPrivate","encryptContent","_x","_x2","_encryptContent","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","content","options","opts","privateKey","wasString","contentBytes","cipherObject","cipherPayload","signatureObject","signedCipherObject","wrap","_callee$","_context","prev","next","Object","assign","publicKey","Error","cipherTextEncoding","sent","JSON","stringify","sign","signature","cipherText","abrupt","stop","decryptContent","parse","err","SyntaxError"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\encryption\\src\\encryption.ts"],"sourcesContent":["import { utf8ToBytes } from '@stacks/common';\nimport {\n  CipherTextEncoding,\n  decryptECIES,\n  encryptECIES,\n  signECDSA,\n  SignedCipherObject,\n} from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\n\nexport interface EncryptionOptions {\n  /**\n   * If set to `true` the data is signed using ECDSA on SHA256 hashes with the user's\n   * app private key. If a string is specified, it is used as the private key instead\n   * of the user's app private key.\n   * @default false\n   */\n  sign?: boolean | string;\n  /**\n   * String encoding format for the cipherText bytes.\n   * Currently defaults to 'hex' for legacy backwards-compatibility.\n   * Only used if the `encrypt` option is also used.\n   * Note: in the future this should default to 'base64' for the significant\n   * file size reduction.\n   */\n  cipherTextEncoding?: CipherTextEncoding;\n  /**\n   * Specifies if the original unencrypted content is a ASCII or UTF-8 string.\n   * For example stringified JSON.\n   * If true, then when the ciphertext is decrypted, it will be returned as\n   * a `string` type variable, otherwise will be returned as bytes.\n   */\n  wasString?: boolean;\n}\n\n/**\n * Specify encryption options, and whether to sign the ciphertext.\n */\nexport interface EncryptContentOptions extends EncryptionOptions {\n  /**\n   * Encrypt the data with this key.\n   */\n  publicKey?: string;\n  /**\n   * Encrypt the data with the public key corresponding to the supplied private key\n   */\n  privateKey?: string;\n}\n\n/**\n * Encrypts the data provided with the app public key.\n * @param {string | Uint8Array} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\nexport async function encryptContent(\n  content: string | Uint8Array,\n  options?: EncryptContentOptions\n): Promise<string> {\n  const opts = Object.assign({}, options);\n  let privateKey: string | undefined;\n  if (!opts.publicKey) {\n    if (!opts.privateKey) {\n      throw new Error('Either public key or private key must be supplied for encryption.');\n    }\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n  }\n  const wasString =\n    typeof opts.wasString === 'boolean' ? opts.wasString : typeof content === 'string';\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const cipherObject = await encryptECIES(\n    opts.publicKey,\n    contentBytes,\n    wasString,\n    opts.cipherTextEncoding\n  );\n  let cipherPayload = JSON.stringify(cipherObject);\n  if (opts.sign) {\n    if (typeof opts.sign === 'string') {\n      privateKey = opts.sign;\n    } else if (!privateKey) {\n      privateKey = opts.privateKey;\n    }\n    const signatureObject = signECDSA(privateKey!, cipherPayload);\n    const signedCipherObject: SignedCipherObject = {\n      signature: signatureObject.signature,\n      publicKey: signatureObject.publicKey,\n      cipherText: cipherPayload,\n    };\n    cipherPayload = JSON.stringify(signedCipherObject);\n  }\n  return cipherPayload;\n}\n\n/**\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {string | Uint8Array} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {string} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {string | Uint8Array} decrypted content.\n */\nexport function decryptContent(\n  content: string,\n  options?: {\n    privateKey?: string;\n  }\n): Promise<string | Uint8Array> {\n  const opts = Object.assign({}, options);\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error(\n        'Failed to parse encrypted content JSON. The content may not ' +\n          'be encrypted. If using getFile, try passing { decrypt: false }.'\n      );\n    } else {\n      throw err;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}