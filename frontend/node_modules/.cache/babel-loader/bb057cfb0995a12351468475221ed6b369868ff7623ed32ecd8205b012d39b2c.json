{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenSigner = exports.createUnsecuredToken = void 0;\nvar base64url = require(\"./base64Url\");\nvar cryptoClients_1 = require(\"./cryptoClients\");\nvar errors_1 = require(\"./errors\");\nvar sha256_1 = require(\"./cryptoClients/sha256\");\nfunction createSigningInput(payload, header) {\n  var tokenParts = [];\n  // add in the header\n  var encodedHeader = base64url.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader);\n  // add in the payload\n  var encodedPayload = base64url.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload);\n  // prepare the message\n  var signingInput = tokenParts.join('.');\n  // return the signing input\n  return signingInput;\n}\nfunction createUnsecuredToken(payload) {\n  var header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\nexports.createUnsecuredToken = createUnsecuredToken;\nvar TokenSigner = /*#__PURE__*/function () {\n  function TokenSigner(signingAlgorithm, rawPrivateKey) {\n    _classCallCheck(this, TokenSigner);\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n  _createClass(TokenSigner, [{\n    key: \"header\",\n    value: function header() {\n      var _header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var defaultHeader = {\n        typ: this.tokenType,\n        alg: this.cryptoClient.algorithmName\n      };\n      return Object.assign({}, defaultHeader, _header);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(payload) {\n      var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      // generate the token header\n      var header = this.header(customHeader);\n      // prepare the message to be signed\n      var signingInput = createSigningInput(payload, header);\n      var signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n      return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    }\n  }, {\n    key: \"signAsync\",\n    value: function signAsync(payload) {\n      var expanded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var customHeader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var header, signingInput, signingInputHash;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // generate the token header\n              header = this.header(customHeader); // prepare the message to be signed\n              signingInput = createSigningInput(payload, header);\n              _context.next = 4;\n              return (0, sha256_1.hashSha256Async)(signingInput);\n            case 4:\n              signingInputHash = _context.sent;\n              return _context.abrupt(\"return\", this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash));\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"createWithSignedHash\",\n    value: function createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n      // sign the message and add in the signature\n      var signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n      if (expanded) {\n        var signedToken = {\n          header: [base64url.encode(JSON.stringify(header))],\n          payload: JSON.stringify(payload),\n          signature: [signature]\n        };\n        return signedToken;\n      } else {\n        return [signingInput, signature].join('.');\n      }\n    }\n  }]);\n  return TokenSigner;\n}();\nexports.TokenSigner = TokenSigner;","map":{"version":3,"names":["base64url","require","cryptoClients_1","errors_1","sha256_1","createSigningInput","payload","header","tokenParts","encodedHeader","encode","JSON","stringify","push","encodedPayload","signingInput","join","createUnsecuredToken","typ","alg","exports","TokenSigner","signingAlgorithm","rawPrivateKey","_classCallCheck","MissingParametersError","Error","toUpperCase","cryptoClients","hasOwnProperty","tokenType","cryptoClient","_createClass","key","value","arguments","length","undefined","defaultHeader","algorithmName","Object","assign","sign","expanded","customHeader","signingInputHash","hashSha256","createWithSignedHash","signAsync","_context","next","hashSha256Async","sent","abrupt","stop","_callee","signature","signHash","signedToken"],"sources":["signer.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}