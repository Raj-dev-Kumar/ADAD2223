{"ast":null,"code":"import { concatArray, intToBigInt, intToBytes, writeUInt32BE } from '@stacks/common';\nimport { ClarityVersion, COINBASE_BYTES_LENGTH, PayloadType, StacksMessageType } from './constants';\nimport { deserializeCV, serializeCV } from './clarity/';\nimport { principalCV } from './clarity/types/principalCV';\nimport { createAddress, createLPString } from './postcondition-types';\nimport { codeBodyString, createMemoString, deserializeAddress, deserializeLPString, deserializeMemoString, serializeStacksMessage } from './types';\nexport function isTokenTransferPayload(p) {\n  return p.payloadType === PayloadType.TokenTransfer;\n}\nexport function isContractCallPayload(p) {\n  return p.payloadType === PayloadType.ContractCall;\n}\nexport function isSmartContractPayload(p) {\n  return p.payloadType === PayloadType.SmartContract;\n}\nexport function isPoisonPayload(p) {\n  return p.payloadType === PayloadType.PoisonMicroblock;\n}\nexport function isCoinbasePayload(p) {\n  return p.payloadType === PayloadType.Coinbase;\n}\nexport function createTokenTransferPayload(recipient, amount, memo) {\n  var _memo;\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient: recipient,\n    amount: intToBigInt(amount, false),\n    memo: (_memo = memo) !== null && _memo !== void 0 ? _memo : createMemoString('')\n  };\n}\nexport function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress: contractAddress,\n    contractName: contractName,\n    functionName: functionName,\n    functionArgs: functionArgs\n  };\n}\nexport function createSmartContractPayload(contractName, codeBody, clarityVersion) {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n  if (typeof clarityVersion === 'number') {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.VersionedSmartContract,\n      clarityVersion: clarityVersion,\n      contractName: contractName,\n      codeBody: codeBody\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName: contractName,\n    codeBody: codeBody\n  };\n}\nexport function createPoisonPayload() {\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.PoisonMicroblock\n  };\n}\nexport function createCoinbasePayload(coinbaseBytes, altRecipient) {\n  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {\n    throw Error(\"Coinbase buffer size must be \".concat(COINBASE_BYTES_LENGTH, \" bytes\"));\n  }\n  if (altRecipient != undefined) {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.CoinbaseToAltRecipient,\n      coinbaseBytes: coinbaseBytes,\n      recipient: altRecipient\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.Coinbase,\n    coinbaseBytes: coinbaseBytes\n  };\n}\nexport function serializePayload(payload) {\n  var bytesArray = [];\n  bytesArray.push(payload.payloadType);\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bytesArray.push(serializeCV(payload.recipient));\n      bytesArray.push(intToBytes(payload.amount, false, 8));\n      bytesArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bytesArray.push(serializeStacksMessage(payload.contractAddress));\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.functionName));\n      var numArgs = new Uint8Array(4);\n      writeUInt32BE(numArgs, payload.functionArgs.length, 0);\n      bytesArray.push(numArgs);\n      payload.functionArgs.forEach(function (arg) {\n        bytesArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.VersionedSmartContract:\n      bytesArray.push(payload.clarityVersion);\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      break;\n    case PayloadType.Coinbase:\n      bytesArray.push(payload.coinbaseBytes);\n      break;\n    case PayloadType.CoinbaseToAltRecipient:\n      bytesArray.push(payload.coinbaseBytes);\n      bytesArray.push(serializeCV(payload.recipient));\n      break;\n  }\n  return concatArray(bytesArray);\n}\nexport function deserializePayload(bytesReader) {\n  var payloadType = bytesReader.readUInt8Enum(PayloadType, function (n) {\n    throw new Error(\"Cannot recognize PayloadType: \".concat(n));\n  });\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      var recipient = deserializeCV(bytesReader);\n      var amount = intToBigInt(bytesReader.readBytes(8), false);\n      var memo = deserializeMemoString(bytesReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      var contractAddress = deserializeAddress(bytesReader);\n      var contractCallName = deserializeLPString(bytesReader);\n      var functionName = deserializeLPString(bytesReader);\n      var functionArgs = [];\n      var numberOfArgs = bytesReader.readUInt32BE();\n      for (var i = 0; i < numberOfArgs; i++) {\n        var clarityValue = deserializeCV(bytesReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);\n    case PayloadType.SmartContract:\n      var smartContractName = deserializeLPString(bytesReader);\n      var codeBody = deserializeLPString(bytesReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n    case PayloadType.VersionedSmartContract:\n      {\n        var clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, function (n) {\n          throw new Error(\"Cannot recognize ClarityVersion: \".concat(n));\n        });\n        var _smartContractName = deserializeLPString(bytesReader);\n        var _codeBody = deserializeLPString(bytesReader, 4, 100000);\n        return createSmartContractPayload(_smartContractName, _codeBody, clarityVersion);\n      }\n    case PayloadType.PoisonMicroblock:\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      var coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      return createCoinbasePayload(coinbaseBytes);\n    case PayloadType.CoinbaseToAltRecipient:\n      var coinbaseToAltRecipientBuffer = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      var altRecipient = deserializeCV(bytesReader);\n      return createCoinbasePayload(coinbaseToAltRecipientBuffer, altRecipient);\n  }\n}","map":{"version":3,"names":["concatArray","intToBigInt","intToBytes","writeUInt32BE","ClarityVersion","COINBASE_BYTES_LENGTH","PayloadType","StacksMessageType","deserializeCV","serializeCV","principalCV","createAddress","createLPString","codeBodyString","createMemoString","deserializeAddress","deserializeLPString","deserializeMemoString","serializeStacksMessage","isTokenTransferPayload","p","payloadType","TokenTransfer","isContractCallPayload","ContractCall","isSmartContractPayload","SmartContract","isPoisonPayload","PoisonMicroblock","isCoinbasePayload","Coinbase","createTokenTransferPayload","recipient","amount","memo","_memo","type","Payload","createContractCallPayload","contractAddress","contractName","functionName","functionArgs","createSmartContractPayload","codeBody","clarityVersion","VersionedSmartContract","createPoisonPayload","createCoinbasePayload","coinbaseBytes","altRecipient","byteLength","Error","concat","undefined","CoinbaseToAltRecipient","serializePayload","payload","bytesArray","push","numArgs","Uint8Array","length","forEach","arg","deserializePayload","bytesReader","readUInt8Enum","n","readBytes","contractCallName","numberOfArgs","readUInt32BE","i","clarityValue","smartContractName","coinbaseToAltRecipientBuffer"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\payload.ts"],"sourcesContent":["import { concatArray, IntegerType, intToBigInt, intToBytes, writeUInt32BE } from '@stacks/common';\nimport { ClarityVersion, COINBASE_BYTES_LENGTH, PayloadType, StacksMessageType } from './constants';\n\nimport { BytesReader } from './bytesReader';\nimport { ClarityValue, deserializeCV, serializeCV } from './clarity/';\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\nimport { Address } from './common';\nimport { createAddress, createLPString, LengthPrefixedString } from './postcondition-types';\nimport {\n  codeBodyString,\n  createMemoString,\n  deserializeAddress,\n  deserializeLPString,\n  deserializeMemoString,\n  MemoString,\n  serializeStacksMessage,\n} from './types';\n\nexport type Payload =\n  | TokenTransferPayload\n  | ContractCallPayload\n  | SmartContractPayload\n  | VersionedSmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload\n  | CoinbasePayloadToAltRecipient;\n\nexport function isTokenTransferPayload(p: Payload): p is TokenTransferPayload {\n  return p.payloadType === PayloadType.TokenTransfer;\n}\nexport function isContractCallPayload(p: Payload): p is ContractCallPayload {\n  return p.payloadType === PayloadType.ContractCall;\n}\nexport function isSmartContractPayload(p: Payload): p is SmartContractPayload {\n  return p.payloadType === PayloadType.SmartContract;\n}\nexport function isPoisonPayload(p: Payload): p is PoisonPayload {\n  return p.payloadType === PayloadType.PoisonMicroblock;\n}\nexport function isCoinbasePayload(p: Payload): p is CoinbasePayload {\n  return p.payloadType === PayloadType.Coinbase;\n}\n\nexport interface TokenTransferPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TokenTransfer;\n  readonly recipient: PrincipalCV;\n  readonly amount: bigint;\n  readonly memo: MemoString;\n}\n\nexport type PayloadInput =\n  | (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & { amount: IntegerType }))\n  | ContractCallPayload\n  | SmartContractPayload\n  | VersionedSmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload\n  | CoinbasePayloadToAltRecipient;\n\nexport function createTokenTransferPayload(\n  recipient: string | PrincipalCV,\n  amount: IntegerType,\n  memo?: string | MemoString\n): TokenTransferPayload {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: memo ?? createMemoString(''),\n  };\n}\n\nexport interface ContractCallPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.ContractCall;\n  readonly contractAddress: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly functionName: LengthPrefixedString;\n  readonly functionArgs: ClarityValue[];\n}\n\nexport function createContractCallPayload(\n  contractAddress: string | Address,\n  contractName: string | LengthPrefixedString,\n  functionName: string | LengthPrefixedString,\n  functionArgs: ClarityValue[]\n): ContractCallPayload {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs,\n  };\n}\n\nexport interface SmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.SmartContract;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport interface VersionedSmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.VersionedSmartContract;\n  readonly clarityVersion: ClarityVersion;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport function createSmartContractPayload(\n  contractName: string | LengthPrefixedString,\n  codeBody: string | LengthPrefixedString,\n  clarityVersion?: ClarityVersion\n): SmartContractPayload | VersionedSmartContractPayload {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  if (typeof clarityVersion === 'number') {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.VersionedSmartContract,\n      clarityVersion,\n      contractName,\n      codeBody,\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody,\n  };\n}\n\nexport interface PoisonPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.PoisonMicroblock;\n}\n\nexport function createPoisonPayload(): PoisonPayload {\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\n\nexport interface CoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.Coinbase;\n  readonly coinbaseBytes: Uint8Array;\n}\n\nexport interface CoinbasePayloadToAltRecipient {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.CoinbaseToAltRecipient;\n  readonly coinbaseBytes: Uint8Array;\n  readonly recipient: PrincipalCV;\n}\n\nexport function createCoinbasePayload(\n  coinbaseBytes: Uint8Array,\n  altRecipient?: PrincipalCV\n): CoinbasePayload | CoinbasePayloadToAltRecipient {\n  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);\n  }\n\n  if (altRecipient != undefined) {\n    return {\n      type: StacksMessageType.Payload,\n      payloadType: PayloadType.CoinbaseToAltRecipient,\n      coinbaseBytes,\n      recipient: altRecipient,\n    };\n  }\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.Coinbase,\n    coinbaseBytes,\n  };\n}\n\nexport function serializePayload(payload: PayloadInput): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bytesArray.push(serializeCV(payload.recipient));\n      bytesArray.push(intToBytes(payload.amount, false, 8));\n      bytesArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bytesArray.push(serializeStacksMessage(payload.contractAddress));\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = new Uint8Array(4);\n      writeUInt32BE(numArgs, payload.functionArgs.length, 0);\n      bytesArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bytesArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.VersionedSmartContract:\n      bytesArray.push(payload.clarityVersion);\n      bytesArray.push(serializeStacksMessage(payload.contractName));\n      bytesArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      break;\n    case PayloadType.Coinbase:\n      bytesArray.push(payload.coinbaseBytes);\n      break;\n    case PayloadType.CoinbaseToAltRecipient:\n      bytesArray.push(payload.coinbaseBytes);\n      bytesArray.push(serializeCV(payload.recipient));\n      break;\n  }\n\n  return concatArray(bytesArray);\n}\n\nexport function deserializePayload(bytesReader: BytesReader): Payload {\n  const payloadType = bytesReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bytesReader) as PrincipalCV;\n      const amount = intToBigInt(bytesReader.readBytes(8), false);\n      const memo = deserializeMemoString(bytesReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bytesReader);\n      const contractCallName = deserializeLPString(bytesReader);\n      const functionName = deserializeLPString(bytesReader);\n      const functionArgs: ClarityValue[] = [];\n      const numberOfArgs = bytesReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bytesReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(\n        contractAddress,\n        contractCallName,\n        functionName,\n        functionArgs\n      );\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bytesReader);\n      const codeBody = deserializeLPString(bytesReader, 4, 100_000);\n      return createSmartContractPayload(smartContractName, codeBody);\n\n    case PayloadType.VersionedSmartContract: {\n      const clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, n => {\n        throw new Error(`Cannot recognize ClarityVersion: ${n}`);\n      });\n      const smartContractName = deserializeLPString(bytesReader);\n      const codeBody = deserializeLPString(bytesReader, 4, 100_000);\n      return createSmartContractPayload(smartContractName, codeBody, clarityVersion);\n    }\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      return createCoinbasePayload(coinbaseBytes);\n    case PayloadType.CoinbaseToAltRecipient:\n      const coinbaseToAltRecipientBuffer = bytesReader.readBytes(COINBASE_BYTES_LENGTH);\n      const altRecipient = deserializeCV(bytesReader) as PrincipalCV;\n      return createCoinbasePayload(coinbaseToAltRecipientBuffer, altRecipient);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}