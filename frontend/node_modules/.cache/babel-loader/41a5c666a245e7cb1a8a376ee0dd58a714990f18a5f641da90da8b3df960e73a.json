{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { bytesToHex, concatArray, hexToBytes, intToBigInt, intToBytes, writeUInt16BE } from '@stacks/common';\nimport { AddressHashMode, AuthType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { cloneDeep, leftPadHex, txidFromData } from './utils';\nimport { serializeMessageSignature, deserializeMessageSignature } from './signature';\nimport { addressFromPublicKeys, createEmptyAddress, createLPList, deserializeLPList, serializeLPList } from './types';\nimport { createStacksPublicKey, getPublicKey, isCompressed, publicKeyFromSignatureVrs, signWithKey } from './keys';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\nexport function emptyMessageSignature() {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: bytesToHex(new Uint8Array(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES))\n  };\n}\nexport function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {\n  var signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  var keyEncoding = isCompressed(createStacksPublicKey(pubKey)) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  return {\n    hashMode: hashMode,\n    signer: signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding: keyEncoding,\n    signature: emptyMessageSignature()\n  };\n}\nexport function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {\n  var stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n  var signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n  return {\n    hashMode: hashMode,\n    signer: signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs\n  };\n}\nexport function isSingleSig(condition) {\n  return 'signature' in condition;\n}\nfunction clearCondition(condition) {\n  var cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n  return _objectSpread(_objectSpread({}, cloned), {}, {\n    nonce: BigInt(0),\n    fee: BigInt(0)\n  });\n}\nexport function serializeSingleSigSpendingCondition(condition) {\n  var bytesArray = [condition.hashMode, hexToBytes(condition.signer), intToBytes(condition.nonce, false, 8), intToBytes(condition.fee, false, 8), condition.keyEncoding, serializeMessageSignature(condition.signature)];\n  return concatArray(bytesArray);\n}\nexport function serializeMultiSigSpendingCondition(condition) {\n  var bytesArray = [condition.hashMode, hexToBytes(condition.signer), intToBytes(condition.nonce, false, 8), intToBytes(condition.fee, false, 8)];\n  var fields = createLPList(condition.fields);\n  bytesArray.push(serializeLPList(fields));\n  var numSigs = new Uint8Array(2);\n  writeUInt16BE(numSigs, condition.signaturesRequired, 0);\n  bytesArray.push(numSigs);\n  return concatArray(bytesArray);\n}\nexport function deserializeSingleSigSpendingCondition(hashMode, bytesReader) {\n  var signer = bytesToHex(bytesReader.readBytes(20));\n  var nonce = BigInt(\"0x\".concat(bytesToHex(bytesReader.readBytes(8))));\n  var fee = BigInt(\"0x\".concat(bytesToHex(bytesReader.readBytes(8))));\n  var keyEncoding = bytesReader.readUInt8Enum(PubKeyEncoding, function (n) {\n    throw new DeserializationError(\"Could not parse \".concat(n, \" as PubKeyEncoding\"));\n  });\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n    throw new DeserializationError('Failed to parse singlesig spending condition: incomaptible hash mode and key encoding');\n  }\n  var signature = deserializeMessageSignature(bytesReader);\n  return {\n    hashMode: hashMode,\n    signer: signer,\n    nonce: nonce,\n    fee: fee,\n    keyEncoding: keyEncoding,\n    signature: signature\n  };\n}\nexport function deserializeMultiSigSpendingCondition(hashMode, bytesReader) {\n  var signer = bytesToHex(bytesReader.readBytes(20));\n  var nonce = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\n  var fee = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\n  var fields = deserializeLPList(bytesReader, StacksMessageType.TransactionAuthField).values;\n  var haveUncompressed = false;\n  var numSigs = 0;\n  var _iterator = _createForOfIteratorHelper(fields),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var field = _step.value;\n      switch (field.contents.type) {\n        case StacksMessageType.PublicKey:\n          if (!isCompressed(field.contents)) haveUncompressed = true;\n          break;\n        case StacksMessageType.MessageSignature:\n          if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n          numSigs += 1;\n          if (numSigs === 65536) throw new VerificationError('Failed to parse multisig spending condition: too many signatures');\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var signaturesRequired = bytesReader.readUInt16BE();\n  if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH) throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n  return {\n    hashMode: hashMode,\n    signer: signer,\n    nonce: nonce,\n    fee: fee,\n    fields: fields,\n    signaturesRequired: signaturesRequired\n  };\n}\nexport function serializeSpendingCondition(condition) {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  }\n  return serializeMultiSigSpendingCondition(condition);\n}\nexport function deserializeSpendingCondition(bytesReader) {\n  var hashMode = bytesReader.readUInt8Enum(AddressHashMode, function (n) {\n    throw new DeserializationError(\"Could not parse \".concat(n, \" as AddressHashMode\"));\n  });\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bytesReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bytesReader);\n  }\n}\nexport function makeSigHashPreSign(curSigHash, authType, fee, nonce) {\n  var hashLength = 32 + 1 + 8 + 8;\n  var sigHash = curSigHash + bytesToHex(new Uint8Array([authType])) + bytesToHex(intToBytes(fee, false, 8)) + bytesToHex(intToBytes(nonce, false, 8));\n  if (hexToBytes(sigHash).byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n  return txidFromData(hexToBytes(sigHash));\n}\nfunction makeSigHashPostSign(curSigHash, pubKey, signature) {\n  var hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n  var pubKeyEncoding = isCompressed(pubKey) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  var sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n  var sigHashBytes = hexToBytes(sigHash);\n  if (sigHashBytes.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n  return txidFromData(sigHashBytes);\n}\nexport function nextSignature(curSigHash, authType, fee, nonce, privateKey) {\n  var sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n  var signature = signWithKey(privateKey, sigHashPreSign);\n  var publicKey = getPublicKey(privateKey);\n  var nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    nextSig: signature,\n    nextSigHash: nextSigHash\n  };\n}\nexport function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {\n  var sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n  var publicKey = createStacksPublicKey(publicKeyFromSignatureVrs(sigHashPreSign, signature, pubKeyEncoding));\n  var nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    pubKey: publicKey,\n    nextSigHash: nextSigHash\n  };\n}\nfunction newInitialSigHash() {\n  var spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\nfunction verify(condition, initialSigHash, authType) {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return verifyMultiSig(condition, initialSigHash, authType);\n  }\n}\nfunction verifySingleSig(condition, initialSigHash, authType) {\n  var _nextVerification = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature),\n    pubKey = _nextVerification.pubKey,\n    nextSigHash = _nextVerification.nextSigHash;\n  var addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;\n  if (addrBytes !== condition.signer) throw new VerificationError(\"Signer hash does not equal hash of public key(s): \".concat(addrBytes, \" != \").concat(condition.signer));\n  return nextSigHash;\n}\nfunction verifyMultiSig(condition, initialSigHash, authType) {\n  var publicKeys = [];\n  var curSigHash = initialSigHash;\n  var haveUncompressed = false;\n  var numSigs = 0;\n  var _iterator2 = _createForOfIteratorHelper(condition.fields),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var field = _step2.value;\n      var foundPubKey = void 0;\n      switch (field.contents.type) {\n        case StacksMessageType.PublicKey:\n          if (!isCompressed(field.contents)) haveUncompressed = true;\n          foundPubKey = field.contents;\n          break;\n        case StacksMessageType.MessageSignature:\n          if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n          var _nextVerification2 = nextVerification(curSigHash, authType, condition.fee, condition.nonce, field.pubKeyEncoding, field.contents),\n            pubKey = _nextVerification2.pubKey,\n            nextSigHash = _nextVerification2.nextSigHash;\n          curSigHash = nextSigHash;\n          foundPubKey = pubKey;\n          numSigs += 1;\n          if (numSigs === 65536) throw new VerificationError('Too many signatures');\n          break;\n      }\n      publicKeys.push(foundPubKey);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (numSigs !== condition.signaturesRequired) throw new VerificationError('Incorrect number of signatures');\n  if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH) throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n  var addrBytes = addressFromPublicKeys(0, condition.hashMode, condition.signaturesRequired, publicKeys).hash160;\n  if (addrBytes !== condition.signer) throw new VerificationError(\"Signer hash does not equal hash of public key(s): \".concat(addrBytes, \" != \").concat(condition.signer));\n  return curSigHash;\n}\nexport function createStandardAuth(spendingCondition) {\n  return {\n    authType: AuthType.Standard,\n    spendingCondition: spendingCondition\n  };\n}\nexport function createSponsoredAuth(spendingCondition, sponsorSpendingCondition) {\n  return {\n    authType: AuthType.Sponsored,\n    spendingCondition: spendingCondition,\n    sponsorSpendingCondition: sponsorSpendingCondition ? sponsorSpendingCondition : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0)\n  };\n}\nexport function intoInitialSighashAuth(auth) {\n  if (auth.spendingCondition) {\n    switch (auth.authType) {\n      case AuthType.Standard:\n        return createStandardAuth(clearCondition(auth.spendingCondition));\n      case AuthType.Sponsored:\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n      default:\n        throw new SigningError('Unexpected authorization type for signing');\n    }\n  }\n  throw new Error('Authorization missing SpendingCondition');\n}\nexport function verifyOrigin(auth, initialSigHash) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    case AuthType.Sponsored:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    default:\n      throw new SigningError('Invalid origin auth type');\n  }\n}\nexport function setFee(auth, amount) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      var spendingCondition = _objectSpread(_objectSpread({}, auth.spendingCondition), {}, {\n        fee: intToBigInt(amount, false)\n      });\n      return _objectSpread(_objectSpread({}, auth), {}, {\n        spendingCondition: spendingCondition\n      });\n    case AuthType.Sponsored:\n      var sponsorSpendingCondition = _objectSpread(_objectSpread({}, auth.sponsorSpendingCondition), {}, {\n        fee: intToBigInt(amount, false)\n      });\n      return _objectSpread(_objectSpread({}, auth), {}, {\n        sponsorSpendingCondition: sponsorSpendingCondition\n      });\n  }\n}\nexport function getFee(auth) {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return auth.spendingCondition.fee;\n    case AuthType.Sponsored:\n      return auth.sponsorSpendingCondition.fee;\n  }\n}\nexport function setNonce(auth, nonce) {\n  var spendingCondition = _objectSpread(_objectSpread({}, auth.spendingCondition), {}, {\n    nonce: intToBigInt(nonce, false)\n  });\n  return _objectSpread(_objectSpread({}, auth), {}, {\n    spendingCondition: spendingCondition\n  });\n}\nexport function setSponsorNonce(auth, nonce) {\n  var sponsorSpendingCondition = _objectSpread(_objectSpread({}, auth.sponsorSpendingCondition), {}, {\n    nonce: intToBigInt(nonce, false)\n  });\n  return _objectSpread(_objectSpread({}, auth), {}, {\n    sponsorSpendingCondition: sponsorSpendingCondition\n  });\n}\nexport function setSponsor(auth, sponsorSpendingCondition) {\n  var sc = _objectSpread(_objectSpread({}, sponsorSpendingCondition), {}, {\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n    fee: intToBigInt(sponsorSpendingCondition.fee, false)\n  });\n  return _objectSpread(_objectSpread({}, auth), {}, {\n    sponsorSpendingCondition: sc\n  });\n}\nexport function serializeAuthorization(auth) {\n  var bytesArray = [];\n  bytesArray.push(auth.authType);\n  switch (auth.authType) {\n    case AuthType.Standard:\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\n      break;\n    case AuthType.Sponsored:\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\n      bytesArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n      break;\n  }\n  return concatArray(bytesArray);\n}\nexport function deserializeAuthorization(bytesReader) {\n  var authType = bytesReader.readUInt8Enum(AuthType, function (n) {\n    throw new DeserializationError(\"Could not parse \".concat(n, \" as AuthType\"));\n  });\n  var spendingCondition;\n  switch (authType) {\n    case AuthType.Standard:\n      spendingCondition = deserializeSpendingCondition(bytesReader);\n      return createStandardAuth(spendingCondition);\n    case AuthType.Sponsored:\n      spendingCondition = deserializeSpendingCondition(bytesReader);\n      var sponsorSpendingCondition = deserializeSpendingCondition(bytesReader);\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n  }\n}","map":{"version":3,"names":["bytesToHex","concatArray","hexToBytes","intToBigInt","intToBytes","writeUInt16BE","AddressHashMode","AuthType","PubKeyEncoding","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","cloneDeep","leftPadHex","txidFromData","serializeMessageSignature","deserializeMessageSignature","addressFromPublicKeys","createEmptyAddress","createLPList","deserializeLPList","serializeLPList","createStacksPublicKey","getPublicKey","isCompressed","publicKeyFromSignatureVrs","signWithKey","DeserializationError","SigningError","VerificationError","emptyMessageSignature","type","MessageSignature","data","Uint8Array","createSingleSigSpendingCondition","hashMode","pubKey","nonce","fee","signer","hash160","keyEncoding","Compressed","Uncompressed","signature","createMultiSigSpendingCondition","numSigs","pubKeys","stacksPublicKeys","map","fields","signaturesRequired","isSingleSig","condition","clearCondition","cloned","_objectSpread","BigInt","serializeSingleSigSpendingCondition","bytesArray","serializeMultiSigSpendingCondition","push","deserializeSingleSigSpendingCondition","bytesReader","readBytes","concat","readUInt8Enum","n","SerializeP2WPKH","deserializeMultiSigSpendingCondition","TransactionAuthField","values","haveUncompressed","_iterator","_createForOfIteratorHelper","_step","s","done","field","value","contents","PublicKey","pubKeyEncoding","err","e","f","readUInt16BE","SerializeP2SH","serializeSpendingCondition","deserializeSpendingCondition","SerializeP2PKH","makeSigHashPreSign","curSigHash","authType","hashLength","sigHash","byteLength","Error","makeSigHashPostSign","toString","sigHashBytes","nextSignature","privateKey","sigHashPreSign","publicKey","nextSigHash","nextSig","nextVerification","initialSigHash","newInitialSigHash","spendingCondition","verify","verifySingleSig","verifyMultiSig","_nextVerification","addrBytes","publicKeys","_iterator2","_step2","foundPubKey","_nextVerification2","createStandardAuth","Standard","createSponsoredAuth","sponsorSpendingCondition","Sponsored","repeat","intoInitialSighashAuth","auth","verifyOrigin","setFee","amount","getFee","setNonce","setSponsorNonce","setSponsor","sc","serializeAuthorization","deserializeAuthorization"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\authorization.ts"],"sourcesContent":["import {\n  bytesToHex,\n  concatArray,\n  hexToBytes,\n  IntegerType,\n  intToBigInt,\n  intToBytes,\n  writeUInt16BE,\n} from '@stacks/common';\nimport {\n  AddressHashMode,\n  AuthType,\n  MultiSigHashMode,\n  PubKeyEncoding,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  SingleSigHashMode,\n  StacksMessageType,\n} from './constants';\n\nimport { cloneDeep, leftPadHex, txidFromData } from './utils';\nimport {\n  TransactionAuthField,\n  serializeMessageSignature,\n  deserializeMessageSignature,\n} from './signature';\nimport {\n  addressFromPublicKeys,\n  createEmptyAddress,\n  createLPList,\n  deserializeLPList,\n  serializeLPList,\n} from './types';\n\nimport {\n  createStacksPublicKey,\n  getPublicKey,\n  isCompressed,\n  publicKeyFromSignatureVrs,\n  signWithKey,\n  StacksPrivateKey,\n  StacksPublicKey,\n} from './keys';\n\nimport { MessageSignature } from './common';\nimport { DeserializationError, SigningError, VerificationError } from './errors';\nimport { BytesReader } from './bytesReader';\n\nexport function emptyMessageSignature(): MessageSignature {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: bytesToHex(new Uint8Array(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)),\n  };\n}\n\nexport interface SingleSigSpendingCondition {\n  hashMode: SingleSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  keyEncoding: PubKeyEncoding;\n  signature: MessageSignature;\n}\n\nexport interface SingleSigSpendingConditionOpts\n  extends Omit<SingleSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport interface MultiSigSpendingCondition {\n  hashMode: MultiSigHashMode;\n  signer: string;\n  nonce: bigint;\n  fee: bigint;\n  fields: TransactionAuthField[];\n  signaturesRequired: number;\n}\n\nexport interface MultiSigSpendingConditionOpts\n  extends Omit<MultiSigSpendingCondition, 'nonce' | 'fee'> {\n  nonce: IntegerType;\n  fee: IntegerType;\n}\n\nexport type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;\n\nexport type SpendingConditionOpts = SingleSigSpendingConditionOpts | MultiSigSpendingConditionOpts;\n\nexport function createSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  pubKey: string,\n  nonce: IntegerType,\n  fee: IntegerType\n): SingleSigSpendingCondition {\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    hashMode,\n    1,\n    [createStacksPublicKey(pubKey)]\n  ).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding,\n    signature: emptyMessageSignature(),\n  };\n}\n\nexport function createMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  numSigs: number,\n  pubKeys: string[],\n  nonce: IntegerType,\n  fee: IntegerType\n): MultiSigSpendingCondition {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    hashMode,\n    numSigs,\n    stacksPublicKeys\n  ).hash160;\n\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs,\n  };\n}\n\nexport function isSingleSig(\n  condition: SpendingConditionOpts\n): condition is SingleSigSpendingConditionOpts {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition: SpendingConditionOpts): SpendingCondition {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return {\n    ...cloned,\n    nonce: BigInt(0),\n    fee: BigInt(0),\n  };\n}\n\nexport function serializeSingleSigSpendingCondition(\n  condition: SingleSigSpendingConditionOpts\n): Uint8Array {\n  const bytesArray = [\n    condition.hashMode,\n    hexToBytes(condition.signer),\n    intToBytes(condition.nonce, false, 8),\n    intToBytes(condition.fee, false, 8),\n    condition.keyEncoding as number,\n    serializeMessageSignature(condition.signature),\n  ];\n  return concatArray(bytesArray);\n}\n\nexport function serializeMultiSigSpendingCondition(\n  condition: MultiSigSpendingConditionOpts\n): Uint8Array {\n  const bytesArray = [\n    condition.hashMode,\n    hexToBytes(condition.signer),\n    intToBytes(condition.nonce, false, 8),\n    intToBytes(condition.fee, false, 8),\n  ];\n\n  const fields = createLPList(condition.fields);\n  bytesArray.push(serializeLPList(fields));\n\n  const numSigs = new Uint8Array(2);\n  writeUInt16BE(numSigs, condition.signaturesRequired, 0);\n  bytesArray.push(numSigs);\n\n  return concatArray(bytesArray);\n}\n\nexport function deserializeSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  bytesReader: BytesReader\n): SingleSigSpendingCondition {\n  const signer = bytesToHex(bytesReader.readBytes(20));\n  const nonce = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n  const fee = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);\n\n  const keyEncoding = bytesReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  if (hashMode === AddressHashMode.SerializeP2WPKH && keyEncoding != PubKeyEncoding.Compressed) {\n    throw new DeserializationError(\n      'Failed to parse singlesig spending condition: incomaptible hash mode and key encoding'\n    );\n  }\n  const signature = deserializeMessageSignature(bytesReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature,\n  };\n}\n\nexport function deserializeMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  bytesReader: BytesReader\n): MultiSigSpendingCondition {\n  const signer = bytesToHex(bytesReader.readBytes(20));\n  const nonce = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\n  const fee = BigInt('0x' + bytesToHex(bytesReader.readBytes(8)));\n\n  const fields = deserializeLPList(bytesReader, StacksMessageType.TransactionAuthField)\n    .values as TransactionAuthField[];\n\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of fields) {\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        numSigs += 1;\n        if (numSigs === 65536)\n          throw new VerificationError(\n            'Failed to parse multisig spending condition: too many signatures'\n          );\n        break;\n    }\n  }\n  const signaturesRequired = bytesReader.readUInt16BE();\n\n  // Partially signed multi-sig tx can be serialized and deserialized without exception (Incorrect number of signatures)\n  // No need to check numSigs !== signaturesRequired to throw Incorrect number of signatures error\n\n  if (haveUncompressed && hashMode === AddressHashMode.SerializeP2SH)\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired,\n  };\n}\n\nexport function serializeSpendingCondition(condition: SpendingConditionOpts): Uint8Array {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  }\n  return serializeMultiSigSpendingCondition(condition);\n}\n\nexport function deserializeSpendingCondition(bytesReader: BytesReader): SpendingCondition {\n  const hashMode = bytesReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bytesReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bytesReader);\n  }\n}\n\nexport function makeSigHashPreSign(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType\n): string {\n  // new hash combines the previous hash and all the new data this signature will add. This\n  // includes:\n  // * the previous hash\n  // * the auth flag\n  // * the tx fee (big-endian 8-byte number)\n  // * nonce (big-endian 8-byte number)\n  const hashLength = 32 + 1 + 8 + 8;\n\n  const sigHash =\n    curSigHash +\n    bytesToHex(new Uint8Array([authType])) +\n    bytesToHex(intToBytes(fee, false, 8)) +\n    bytesToHex(intToBytes(nonce, false, 8));\n\n  if (hexToBytes(sigHash).byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(hexToBytes(sigHash));\n}\n\nfunction makeSigHashPostSign(\n  curSigHash: string,\n  pubKey: StacksPublicKey,\n  signature: MessageSignature\n): string {\n  // new hash combines the previous hash and all the new data this signature will add.  This\n  // includes:\n  // * the public key compression flag\n  // * the signature\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n\n  const pubKeyEncoding = isCompressed(pubKey)\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n\n  const sigHashBytes = hexToBytes(sigHash);\n  if (sigHashBytes.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBytes);\n}\n\nexport function nextSignature(\n  curSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  privateKey: StacksPrivateKey\n): {\n  nextSig: MessageSignature;\n  nextSigHash: string;\n} {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    nextSig: signature,\n    nextSigHash,\n  };\n}\n\nexport function nextVerification(\n  initialSigHash: string,\n  authType: AuthType,\n  fee: IntegerType,\n  nonce: IntegerType,\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n\n  const publicKey = createStacksPublicKey(\n    publicKeyFromSignatureVrs(sigHashPreSign, signature, pubKeyEncoding)\n  );\n\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n\n  return {\n    pubKey: publicKey,\n    nextSigHash,\n  };\n}\n\nfunction newInitialSigHash(): SpendingCondition {\n  const spendingCondition = createSingleSigSpendingCondition(\n    AddressHashMode.SerializeP2PKH,\n    '',\n    0,\n    0\n  );\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(\n  condition: SpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return verifyMultiSig(condition, initialSigHash, authType);\n  }\n}\n\nfunction verifySingleSig(\n  condition: SingleSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const { pubKey, nextSigHash } = nextVerification(\n    initialSigHash,\n    authType,\n    condition.fee,\n    condition.nonce,\n    condition.keyEncoding,\n    condition.signature\n  );\n\n  // address version arg doesn't matter for signer hash generation\n  const addrBytes = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    condition.hashMode,\n    1,\n    [pubKey]\n  ).hash160;\n\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return nextSigHash;\n}\n\nfunction verifyMultiSig(\n  condition: MultiSigSpendingConditionOpts,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const publicKeys: StacksPublicKey[] = [];\n  let curSigHash = initialSigHash;\n  let haveUncompressed = false;\n  let numSigs = 0;\n\n  for (const field of condition.fields) {\n    let foundPubKey: StacksPublicKey;\n\n    switch (field.contents.type) {\n      case StacksMessageType.PublicKey:\n        if (!isCompressed(field.contents)) haveUncompressed = true;\n        foundPubKey = field.contents;\n        break;\n      case StacksMessageType.MessageSignature:\n        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed) haveUncompressed = true;\n        const { pubKey, nextSigHash } = nextVerification(\n          curSigHash,\n          authType,\n          condition.fee,\n          condition.nonce,\n          field.pubKeyEncoding,\n          field.contents\n        );\n        curSigHash = nextSigHash;\n        foundPubKey = pubKey;\n\n        numSigs += 1;\n        if (numSigs === 65536) throw new VerificationError('Too many signatures');\n\n        break;\n    }\n    publicKeys.push(foundPubKey);\n  }\n\n  if (numSigs !== condition.signaturesRequired)\n    throw new VerificationError('Incorrect number of signatures');\n\n  if (haveUncompressed && condition.hashMode === AddressHashMode.SerializeP2SH)\n    throw new VerificationError('Uncompressed keys are not allowed in this hash mode');\n\n  const addrBytes = addressFromPublicKeys(\n    0 as any, // only used for hash, so version doesn't matter\n    condition.hashMode,\n    condition.signaturesRequired,\n    publicKeys\n  ).hash160;\n  if (addrBytes !== condition.signer)\n    throw new VerificationError(\n      `Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`\n    );\n\n  return curSigHash;\n}\n\nexport type Authorization = StandardAuthorization | SponsoredAuthorization;\n\nexport interface StandardAuthorization {\n  authType: AuthType.Standard;\n  spendingCondition: SpendingCondition;\n}\n\nexport interface SponsoredAuthorization {\n  authType: AuthType.Sponsored;\n  spendingCondition: SpendingCondition;\n  sponsorSpendingCondition: SpendingCondition;\n}\n\nexport function createStandardAuth(spendingCondition: SpendingCondition): StandardAuthorization {\n  return {\n    authType: AuthType.Standard,\n    spendingCondition,\n  };\n}\n\nexport function createSponsoredAuth(\n  spendingCondition: SpendingCondition,\n  sponsorSpendingCondition?: SpendingCondition\n): Authorization {\n  return {\n    authType: AuthType.Sponsored,\n    spendingCondition,\n    sponsorSpendingCondition: sponsorSpendingCondition\n      ? sponsorSpendingCondition\n      : createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0),\n  };\n}\n\nexport function intoInitialSighashAuth(auth: Authorization): Authorization {\n  if (auth.spendingCondition) {\n    switch (auth.authType) {\n      case AuthType.Standard:\n        return createStandardAuth(clearCondition(auth.spendingCondition));\n      case AuthType.Sponsored:\n        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());\n      default:\n        throw new SigningError('Unexpected authorization type for signing');\n    }\n  }\n\n  throw new Error('Authorization missing SpendingCondition');\n}\n\nexport function verifyOrigin(auth: Authorization, initialSigHash: string): string {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    case AuthType.Sponsored:\n      return verify(auth.spendingCondition, initialSigHash, AuthType.Standard);\n    default:\n      throw new SigningError('Invalid origin auth type');\n  }\n}\n\nexport function setFee(auth: Authorization, amount: IntegerType): Authorization {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      const spendingCondition = {\n        ...auth.spendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, spendingCondition };\n    case AuthType.Sponsored:\n      const sponsorSpendingCondition = {\n        ...auth.sponsorSpendingCondition,\n        fee: intToBigInt(amount, false),\n      };\n      return { ...auth, sponsorSpendingCondition };\n  }\n}\n\nexport function getFee(auth: Authorization): bigint {\n  switch (auth.authType) {\n    case AuthType.Standard:\n      return auth.spendingCondition.fee;\n    case AuthType.Sponsored:\n      return auth.sponsorSpendingCondition.fee;\n  }\n}\n\nexport function setNonce(auth: Authorization, nonce: IntegerType): Authorization {\n  const spendingCondition = {\n    ...auth.spendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    spendingCondition,\n  };\n}\n\nexport function setSponsorNonce(auth: SponsoredAuthorization, nonce: IntegerType): Authorization {\n  const sponsorSpendingCondition = {\n    ...auth.sponsorSpendingCondition,\n    nonce: intToBigInt(nonce, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition,\n  };\n}\n\nexport function setSponsor(\n  auth: SponsoredAuthorization,\n  sponsorSpendingCondition: SpendingConditionOpts\n): Authorization {\n  const sc = {\n    ...sponsorSpendingCondition,\n    nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n    fee: intToBigInt(sponsorSpendingCondition.fee, false),\n  };\n\n  return {\n    ...auth,\n    sponsorSpendingCondition: sc,\n  };\n}\n\nexport function serializeAuthorization(auth: Authorization): Uint8Array {\n  const bytesArray = [];\n  bytesArray.push(auth.authType);\n\n  switch (auth.authType) {\n    case AuthType.Standard:\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\n      break;\n    case AuthType.Sponsored:\n      bytesArray.push(serializeSpendingCondition(auth.spendingCondition));\n      bytesArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));\n      break;\n  }\n\n  return concatArray(bytesArray);\n}\n\nexport function deserializeAuthorization(bytesReader: BytesReader) {\n  const authType = bytesReader.readUInt8Enum(AuthType, n => {\n    throw new DeserializationError(`Could not parse ${n} as AuthType`);\n  });\n\n  let spendingCondition;\n  switch (authType) {\n    case AuthType.Standard:\n      spendingCondition = deserializeSpendingCondition(bytesReader);\n      return createStandardAuth(spendingCondition);\n    case AuthType.Sponsored:\n      spendingCondition = deserializeSpendingCondition(bytesReader);\n      const sponsorSpendingCondition = deserializeSpendingCondition(bytesReader);\n      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}