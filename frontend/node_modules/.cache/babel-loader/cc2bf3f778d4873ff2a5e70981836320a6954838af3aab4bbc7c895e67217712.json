{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nvar utils_1 = require(\"@noble/hashes/utils\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nvar hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\nfunction c32encode(inputHex, minLength) {\n  // must be hex\n  if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n    throw new Error('Not a hex-encoded string');\n  }\n  if (inputHex.length % 2 !== 0) {\n    inputHex = \"0\".concat(inputHex);\n  }\n  inputHex = inputHex.toLowerCase();\n  var res = [];\n  var carry = 0;\n  for (var i = inputHex.length - 1; i >= 0; i--) {\n    if (carry < 4) {\n      var currentCode = hex.indexOf(inputHex[i]) >> carry;\n      var nextCode = 0;\n      if (i !== 0) {\n        nextCode = hex.indexOf(inputHex[i - 1]);\n      }\n      // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n      var nextBits = 1 + carry;\n      var nextLowBits = nextCode % (1 << nextBits) << 5 - nextBits;\n      var curC32Digit = exports.c32[currentCode + nextLowBits];\n      carry = nextBits;\n      res.unshift(curC32Digit);\n    } else {\n      carry = 0;\n    }\n  }\n  var C32leadingZeros = 0;\n  for (var _i = 0; _i < res.length; _i++) {\n    if (res[_i] !== '0') {\n      break;\n    } else {\n      C32leadingZeros++;\n    }\n  }\n  res = res.slice(C32leadingZeros);\n  var zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\\u0000*/);\n  var numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n  for (var _i2 = 0; _i2 < numLeadingZeroBytesInHex; _i2++) {\n    res.unshift(exports.c32[0]);\n  }\n  if (minLength) {\n    var count = minLength - res.length;\n    for (var _i3 = 0; _i3 < count; _i3++) {\n      res.unshift(exports.c32[0]);\n    }\n  }\n  return res.join('');\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\nfunction c32normalize(c32input) {\n  // must be upper-case\n  // replace all O's with 0's\n  // replace all I's and L's with 1's\n  return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\nfunction c32decode(c32input, minLength) {\n  c32input = c32normalize(c32input);\n  // must result in a c32 string\n  if (!c32input.match(\"^[\".concat(exports.c32, \"]*$\"))) {\n    throw new Error('Not a c32-encoded string');\n  }\n  var zeroPrefix = c32input.match(\"^\".concat(exports.c32[0], \"*\"));\n  var numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n  var res = [];\n  var carry = 0;\n  var carryBits = 0;\n  for (var i = c32input.length - 1; i >= 0; i--) {\n    if (carryBits === 4) {\n      res.unshift(hex[carry]);\n      carryBits = 0;\n      carry = 0;\n    }\n    var currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n    var currentValue = currentCode + carry;\n    var currentHexDigit = hex[currentValue % 16];\n    carryBits += 1;\n    carry = currentValue >> 4;\n    if (carry > 1 << carryBits) {\n      throw new Error('Panic error in decoding.');\n    }\n    res.unshift(currentHexDigit);\n  }\n  // one last carry\n  res.unshift(hex[carry]);\n  if (res.length % 2 === 1) {\n    res.unshift('0');\n  }\n  var hexLeadingZeros = 0;\n  for (var _i4 = 0; _i4 < res.length; _i4++) {\n    if (res[_i4] !== '0') {\n      break;\n    } else {\n      hexLeadingZeros++;\n    }\n  }\n  res = res.slice(hexLeadingZeros - hexLeadingZeros % 2);\n  var hexStr = res.join('');\n  for (var _i5 = 0; _i5 < numLeadingZeroBytes; _i5++) {\n    hexStr = \"00\".concat(hexStr);\n  }\n  if (minLength) {\n    var count = minLength * 2 - hexStr.length;\n    for (var _i6 = 0; _i6 < count; _i6 += 2) {\n      hexStr = \"00\".concat(hexStr);\n    }\n  }\n  return hexStr;\n}\nexports.c32decode = c32decode;","map":{"version":3,"names":["Object","defineProperty","exports","value","c32decode","c32normalize","c32encode","c32","utils_1","require","hex","inputHex","minLength","match","Error","length","concat","toLowerCase","res","carry","i","currentCode","indexOf","nextCode","nextBits","nextLowBits","curC32Digit","unshift","C32leadingZeros","slice","zeroPrefix","TextDecoder","decode","hexToBytes","numLeadingZeroBytesInHex","count","join","c32input","toUpperCase","replace","numLeadingZeroBytes","carryBits","currentValue","currentHexDigit","hexLeadingZeros","hexStr"],"sources":["C:/Users/rajde/gitrep/deploy/frontend/node_modules/c32check/lib/encoding.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nconst utils_1 = require(\"@noble/hashes/utils\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nconst hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\nfunction c32encode(inputHex, minLength) {\n    // must be hex\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Not a hex-encoded string');\n    }\n    if (inputHex.length % 2 !== 0) {\n        inputHex = `0${inputHex}`;\n    }\n    inputHex = inputHex.toLowerCase();\n    let res = [];\n    let carry = 0;\n    for (let i = inputHex.length - 1; i >= 0; i--) {\n        if (carry < 4) {\n            const currentCode = hex.indexOf(inputHex[i]) >> carry;\n            let nextCode = 0;\n            if (i !== 0) {\n                nextCode = hex.indexOf(inputHex[i - 1]);\n            }\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n            const nextBits = 1 + carry;\n            const nextLowBits = nextCode % (1 << nextBits) << (5 - nextBits);\n            const curC32Digit = exports.c32[currentCode + nextLowBits];\n            carry = nextBits;\n            res.unshift(curC32Digit);\n        }\n        else {\n            carry = 0;\n        }\n    }\n    let C32leadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            C32leadingZeros++;\n        }\n    }\n    res = res.slice(C32leadingZeros);\n    const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\\u0000*/);\n    const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n    for (let i = 0; i < numLeadingZeroBytesInHex; i++) {\n        res.unshift(exports.c32[0]);\n    }\n    if (minLength) {\n        const count = minLength - res.length;\n        for (let i = 0; i < count; i++) {\n            res.unshift(exports.c32[0]);\n        }\n    }\n    return res.join('');\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\nfunction c32normalize(c32input) {\n    // must be upper-case\n    // replace all O's with 0's\n    // replace all I's and L's with 1's\n    return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\nfunction c32decode(c32input, minLength) {\n    c32input = c32normalize(c32input);\n    // must result in a c32 string\n    if (!c32input.match(`^[${exports.c32}]*$`)) {\n        throw new Error('Not a c32-encoded string');\n    }\n    const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);\n    const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n    let res = [];\n    let carry = 0;\n    let carryBits = 0;\n    for (let i = c32input.length - 1; i >= 0; i--) {\n        if (carryBits === 4) {\n            res.unshift(hex[carry]);\n            carryBits = 0;\n            carry = 0;\n        }\n        const currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n        const currentValue = currentCode + carry;\n        const currentHexDigit = hex[currentValue % 16];\n        carryBits += 1;\n        carry = currentValue >> 4;\n        if (carry > 1 << carryBits) {\n            throw new Error('Panic error in decoding.');\n        }\n        res.unshift(currentHexDigit);\n    }\n    // one last carry\n    res.unshift(hex[carry]);\n    if (res.length % 2 === 1) {\n        res.unshift('0');\n    }\n    let hexLeadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            hexLeadingZeros++;\n        }\n    }\n    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));\n    let hexStr = res.join('');\n    for (let i = 0; i < numLeadingZeroBytes; i++) {\n        hexStr = `00${hexStr}`;\n    }\n    if (minLength) {\n        const count = minLength * 2 - hexStr.length;\n        for (let i = 0; i < count; i += 2) {\n            hexStr = `00${hexStr}`;\n        }\n    }\n    return hexStr;\n}\nexports.c32decode = c32decode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}