{"ast":null,"code":"import _defineProperty from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { AppConfig, UserSession } from '@stacks/auth';\nexport * from '@stacks/auth';\nimport { decodeToken, SECP256K1Client, createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { StacksTestnet } from '@stacks/network';\nimport { ChainID, serializeCV, serializePostCondition, deserializeTransaction } from '@stacks/transactions';\nimport { defineCustomElements } from '@stacks/connect-ui/loader';\nvar X = Object.defineProperty,\n  _ = Object.defineProperties;\nvar M = Object.getOwnPropertyDescriptors;\nvar P = Object.getOwnPropertySymbols;\nvar D = Object.prototype.hasOwnProperty,\n  B = Object.prototype.propertyIsEnumerable;\nvar b = function b(e, t, n) {\n    return t in e ? X(e, t, {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: n\n    }) : e[t] = n;\n  },\n  a = function a(e, t) {\n    for (var n in t || (t = {})) D.call(t, n) && b(e, n, t[n]);\n    if (P) {\n      var _iterator = _createForOfIteratorHelper(P(t)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var n = _step.value;\n          B.call(t, n) && b(e, n, t[n]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return e;\n  },\n  c = function c(e, t) {\n    return _(e, M(t));\n  };\nvar f = function f(e, t) {\n  var n = {};\n  for (var r in e) D.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);\n  if (e != null && P) {\n    var _iterator2 = _createForOfIteratorHelper(P(e)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var r = _step2.value;\n        t.indexOf(r) < 0 && B.call(e, r) && (n[r] = e[r]);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return n;\n};\nfunction d() {\n  return window.StacksProvider || window.BlockstackProvider;\n}\nfunction zt() {\n  return !!d();\n}\nvar Qt = \"https://app.blockstack.org\",\n  R = \"7.4.1\";\ntypeof window != \"undefined\" && (window.__CONNECT_VERSION__ = R);\nvar J = function J() {\n    var e = navigator.userAgent;\n    return /android/i.test(e) || /iPad|iPhone|iPod/.test(e) ? !0 : /windows phone/i.test(e);\n  },\n  Zt = function Zt() {\n    return !J();\n  },\n  A = function A(e) {\n    if (!e) {\n      var t = new AppConfig([\"store_write\"], document.location.href);\n      e = new UserSession({\n        appConfig: t\n      });\n    }\n    return e;\n  },\n  U = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(e) {\n      var t,\n        _e$redirectTo,\n        n,\n        r,\n        s,\n        o,\n        _e$sendToSignIn,\n        i,\n        p,\n        u,\n        l,\n        S,\n        F,\n        T,\n        k,\n        $,\n        _args = arguments;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            t = _args.length > 1 && _args[1] !== undefined ? _args[1] : d();\n            if (t) {\n              _context.next = 3;\n              break;\n            }\n            throw new Error(\"[Connect] No installed Stacks wallet found\");\n          case 3:\n            _e$redirectTo = e.redirectTo, n = _e$redirectTo === void 0 ? \"/\" : _e$redirectTo, r = e.manifestPath, s = e.onFinish, o = e.onCancel, _e$sendToSignIn = e.sendToSignIn, i = _e$sendToSignIn === void 0 ? !1 : _e$sendToSignIn, p = e.userSession, u = e.appDetails, l = A(p);\n            l.isUserSignedIn() && l.signUserOut();\n            S = l.generateAndStoreTransitKey(), F = l.makeAuthRequest(S, \"\".concat(document.location.origin).concat(n), \"\".concat(document.location.origin).concat(r), l.appConfig.scopes, void 0, void 0, {\n              sendToSignIn: i,\n              appDetails: u,\n              connectVersion: R\n            });\n            _context.prev = 6;\n            _context.next = 9;\n            return t.authenticationRequest(F);\n          case 9:\n            T = _context.sent;\n            _context.next = 12;\n            return l.handlePendingSignIn(T);\n          case 12:\n            k = decodeToken(T), $ = k == null ? void 0 : k.payload;\n            s == null || s({\n              authResponse: T,\n              authResponsePayload: $,\n              userSession: l\n            });\n            _context.next = 19;\n            break;\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](6);\n            console.error(\"[Connect] Error during auth request\", _context.t0), o == null || o();\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[6, 16]]);\n    }));\n    return function U(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(),\n  te = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(e) {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", (e = A(e), e.isUserSignedIn() ? e.loadUserData() : e.isSignInPending() ? e.handlePendingSignIn() : null));\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function te(_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\nvar z = Array.from({\n  length: 256\n}, function (e, t) {\n  return t.toString(16).padStart(2, \"0\");\n});\nfunction m(e) {\n  if (!(e instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n  var t = \"\";\n  var _iterator3 = _createForOfIteratorHelper(e),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var n = _step3.value;\n      t += z[n];\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return t;\n}\nfunction I(e) {\n  if (typeof e != \"string\") throw new TypeError(\"hexToBytes: expected string, got \".concat(typeof e));\n  var t = e.length % 2 ? \"0\".concat(e) : e,\n    n = new Uint8Array(t.length / 2);\n  for (var r = 0; r < n.length; r++) {\n    var s = r * 2,\n      o = t.slice(s, s + 2),\n      i = Number.parseInt(o, 16);\n    if (Number.isNaN(i) || i < 0) throw new Error(\"Invalid byte sequence\");\n    n[r] = i;\n  }\n  return n;\n}\nvar Y = function (r) {\n    return r.ContractCall = \"contract_call\", r.ContractDeploy = \"smart_contract\", r.STXTransfer = \"token_transfer\", r;\n  }(Y || {}),\n  H = function (o) {\n    return o.BUFFER = \"buffer\", o.UINT = \"uint\", o.INT = \"int\", o.PRINCIPAL = \"principal\", o.BOOL = \"bool\", o;\n  }(H || {});\nvar x = function x(e) {\n  var t = e;\n  if (!t) {\n    var n = new AppConfig([\"store_write\"], document.location.href);\n    t = new UserSession({\n      appConfig: n\n    });\n  }\n  return t;\n};\nfunction g(e) {\n  try {\n    return x(e).loadUserData().appPrivateKey;\n  } catch (t) {\n    return !1;\n  }\n}\nvar y = function y(e) {\n  var n = x(e).loadUserData().appPrivateKey,\n    r = SECP256K1Client.derivePublicKey(n);\n  return {\n    privateKey: n,\n    publicKey: r\n  };\n};\nfunction st(e) {\n  var _o;\n  var p;\n  var t = e.stxAddress,\n    n = e.userSession,\n    r = e.network;\n  if (t) return t;\n  if (!n || !r) return;\n  var s = (p = n == null ? void 0 : n.loadUserData().profile) == null ? void 0 : p.stxAddress,\n    o = (_o = {}, _defineProperty(_o, ChainID.Mainnet, \"mainnet\"), _defineProperty(_o, ChainID.Testnet, \"testnet\"), _o);\n  return s == null ? void 0 : s[o[r.chainId]];\n}\nfunction at(e) {\n  var t = e.network || new StacksTestnet(),\n    n = x(e.userSession),\n    r = c(a({}, e), {\n      network: t,\n      userSession: n\n    });\n  return a({\n    stxAddress: st(r)\n  }, r);\n}\nfunction E(e) {\n  return e.map(function (t) {\n    return m(serializePostCondition(t));\n  });\n}\nfunction h(_x3, _x4) {\n  return _h.apply(this, arguments);\n}\nfunction _h() {\n  _h = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(e, t) {\n    var n;\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) switch (_context11.prev = _context11.next) {\n        case 0:\n          n = e.postConditions;\n          return _context11.abrupt(\"return\", (n && typeof n[0] != \"string\" && (n = E(n)), new TokenSigner(\"ES256k\", t).signAsync(c(a({}, e), {\n            postConditions: n\n          }))));\n        case 2:\n        case \"end\":\n          return _context11.stop();\n      }\n    }, _callee11);\n  }));\n  return _h.apply(this, arguments);\n}\nfunction w(e) {\n  var t = e.postConditions;\n  return t && typeof t[0] != \"string\" && (t = E(t)), createUnsecuredToken(c(a({}, e), {\n    postConditions: t\n  }));\n}\nvar it = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref3, n) {\n      var e, t, r, s, o, i, p, u, l;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            e = _ref3.token, t = _ref3.options;\n            _context3.prev = 1;\n            _context3.next = 4;\n            return n.transactionRequest(e);\n          case 4:\n            i = _context3.sent;\n            p = i.txRaw;\n            u = I(p.replace(/^0x/, \"\"));\n            l = deserializeTransaction(u);\n            if (!(\"sponsored\" in t && t.sponsored)) {\n              _context3.next = 11;\n              break;\n            }\n            (r = t.onFinish) == null || r.call(t, c(a({}, i), {\n              stacksTransaction: l\n            }));\n            return _context3.abrupt(\"return\");\n          case 11:\n            (s = t.onFinish) == null || s.call(t, c(a({}, i), {\n              stacksTransaction: l\n            }));\n            _context3.next = 17;\n            break;\n          case 14:\n            _context3.prev = 14;\n            _context3.t0 = _context3[\"catch\"](1);\n            console.error(\"[Connect] Error during transaction request\", _context3.t0), (o = t.onCancel) == null || o.call(t);\n          case 17:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3, null, [[1, 14]]);\n    }));\n    return function it(_x5, _x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }(),\n  ct = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(e) {\n      var p, t, n, r, s, o, _y, u, l, S, i;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            p = e, t = p.functionArgs, n = p.appDetails, r = p.userSession, s = f(p, [\"functionArgs\", \"appDetails\", \"userSession\"]), o = t.map(function (u) {\n              return typeof u == \"string\" ? u : m(serializeCV(u));\n            });\n            if (!g(r)) {\n              _context4.next = 4;\n              break;\n            }\n            _y = y(r), u = _y.privateKey, l = _y.publicKey, S = c(a({}, s), {\n              functionArgs: o,\n              txType: \"contract_call\",\n              publicKey: l\n            });\n            return _context4.abrupt(\"return\", (n && (S.appDetails = n), h(S, u)));\n          case 4:\n            i = c(a({}, s), {\n              functionArgs: o,\n              txType: \"contract_call\"\n            });\n            return _context4.abrupt(\"return\", (n && (i.appDetails = n), w(i)));\n          case 6:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    return function ct(_x7) {\n      return _ref5.apply(this, arguments);\n    };\n  }(),\n  pt = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(e) {\n      var o, t, n, r, _y2, i, p, u, s;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            o = e, t = o.appDetails, n = o.userSession, r = f(o, [\"appDetails\", \"userSession\"]);\n            if (!g(n)) {\n              _context5.next = 4;\n              break;\n            }\n            _y2 = y(n), i = _y2.privateKey, p = _y2.publicKey, u = c(a({}, r), {\n              publicKey: p,\n              txType: \"smart_contract\"\n            });\n            return _context5.abrupt(\"return\", (t && (u.appDetails = t), h(u, i)));\n          case 4:\n            s = c(a({}, r), {\n              txType: \"smart_contract\"\n            });\n            return _context5.abrupt(\"return\", (t && (s.appDetails = t), w(s)));\n          case 6:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    return function pt(_x8) {\n      return _ref6.apply(this, arguments);\n    };\n  }(),\n  ut = /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(e) {\n      var i, t, n, r, s, _y3, p, u, l, o;\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            i = e, t = i.amount, n = i.appDetails, r = i.userSession, s = f(i, [\"amount\", \"appDetails\", \"userSession\"]);\n            if (!g(r)) {\n              _context6.next = 4;\n              break;\n            }\n            _y3 = y(r), p = _y3.privateKey, u = _y3.publicKey, l = c(a({}, s), {\n              amount: t.toString(10),\n              publicKey: u,\n              txType: \"token_transfer\"\n            });\n            return _context6.abrupt(\"return\", (n && (l.appDetails = n), h(l, p)));\n          case 4:\n            o = c(a({}, s), {\n              amount: t.toString(10),\n              txType: \"token_transfer\"\n            });\n            return _context6.abrupt(\"return\", (n && (o.appDetails = n), w(o)));\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n    return function ut(_x9) {\n      return _ref7.apply(this, arguments);\n    };\n  }(),\n  lt = /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(e) {\n      var i, t, n, r, s, _y4, p, u, l, o;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            i = e, t = i.txHex, n = i.appDetails, r = i.userSession, s = f(i, [\"txHex\", \"appDetails\", \"userSession\"]);\n            if (!g(r)) {\n              _context7.next = 4;\n              break;\n            }\n            _y4 = y(r), p = _y4.privateKey, u = _y4.publicKey, l = c(a({}, s), {\n              txHex: t,\n              publicKey: u\n            });\n            return _context7.abrupt(\"return\", (n && (l.appDetails = n), h(l, p)));\n          case 4:\n            o = c(a({}, s), {\n              txHex: t\n            });\n            return _context7.abrupt(\"return\", (n && (o.appDetails = n), w(o)));\n          case 6:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n    return function lt(_x10) {\n      return _ref8.apply(this, arguments);\n    };\n  }();\nfunction C(_x11, _x12, _x13) {\n  return _C.apply(this, arguments);\n}\nfunction _C() {\n  _C = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(e, t, n) {\n    var r;\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) switch (_context12.prev = _context12.next) {\n        case 0:\n          _context12.next = 2;\n          return t(a(a({}, at(e)), e));\n        case 2:\n          r = _context12.sent;\n          return _context12.abrupt(\"return\", it({\n            token: r,\n            options: e\n          }, n));\n        case 4:\n        case \"end\":\n          return _context12.stop();\n      }\n    }, _callee12);\n  }));\n  return _C.apply(this, arguments);\n}\nfunction de(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : d();\n  if (!t) throw new Error(\"[Connect] No installed Stacks wallet found\");\n  return C(e, ct, t);\n}\nfunction fe(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : d();\n  if (!t) throw new Error(\"[Connect] No installed Stacks wallet found\");\n  return C(e, pt, t);\n}\nfunction ge(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : d();\n  if (!t) throw new Error(\"[Connect] No installed Stacks wallet found\");\n  return C(e, ut, t);\n}\nfunction ye(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : d();\n  if (!t) throw new Error(\"[Connect] No installed Stacks wallet found\");\n  return C(e, lt, t);\n}\nfunction yt(_x14, _x15) {\n  return _yt.apply(this, arguments);\n}\nfunction _yt() {\n  _yt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(e, t) {\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) switch (_context13.prev = _context13.next) {\n        case 0:\n          return _context13.abrupt(\"return\", new TokenSigner(\"ES256k\", t).signAsync(a({}, e)));\n        case 1:\n        case \"end\":\n          return _context13.stop();\n      }\n    }, _callee13);\n  }));\n  return _yt.apply(this, arguments);\n}\nfunction xt(e) {\n  var t = e.network || new StacksTestnet(),\n    n = x(e.userSession),\n    r = c(a({}, e), {\n      network: t,\n      userSession: n\n    });\n  return a({}, r);\n}\nfunction St(_x16, _x17) {\n  return _St.apply(this, arguments);\n}\nfunction _St() {\n  _St = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref9, n) {\n    var e, t, r, s, o;\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) switch (_context14.prev = _context14.next) {\n        case 0:\n          e = _ref9.token, t = _ref9.options;\n          if (n) {\n            _context14.next = 3;\n            break;\n          }\n          throw new Error(\"[Connect] No installed Stacks wallet found\");\n        case 3:\n          _context14.prev = 3;\n          _context14.next = 6;\n          return n.psbtRequest(e);\n        case 6:\n          o = _context14.sent;\n          (r = t.onFinish) == null || r.call(t, o);\n          _context14.next = 13;\n          break;\n        case 10:\n          _context14.prev = 10;\n          _context14.t0 = _context14[\"catch\"](3);\n          console.error(\"[Connect] Error during psbt request\", _context14.t0), (s = t.onCancel) == null || s.call(t);\n        case 13:\n        case \"end\":\n          return _context14.stop();\n      }\n    }, _callee14, null, [[3, 10]]);\n  }));\n  return _St.apply(this, arguments);\n}\nvar mt = /*#__PURE__*/function () {\n  var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(e) {\n    var p, t, n, r, s, o, _y5, u, l, S, i;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          p = e, t = p.allowedSighash, n = p.hex, r = p.signAtIndex, s = p.userSession, o = f(p, [\"allowedSighash\", \"hex\", \"signAtIndex\", \"userSession\"]);\n          if (!g(s)) {\n            _context8.next = 4;\n            break;\n          }\n          _y5 = y(s), u = _y5.privateKey, l = _y5.publicKey, S = c(a({}, o), {\n            allowedSighash: t,\n            hex: n,\n            signAtIndex: r,\n            publicKey: l\n          });\n          return _context8.abrupt(\"return\", yt(S, u));\n        case 4:\n          i = a({}, o);\n          return _context8.abrupt(\"return\", createUnsecuredToken(i));\n        case 6:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return function mt(_x18) {\n    return _ref10.apply(this, arguments);\n  };\n}();\nfunction Tt(_x19, _x20, _x21) {\n  return _Tt.apply(this, arguments);\n}\nfunction _Tt() {\n  _Tt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(e, t, n) {\n    var r;\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) switch (_context15.prev = _context15.next) {\n        case 0:\n          _context15.next = 2;\n          return t(a(a({}, xt(e)), e));\n        case 2:\n          r = _context15.sent;\n          return _context15.abrupt(\"return\", St({\n            token: r,\n            options: e\n          }, n));\n        case 4:\n        case \"end\":\n          return _context15.stop();\n      }\n    }, _callee15);\n  }));\n  return _Tt.apply(this, arguments);\n}\nfunction Ce(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : d();\n  return Tt(e, mt, t);\n}\nfunction Ct(e) {\n  var _s;\n  var i;\n  var t = e.userSession,\n    n = e.network;\n  if (!t || !n) return;\n  var r = (i = t == null ? void 0 : t.loadUserData().profile) == null ? void 0 : i.stxAddress,\n    s = (_s = {}, _defineProperty(_s, ChainID.Mainnet, \"mainnet\"), _defineProperty(_s, ChainID.Testnet, \"testnet\"), _s);\n  return r == null ? void 0 : r[s[n.chainId]];\n}\nfunction kt(_x22, _x23) {\n  return _kt.apply(this, arguments);\n}\nfunction _kt() {\n  _kt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(e, t) {\n    return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n      while (1) switch (_context16.prev = _context16.next) {\n        case 0:\n          return _context16.abrupt(\"return\", new TokenSigner(\"ES256k\", t).signAsync(a({}, e)));\n        case 1:\n        case \"end\":\n          return _context16.stop();\n      }\n    }, _callee16);\n  }));\n  return _kt.apply(this, arguments);\n}\nfunction O(e) {\n  var t = e.network || new StacksTestnet(),\n    n = x(e.userSession),\n    r = c(a({}, e), {\n      network: t,\n      userSession: n\n    });\n  return a({\n    stxAddress: Ct(r)\n  }, r);\n}\nfunction Ot(_x24, _x25) {\n  return _Ot.apply(this, arguments);\n}\nfunction _Ot() {\n  _Ot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(_ref11, n) {\n    var e, t, r, s, o;\n    return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n      while (1) switch (_context17.prev = _context17.next) {\n        case 0:\n          e = _ref11.token, t = _ref11.options;\n          _context17.prev = 1;\n          _context17.next = 4;\n          return n.signatureRequest(e);\n        case 4:\n          o = _context17.sent;\n          (r = t.onFinish) == null || r.call(t, o);\n          _context17.next = 11;\n          break;\n        case 8:\n          _context17.prev = 8;\n          _context17.t0 = _context17[\"catch\"](1);\n          console.error(\"[Connect] Error during signature request\", _context17.t0), (s = t.onCancel) == null || s.call(t);\n        case 11:\n        case \"end\":\n          return _context17.stop();\n      }\n    }, _callee17, null, [[1, 8]]);\n  }));\n  return _Ot.apply(this, arguments);\n}\nvar bt = /*#__PURE__*/function () {\n  var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(e) {\n    var s, t, n, _y6, o, i, p, r;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          s = e, t = s.userSession, n = f(s, [\"userSession\"]);\n          if (!g(t)) {\n            _context9.next = 4;\n            break;\n          }\n          _y6 = y(t), o = _y6.privateKey, i = _y6.publicKey, p = c(a({}, n), {\n            publicKey: i\n          });\n          return _context9.abrupt(\"return\", kt(p, o));\n        case 4:\n          r = a({}, n);\n          return _context9.abrupt(\"return\", createUnsecuredToken(r));\n        case 6:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee9);\n  }));\n  return function bt(_x26) {\n    return _ref12.apply(this, arguments);\n  };\n}();\nfunction Dt(_x27, _x28, _x29) {\n  return _Dt.apply(this, arguments);\n}\nfunction _Dt() {\n  _Dt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(e, t, n) {\n    var r;\n    return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n      while (1) switch (_context18.prev = _context18.next) {\n        case 0:\n          _context18.next = 2;\n          return t(a(a({}, O(e)), e));\n        case 2:\n          r = _context18.sent;\n          return _context18.abrupt(\"return\", Ot({\n            token: r,\n            options: e\n          }, n));\n        case 4:\n        case \"end\":\n          return _context18.stop();\n      }\n    }, _callee18);\n  }));\n  return _Dt.apply(this, arguments);\n}\nfunction Ue(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : d();\n  if (!t) throw new Error(\"[Connect] No installed Stacks wallet found\");\n  return Dt(e, bt, t);\n}\nfunction At(_x30, _x31, _x32) {\n  return _At.apply(this, arguments);\n}\nfunction _At() {\n  _At = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(e, t, n) {\n    var r;\n    return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n      while (1) switch (_context19.prev = _context19.next) {\n        case 0:\n          _context19.next = 2;\n          return t(a(a({}, O(e)), e));\n        case 2:\n          r = _context19.sent;\n          return _context19.abrupt(\"return\", vt({\n            token: r,\n            options: e\n          }, n));\n        case 4:\n        case \"end\":\n          return _context19.stop();\n      }\n    }, _callee19);\n  }));\n  return _At.apply(this, arguments);\n}\nfunction N(e) {\n  return c(a({}, e), {\n    message: m(serializeCV(e.message)),\n    domain: m(serializeCV(e.domain))\n  });\n}\nfunction Ut(_x33, _x34) {\n  return _Ut.apply(this, arguments);\n}\nfunction _Ut() {\n  _Ut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(e, t) {\n    return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n      while (1) switch (_context20.prev = _context20.next) {\n        case 0:\n          return _context20.abrupt(\"return\", new TokenSigner(\"ES256k\", t).signAsync(N(e)));\n        case 1:\n        case \"end\":\n          return _context20.stop();\n      }\n    }, _callee20);\n  }));\n  return _Ut.apply(this, arguments);\n}\nfunction It(_x35) {\n  return _It.apply(this, arguments);\n}\nfunction _It() {\n  _It = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(e) {\n    var r, t, n, _y8, s, o, i;\n    return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n      while (1) switch (_context21.prev = _context21.next) {\n        case 0:\n          r = e, t = r.userSession, n = f(r, [\"userSession\"]);\n          if (!g(t)) {\n            _context21.next = 4;\n            break;\n          }\n          _y8 = y(t), s = _y8.privateKey, o = _y8.publicKey, i = c(a({}, n), {\n            publicKey: o\n          });\n          return _context21.abrupt(\"return\", Ut(i, s));\n        case 4:\n          return _context21.abrupt(\"return\", createUnsecuredToken(N(e)));\n        case 5:\n        case \"end\":\n          return _context21.stop();\n      }\n    }, _callee21);\n  }));\n  return _It.apply(this, arguments);\n}\nfunction vt(_x36, _x37) {\n  return _vt.apply(this, arguments);\n}\nfunction _vt() {\n  _vt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(_ref13, n) {\n    var e, t, r, s, o;\n    return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n      while (1) switch (_context22.prev = _context22.next) {\n        case 0:\n          e = _ref13.token, t = _ref13.options;\n          _context22.prev = 1;\n          _context22.next = 4;\n          return n.structuredDataSignatureRequest(e);\n        case 4:\n          o = _context22.sent;\n          (r = t.onFinish) == null || r.call(t, o);\n          _context22.next = 11;\n          break;\n        case 8:\n          _context22.prev = 8;\n          _context22.t0 = _context22[\"catch\"](1);\n          console.error(\"[Connect] Error during signature request\", _context22.t0), (s = t.onCancel) == null || s.call(t);\n        case 11:\n        case \"end\":\n          return _context22.stop();\n      }\n    }, _callee22, null, [[1, 8]]);\n  }));\n  return _vt.apply(this, arguments);\n}\nfunction Xe(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : d();\n  if (!t) throw new Error(\"[Connect] No installed Stacks wallet found\");\n  return At(e, It, t);\n}\nfunction Nt(_x38, _x39) {\n  return _Nt.apply(this, arguments);\n}\nfunction _Nt() {\n  _Nt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(e, t) {\n    return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n      while (1) switch (_context23.prev = _context23.next) {\n        case 0:\n          return _context23.abrupt(\"return\", new TokenSigner(\"ES256k\", t).signAsync(a({}, e)));\n        case 1:\n        case \"end\":\n          return _context23.stop();\n      }\n    }, _callee23);\n  }));\n  return _Nt.apply(this, arguments);\n}\nfunction Ft(e) {\n  var t = e.network || new StacksTestnet(),\n    n = x(e.userSession),\n    r = c(a({}, e), {\n      network: t,\n      userSession: n\n    });\n  return a({}, r);\n}\nfunction $t(_x40, _x41) {\n  return _$t.apply(this, arguments);\n}\nfunction _$t() {\n  _$t = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(_ref14, n) {\n    var e, t, r, s, o;\n    return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n      while (1) switch (_context24.prev = _context24.next) {\n        case 0:\n          e = _ref14.token, t = _ref14.options;\n          _context24.prev = 1;\n          _context24.next = 4;\n          return n.profileUpdateRequest(e);\n        case 4:\n          o = _context24.sent;\n          (r = t.onFinish) == null || r.call(t, o);\n          _context24.next = 11;\n          break;\n        case 8:\n          _context24.prev = 8;\n          _context24.t0 = _context24[\"catch\"](1);\n          console.error(\"[Connect] Error during signature request\", _context24.t0), (s = t.onCancel) == null || s.call(t);\n        case 11:\n        case \"end\":\n          return _context24.stop();\n      }\n    }, _callee24, null, [[1, 8]]);\n  }));\n  return _$t.apply(this, arguments);\n}\nvar Xt = /*#__PURE__*/function () {\n  var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(e) {\n    var o, t, n, r, _y7, i, p, u, s;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) switch (_context10.prev = _context10.next) {\n        case 0:\n          o = e, t = o.userSession, n = o.profile, r = f(o, [\"userSession\", \"profile\"]);\n          if (!g(t)) {\n            _context10.next = 4;\n            break;\n          }\n          _y7 = y(t), i = _y7.privateKey, p = _y7.publicKey, u = c(a({}, r), {\n            profile: n,\n            publicKey: p\n          });\n          return _context10.abrupt(\"return\", Nt(u, i));\n        case 4:\n          s = a({}, r);\n          return _context10.abrupt(\"return\", createUnsecuredToken(s));\n        case 6:\n        case \"end\":\n          return _context10.stop();\n      }\n    }, _callee10);\n  }));\n  return function Xt(_x42) {\n    return _ref15.apply(this, arguments);\n  };\n}();\nfunction _t(_x43, _x44, _x45) {\n  return _t2.apply(this, arguments);\n}\nfunction _t2() {\n  _t2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(e, t, n) {\n    var r;\n    return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n      while (1) switch (_context25.prev = _context25.next) {\n        case 0:\n          _context25.next = 2;\n          return t(a(a({}, Ft(e)), e));\n        case 2:\n          r = _context25.sent;\n          return _context25.abrupt(\"return\", $t({\n            token: r,\n            options: e\n          }, n));\n        case 4:\n        case \"end\":\n          return _context25.stop();\n      }\n    }, _callee25);\n  }));\n  return _t2.apply(this, arguments);\n}\nfunction Ye(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : d();\n  if (!t) throw new Error(\"[Connect] No installed Stacks wallet found\");\n  return _t(e, Xt, t);\n}\nvar Mt = function (o) {\n  return o[o.DEFAULT = 0] = \"DEFAULT\", o[o.ALL = 1] = \"ALL\", o[o.NONE = 2] = \"NONE\", o[o.SINGLE = 3] = \"SINGLE\", o[o.ANYONECANPAY = 128] = \"ANYONECANPAY\", o;\n}(Mt || {});\nvar Vt = function Vt(e) {\n    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : d();\n    if (t) {\n      U(e, t);\n      return;\n    }\n    if (typeof window !== void 0) {\n      defineCustomElements(window);\n      var n = document.createElement(\"connect-modal\");\n      n.authOptions = e, document.body.appendChild(n);\n      var r = function r(s) {\n        s.key === \"Escape\" && (document.removeEventListener(\"keydown\", r), n.remove());\n      };\n      document.addEventListener(\"keydown\", r);\n    }\n  },\n  en = function en(e) {\n    return Vt(e);\n  };\nexport { H as ContractCallArgumentType, Mt as SignatureHash, Y as TransactionTypes, U as authenticate, Qt as defaultAuthURL, Ft as getDefaultProfileUpdateRequestOptions, xt as getDefaultPsbtRequestOptions, O as getDefaultSignatureRequestOptions, y as getKeys, A as getOrCreateUserSession, d as getStacksProvider, st as getStxAddress, te as getUserData, x as getUserSession, g as hasAppPrivateKey, J as isMobile, zt as isStacksWalletInstalled, ct as makeContractCallToken, pt as makeContractDeployToken, Xt as makeProfileUpdateToken, mt as makePsbtToken, ut as makeSTXTransferToken, lt as makeSignTransaction, de as openContractCall, fe as openContractDeploy, Ye as openProfileUpdateRequestPopup, Ce as openPsbtRequestPopup, ge as openSTXTransfer, ye as openSignTransaction, Ue as openSignatureRequestPopup, Xe as openStructuredDataSignatureRequestPopup, Zt as shouldUsePopup, en as showBlockstackConnect, Vt as showConnect, bt as signMessage, It as signStructuredMessage };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":[],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\auth.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\utils.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\bitcoin\\psbt.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\transactions\\index.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\node_modules\\@stacks\\common\\src\\utils.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\types\\transactions.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\signature\\index.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\signature\\structuredData.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\profile\\index.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\types\\bitcoin.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\ui.ts","C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\connect\\src\\index.ts"],"sourcesContent":["import { AppConfig, UserSession } from '@stacks/auth';\nimport { decodeToken } from 'jsontokens';\nimport type { AuthOptions, AuthResponsePayload, StacksProvider } from './types';\n\nimport { getStacksProvider } from './utils';\n\nexport const defaultAuthURL = 'https://app.blockstack.org';\n\nconst version = __VERSION__; // replaced via tsup esbuildOptions\n\nif (typeof window !== 'undefined') {\n  window.__CONNECT_VERSION__ = version;\n}\n\nexport const isMobile = () => {\n  const ua = navigator.userAgent;\n  if (/android/i.test(ua)) {\n    return true;\n  }\n  if (/iPad|iPhone|iPod/.test(ua)) {\n    return true;\n  }\n  return /windows phone/i.test(ua);\n};\n\n/**\n * mobile should not use a 'popup' type of window.\n */\nexport const shouldUsePopup = () => {\n  return !isMobile();\n};\n\nexport const getOrCreateUserSession = (userSession?: UserSession): UserSession => {\n  if (!userSession) {\n    const appConfig = new AppConfig(['store_write'], document.location.href);\n    userSession = new UserSession({ appConfig });\n  }\n  return userSession;\n};\n\nexport const authenticate = async (\n  authOptions: AuthOptions,\n  provider: StacksProvider = getStacksProvider()\n) => {\n  if (!provider) throw new Error('[Connect] No installed Stacks wallet found');\n\n  const {\n    redirectTo = '/',\n    manifestPath,\n    onFinish,\n    onCancel,\n    sendToSignIn = false,\n    userSession: _userSession,\n    appDetails,\n  } = authOptions;\n  const userSession = getOrCreateUserSession(_userSession);\n  if (userSession.isUserSignedIn()) {\n    userSession.signUserOut();\n  }\n  const transitKey = userSession.generateAndStoreTransitKey();\n  const authRequest = userSession.makeAuthRequest(\n    transitKey,\n    `${document.location.origin}${redirectTo}`,\n    `${document.location.origin}${manifestPath}`,\n    userSession.appConfig.scopes,\n    undefined,\n    undefined,\n    {\n      sendToSignIn,\n      appDetails,\n      connectVersion: version,\n    }\n  );\n\n  try {\n    const authResponse = await provider.authenticationRequest(authRequest);\n    await userSession.handlePendingSignIn(authResponse);\n    const token = decodeToken(authResponse);\n    const payload = token?.payload;\n    const authResponsePayload = payload as unknown as AuthResponsePayload;\n    onFinish?.({\n      authResponse,\n      authResponsePayload,\n      userSession,\n    });\n  } catch (error) {\n    console.error('[Connect] Error during auth request', error);\n    onCancel?.();\n  }\n};\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const getUserData = async (userSession?: UserSession) => {\n  userSession = getOrCreateUserSession(userSession);\n  if (userSession.isUserSignedIn()) {\n    return userSession.loadUserData();\n  }\n  if (userSession.isSignInPending()) {\n    return userSession.handlePendingSignIn();\n  }\n  return null;\n};\n","export function getStacksProvider() {\n  return window.StacksProvider || window.BlockstackProvider;\n}\n\nexport function isStacksWalletInstalled() {\n  return !!getStacksProvider();\n}\n","import { StacksTestnet } from '@stacks/network';\nimport { createUnsecuredToken, Json, TokenSigner } from 'jsontokens';\n\nimport { getKeys, getUserSession, hasAppPrivateKey } from '../transactions';\nimport { PsbtPayload, PsbtPopup, PsbtRequestOptions } from '../types/bitcoin';\nimport { getStacksProvider } from '../utils';\nimport { StacksProvider } from '../types';\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: PsbtPayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({ ...payload } as any);\n}\n\nexport function getDefaultPsbtRequestOptions(options: PsbtRequestOptions) {\n  const network = options.network || new StacksTestnet();\n  const userSession = getUserSession(options.userSession);\n  const defaults: PsbtRequestOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n  return {\n    ...defaults,\n  };\n}\n\nasync function openPsbtPopup({ token, options }: PsbtPopup, provider: StacksProvider) {\n  if (!provider) throw new Error('[Connect] No installed Stacks wallet found');\n\n  try {\n    const psbtResponse = await provider.psbtRequest(token);\n    options.onFinish?.(psbtResponse);\n  } catch (error) {\n    console.error('[Connect] Error during psbt request', error);\n    options.onCancel?.();\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const makePsbtToken = async (options: PsbtRequestOptions) => {\n  const { allowedSighash, hex, signAtIndex, userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n\n    const payload: PsbtPayload = {\n      ..._options,\n      allowedSighash,\n      hex,\n      signAtIndex,\n      publicKey,\n    };\n\n    return signPayload(payload, privateKey);\n  }\n  const payload = { ..._options };\n  return createUnsecuredToken(payload as Json);\n};\n\nasync function generateTokenAndOpenPopup<T extends PsbtRequestOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>,\n  provider: StacksProvider\n) {\n  const token = await makeTokenFn({\n    ...getDefaultPsbtRequestOptions(options),\n    ...options,\n  } as T);\n  return openPsbtPopup({ token, options }, provider);\n}\n\n/**\n * @experimental\n */\nexport function openPsbtRequestPopup(\n  options: PsbtRequestOptions,\n  provider: StacksProvider = getStacksProvider()\n) {\n  return generateTokenAndOpenPopup(options, makePsbtToken, provider);\n}\n","import { AppConfig, UserSession } from '@stacks/auth';\nimport { bytesToHex, hexToBytes } from '@stacks/common';\nimport { StacksTestnet } from '@stacks/network';\nimport {\n  ChainID,\n  deserializeTransaction,\n  PostCondition,\n  serializeCV,\n  serializePostCondition,\n} from '@stacks/transactions';\nimport { createUnsecuredToken, Json, SECP256K1Client, TokenSigner } from 'jsontokens';\nimport {\n  ContractCallOptions,\n  ContractCallPayload,\n  ContractCallRegularOptions,\n  ContractCallSponsoredOptions,\n  ContractDeployOptions,\n  ContractDeployPayload,\n  ContractDeployRegularOptions,\n  ContractDeploySponsoredOptions,\n  FinishedTxPayload,\n  SignTransactionOptions,\n  SignTransactionPayload,\n  SponsoredFinishedTxPayload,\n  STXTransferOptions,\n  STXTransferPayload,\n  STXTransferRegularOptions,\n  STXTransferSponsoredOptions,\n  TransactionOptions,\n  TransactionPayload,\n  TransactionPopup,\n  TransactionTypes,\n} from '../types/transactions';\nimport { getStacksProvider } from '../utils';\nimport { StacksProvider } from '../types';\n\n// TODO extract out of transactions\nexport const getUserSession = (_userSession?: UserSession) => {\n  let userSession = _userSession;\n\n  if (!userSession) {\n    const appConfig = new AppConfig(['store_write'], document.location.href);\n    userSession = new UserSession({ appConfig });\n  }\n  return userSession;\n};\n\nexport function hasAppPrivateKey(userSession?: UserSession) {\n  try {\n    const session = getUserSession(userSession).loadUserData();\n    return session.appPrivateKey;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport const getKeys = (_userSession?: UserSession) => {\n  const userSession = getUserSession(_userSession);\n  const privateKey = userSession.loadUserData().appPrivateKey;\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n\n  return { privateKey, publicKey };\n};\n\n// TODO extract out of transactions\nexport function getStxAddress(options: TransactionOptions) {\n  const { stxAddress, userSession, network } = options;\n\n  if (stxAddress) return stxAddress;\n  if (!userSession || !network) return undefined;\n  const stxAddresses = userSession?.loadUserData().profile?.stxAddress;\n  const chainIdToKey = {\n    [ChainID.Mainnet]: 'mainnet',\n    [ChainID.Testnet]: 'testnet',\n  };\n  const address: string | undefined = stxAddresses?.[chainIdToKey[network.chainId]];\n  return address;\n}\n\nfunction getDefaults(options: TransactionOptions) {\n  const network = options.network || new StacksTestnet();\n\n  const userSession = getUserSession(options.userSession);\n  const defaults: TransactionOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n\n  return {\n    stxAddress: getStxAddress(defaults),\n    ...defaults,\n  };\n}\n\nfunction encodePostConditions(postConditions: PostCondition[]) {\n  return postConditions.map(pc => bytesToHex(serializePostCondition(pc)));\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: TransactionPayload, privateKey: string) {\n  let { postConditions } = payload;\n  if (postConditions && typeof postConditions[0] !== 'string') {\n    postConditions = encodePostConditions(postConditions as PostCondition[]);\n  }\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({ ...payload, postConditions } as any);\n}\n\nfunction createUnsignedTransactionPayload(payload: Partial<TransactionPayload>) {\n  let { postConditions } = payload;\n  if (postConditions && typeof postConditions[0] !== 'string') {\n    postConditions = encodePostConditions(postConditions as PostCondition[]);\n  }\n  return createUnsecuredToken({ ...payload, postConditions } as unknown as Json);\n}\n\nconst openTransactionPopup = async (\n  { token, options }: TransactionPopup,\n  provider: StacksProvider\n) => {\n  try {\n    const txResponse = await provider.transactionRequest(token);\n    const { txRaw } = txResponse;\n    const txBytes = hexToBytes(txRaw.replace(/^0x/, ''));\n    const stacksTransaction = deserializeTransaction(txBytes);\n\n    if ('sponsored' in options && options.sponsored) {\n      options.onFinish?.({\n        ...(txResponse as SponsoredFinishedTxPayload),\n        stacksTransaction,\n      });\n      return;\n    }\n    options.onFinish?.({\n      ...(txResponse as FinishedTxPayload),\n      stacksTransaction,\n    });\n  } catch (error) {\n    console.error('[Connect] Error during transaction request', error);\n    options.onCancel?.();\n  }\n};\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const makeContractCallToken = async (options: ContractCallOptions) => {\n  const { functionArgs, appDetails, userSession, ..._options } = options;\n\n  const args: string[] = functionArgs.map(arg => {\n    if (typeof arg === 'string') {\n      return arg;\n    }\n    return bytesToHex(serializeCV(arg));\n  });\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: ContractCallPayload = {\n      ..._options,\n      functionArgs: args,\n      txType: TransactionTypes.ContractCall,\n      publicKey,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n  const payload: Partial<ContractCallPayload> = {\n    ..._options,\n    functionArgs: args,\n    txType: TransactionTypes.ContractCall,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const makeContractDeployToken = async (options: ContractDeployOptions) => {\n  const { appDetails, userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: ContractDeployPayload = {\n      ..._options,\n      publicKey,\n      txType: TransactionTypes.ContractDeploy,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n\n  const payload: Partial<ContractDeployPayload> = {\n    ..._options,\n    txType: TransactionTypes.ContractDeploy,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const makeSTXTransferToken = async (options: STXTransferOptions) => {\n  const { amount, appDetails, userSession, ..._options } = options;\n\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: STXTransferPayload = {\n      ..._options,\n      amount: amount.toString(10),\n      publicKey,\n      txType: TransactionTypes.STXTransfer,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n\n  const payload: Partial<STXTransferPayload> = {\n    ..._options,\n    amount: amount.toString(10),\n    txType: TransactionTypes.STXTransfer,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\nexport const makeSignTransaction = async (options: SignTransactionOptions) => {\n  const { txHex, appDetails, userSession, ..._options } = options;\n\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: SignTransactionPayload = {\n      ..._options,\n      txHex,\n      publicKey,\n    };\n    if (appDetails) payload.appDetails = appDetails;\n    return signPayload(payload, privateKey);\n  }\n\n  const payload: Partial<SignTransactionOptions> = {\n    ..._options,\n    txHex,\n  };\n  if (appDetails) payload.appDetails = appDetails;\n  return createUnsignedTransactionPayload(payload);\n};\n\nasync function generateTokenAndOpenPopup<T extends TransactionOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>,\n  provider: StacksProvider\n) {\n  const token = await makeTokenFn({\n    ...getDefaults(options),\n    ...options,\n  } as T);\n  return openTransactionPopup({ token, options }, provider);\n}\n\nexport function openContractCall(\n  options: ContractCallOptions | ContractCallRegularOptions | ContractCallSponsoredOptions,\n  provider: StacksProvider = getStacksProvider()\n) {\n  if (!provider) throw new Error('[Connect] No installed Stacks wallet found');\n  return generateTokenAndOpenPopup(options, makeContractCallToken, provider);\n}\n\nexport function openContractDeploy(\n  options: ContractDeployOptions | ContractDeployRegularOptions | ContractDeploySponsoredOptions,\n  provider: StacksProvider = getStacksProvider()\n) {\n  if (!provider) throw new Error('[Connect] No installed Stacks wallet found');\n  return generateTokenAndOpenPopup(options, makeContractDeployToken, provider);\n}\n\nexport function openSTXTransfer(\n  options: STXTransferOptions | STXTransferRegularOptions | STXTransferSponsoredOptions,\n  provider: StacksProvider = getStacksProvider()\n) {\n  if (!provider) throw new Error('[Connect] No installed Stacks wallet found');\n  return generateTokenAndOpenPopup(options, makeSTXTransferToken, provider);\n}\n\nexport function openSignTransaction(\n  options: SignTransactionOptions,\n  provider: StacksProvider = getStacksProvider()\n) {\n  if (!provider) throw new Error('[Connect] No installed Stacks wallet found');\n  return generateTokenAndOpenPopup(options, makeSignTransaction, provider);\n}\n","import { Logger } from './logger';\n\n/**\n *  @ignore\n */\nexport const BLOCKSTACK_HANDLER = 'blockstack';\n\n/**\n * Time\n * @private\n * @ignore\n */\nexport function nextYear() {\n  return new Date(new Date().setFullYear(new Date().getFullYear() + 1));\n}\n\n/**\n * Time\n * @private\n * @ignore\n */\nexport function nextMonth() {\n  return new Date(new Date().setMonth(new Date().getMonth() + 1));\n}\n\n/**\n * Time\n * @private\n * @ignore\n */\nexport function nextHour() {\n  return new Date(new Date().setHours(new Date().getHours() + 1));\n}\n\n/**\n * Converts megabytes to bytes. Returns 0 if the input is not a finite number.\n * @ignore\n */\nexport function megabytesToBytes(megabytes: number): number {\n  if (!Number.isFinite(megabytes)) {\n    return 0;\n  }\n  return Math.floor(megabytes * 1024 * 1024);\n}\n\n/**\n * Calculate the AES-CBC ciphertext output byte length a given input length.\n * AES has a fixed block size of 16-bytes regardless key size.\n * @ignore\n */\nexport function getAesCbcOutputLength(inputByteLength: number) {\n  // AES-CBC block mode rounds up to the next block size.\n  const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;\n  return cipherTextLength;\n}\n\n/**\n * Calculate the base64 encoded string length for a given input length.\n * This is equivalent to the byte length when the string is ASCII or UTF8-8\n * encoded.\n * @param number\n */\nexport function getBase64OutputLength(inputByteLength: number) {\n  const encodedLength = Math.ceil(inputByteLength / 3) * 4;\n  return encodedLength;\n}\n\n/**\n * Query Strings\n * @private\n * @ignore\n */\n\nexport function updateQueryStringParameter(uri: string, key: string, value: string) {\n  const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');\n  const separator = uri.indexOf('?') !== -1 ? '&' : '?';\n  if (uri.match(re)) {\n    return uri.replace(re, `$1${key}=${value}$2`);\n  } else {\n    return `${uri}${separator}${key}=${value}`;\n  }\n}\n\n/**\n * Versioning\n * @param {string} v1 - the left half of the version inequality\n * @param {string} v2 - right half of the version inequality\n * @returns {bool} iff v1 >= v2\n * @private\n * @ignore\n */\n\nexport function isLaterVersion(v1: string, v2: string) {\n  if (v1 === undefined || v1 === '') {\n    v1 = '0.0.0';\n  }\n\n  if (v2 === undefined || v1 === '') {\n    v2 = '0.0.0';\n  }\n\n  const v1tuple = v1.split('.').map(x => parseInt(x, 10));\n  const v2tuple = v2.split('.').map(x => parseInt(x, 10));\n\n  for (let index = 0; index < v2.length; index++) {\n    if (index >= v1.length) {\n      v2tuple.push(0);\n    }\n    if (v1tuple[index] < v2tuple[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * UUIDs\n * @private\n * @ignore\n */\nexport function makeUUID4() {\n  let d = new Date().getTime();\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    d += performance.now(); // use high-precision timer if available\n  }\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n\n/**\n * Checks if both urls pass the same origin check & are absolute\n * @param  {[type]}  uri1 first uri to check\n * @param  {[type]}  uri2 second uri to check\n * @return {Boolean} true if they pass the same origin check\n * @private\n * @ignore\n */\nexport function isSameOriginAbsoluteUrl(uri1: string, uri2: string) {\n  try {\n    const parsedUri1 = new URL(uri1);\n    const parsedUri2 = new URL(uri2);\n\n    const port1 =\n      parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);\n    const port2 =\n      parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);\n\n    const match = {\n      scheme: parsedUri1.protocol === parsedUri2.protocol,\n      hostname: parsedUri1.hostname === parsedUri2.hostname,\n      port: port1 === port2,\n      absolute:\n        (uri1.includes('http://') || uri1.includes('https://')) &&\n        (uri2.includes('http://') || uri2.includes('https://')),\n    };\n\n    return match.scheme && match.hostname && match.port && match.absolute;\n  } catch (error) {\n    console.log(error);\n    console.log('Parsing error in same URL origin check');\n    // Parse error\n    return false;\n  }\n}\n\n/**\n * Returns the global scope `Window`, `WorkerGlobalScope`, or `NodeJS.Global` if available in the\n * currently executing environment.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/self\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope\n *\n * This could be switched to `globalThis` once it is standardized and widely available.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\n * @ignore\n */\nexport function getGlobalScope(): Window {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  // This function is meant to be called when accessing APIs that are typically only available in\n  // web-browser/DOM environments, but we also want to support situations where running in Node.js\n  // environment, and a polyfill was added to the Node.js `global` object scope without adding the\n  // `window` global object as well.\n  if (typeof global !== 'undefined') {\n    return global as unknown as Window;\n  }\n  throw new Error(\n    'Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available'\n  );\n}\n\nfunction getAPIUsageErrorMessage(\n  scopeObject: unknown,\n  apiName: string,\n  usageDesc?: string\n): string {\n  if (usageDesc) {\n    return `Use of '${usageDesc}' requires \\`${apiName}\\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n  } else {\n    return `\\`${apiName}\\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;\n  }\n}\n\ninterface GetGlobalObjectOptions {\n  /**\n   * Throw an error if the object is not found.\n   * @default false\n   */\n  throwIfUnavailable?: boolean;\n  /**\n   * Additional information to include in an error if thrown.\n   */\n  usageDesc?: string;\n  /**\n   * If the object is not found, return an new empty object instead of undefined.\n   * Requires [[throwIfUnavailable]] to be falsey.\n   * @default false\n   */\n  returnEmptyObject?: boolean;\n}\n\n/**\n * Returns an object from the global scope (`Window` or `WorkerGlobalScope`) if it\n * is available within the currently executing environment.\n * When executing within the Node.js runtime these APIs are unavailable and will be\n * `undefined` unless the API is provided via polyfill.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @ignore\n */\nexport function getGlobalObject<K extends Extract<keyof Window, string>>(\n  name: K,\n  { throwIfUnavailable, usageDesc, returnEmptyObject }: GetGlobalObjectOptions = {}\n): Window[K] | undefined {\n  let globalScope: Window | undefined = undefined;\n  try {\n    globalScope = getGlobalScope();\n    if (globalScope) {\n      const obj = globalScope[name];\n      if (obj) {\n        return obj;\n      }\n    }\n  } catch (error) {\n    Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);\n  }\n  if (throwIfUnavailable) {\n    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n    Logger.error(errMsg);\n    throw new Error(errMsg);\n  }\n  if (returnEmptyObject) {\n    return {} as any;\n  }\n  return undefined;\n}\n\n/**\n * Returns a specified subset of objects from the global scope (`Window` or `WorkerGlobalScope`)\n * if they are available within the currently executing environment.\n * When executing within the Node.js runtime these APIs are unavailable will be `undefined`\n * unless the API is provided via polyfill.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @ignore\n */\nexport function getGlobalObjects<K extends Extract<keyof Window, string>>(\n  names: K[],\n  { throwIfUnavailable, usageDesc, returnEmptyObject }: GetGlobalObjectOptions = {}\n): Pick<Window, K> {\n  let globalScope: Window | undefined;\n  try {\n    globalScope = getGlobalScope();\n  } catch (error) {\n    Logger.error(`Error getting global scope: ${error}`);\n    if (throwIfUnavailable) {\n      const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);\n      Logger.error(errMsg);\n      throw errMsg;\n    } else if (returnEmptyObject) {\n      globalScope = {} as any;\n    }\n  }\n\n  const result: Pick<Window, K> = {} as any;\n  for (let i = 0; i < names.length; i++) {\n    const name = names[i];\n    try {\n      if (globalScope) {\n        const obj = globalScope[name];\n        if (obj) {\n          result[name] = obj;\n        } else if (throwIfUnavailable) {\n          const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n          Logger.error(errMsg);\n          throw new Error(errMsg);\n        } else if (returnEmptyObject) {\n          result[name] = {} as any;\n        }\n      }\n    } catch (error) {\n      if (throwIfUnavailable) {\n        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n        Logger.error(errMsg);\n        throw new Error(errMsg);\n      }\n    }\n  }\n  return result;\n}\n// After removing bn.js library provide backward compatibility for users passing bn.js instance\ntype BN = import('bn.js'); // Type only import from @types/bn.js\nexport type IntegerType = number | string | bigint | Uint8Array | BN;\n\nexport function intToBytes(value: IntegerType, signed: boolean, byteLength: number): Uint8Array {\n  return bigIntToBytes(intToBigInt(value, signed), byteLength);\n}\n\nexport function intToBigInt(value: IntegerType, signed: boolean): bigint {\n  let parsedValue = value;\n\n  if (typeof parsedValue === 'number') {\n    if (!Number.isInteger(parsedValue)) {\n      throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);\n    }\n    if (parsedValue > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError(\n        `Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`\n      );\n    }\n    return BigInt(parsedValue);\n  }\n  if (typeof parsedValue === 'string') {\n    // If hex string then convert to bytes then fall through to the bytes condition\n    if (parsedValue.toLowerCase().startsWith('0x')) {\n      // Trim '0x' hex-prefix\n      let hex = parsedValue.slice(2);\n\n      // Allow odd-length strings like `0xf` -- some libs output these, or even just `0x${num.toString(16)}`\n      hex = hex.padStart(hex.length + (hex.length % 2), '0');\n\n      parsedValue = hexToBytes(hex);\n    } else {\n      try {\n        return BigInt(parsedValue);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);\n        }\n      }\n    }\n  }\n  if (typeof parsedValue === 'bigint') {\n    return parsedValue;\n  }\n  if (parsedValue instanceof Uint8Array) {\n    if (signed) {\n      // Allow byte arrays smaller than 128-bits to be passed.\n      // This allows positive signed ints like `0x08` (8) or negative signed\n      // ints like `0xf8` (-8) to be passed without having to pad to 16 bytes.\n      const bn = fromTwos(\n        BigInt(`0x${bytesToHex(parsedValue)}`),\n        BigInt(parsedValue.byteLength * 8)\n      );\n      return BigInt(bn.toString());\n    } else {\n      return BigInt(`0x${bytesToHex(parsedValue)}`);\n    }\n  }\n  // After removing bn.js library provide backward compatibility for users passing bn.js instance\n  // For backward compatibility with bn.js check if it's a bn.js instance\n  if (\n    parsedValue != null &&\n    typeof parsedValue === 'object' &&\n    parsedValue.constructor.name === 'BN'\n  ) {\n    return BigInt(parsedValue.toString());\n  }\n  throw new TypeError(\n    `Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`\n  );\n}\n\nexport function with0x(value: string): string {\n  return value.startsWith('0x') ? value : `0x${value}`;\n}\n\n/**\n * Converts hex input string to bigint\n * @param hex - hex input string without 0x prefix and in big endian format\n * @example \"6c7cde4d702830c1db34ef7c19e2776f59107afef39084776fc88bc78dbb9656\"\n * @ignore\n */\nexport function hexToBigInt(hex: string): bigint {\n  if (typeof hex !== 'string')\n    throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);\n  // Big Endian\n  return BigInt(`0x${hex}`);\n}\n\n/**\n * Converts IntegerType to hex string\n * @ignore\n */\nexport function intToHex(integer: IntegerType, lengthBytes = 8): string {\n  const value = typeof integer === 'bigint' ? integer : intToBigInt(integer, false);\n  return value.toString(16).padStart(lengthBytes * 2, '0');\n}\n\n/**\n * Converts hex string to integer\n * @ignore\n */\nexport function hexToInt(hex: string): number {\n  return parseInt(hex, 16);\n}\n\n/**\n * Converts bigint to byte array\n * @param value bigint value to be converted\n * @param length byte array optional length\n * @return {Uint8Array} byte array\n */\nexport function bigIntToBytes(value: bigint, length: number = 16): Uint8Array {\n  const hex = intToHex(value, length);\n  return hexToBytes(hex);\n}\n\n/**\n * Converts from signed number to two's complement\n * MIN_VALUE = -(1 << (width - 1))\n * MAX_VALUE =  (1 << (width - 1)) - 1\n * @ignore\n */\nexport function toTwos(value: bigint, width: bigint): bigint {\n  if (\n    value < -(BigInt(1) << (width - BigInt(1))) ||\n    (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value\n  ) {\n    throw `Unable to represent integer in width: ${width}`;\n  }\n  if (value >= BigInt(0)) {\n    return BigInt(value);\n  }\n  return value + (BigInt(1) << width);\n}\n\n/**\n * Returns nth bit (right-to-left, zero-indexed)\n */\nfunction nthBit(value: bigint, n: bigint) {\n  return value & (BigInt(1) << n);\n}\n\n/**\n * Converts from two's complement to signed number\n * @ignore\n */\nexport function fromTwos(value: bigint, width: bigint) {\n  if (nthBit(value, width - BigInt(1))) {\n    return value - (BigInt(1) << width);\n  }\n  return value;\n}\n\n// The following methods are based on `@noble/hashes` implementation\n// https://github.com/paulmillr/noble-hashes\n// Copyright (c) 2022 Paul Miller (https://paulmillr.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the “Software”), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\nconst hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n\n/**\n * Converts bytes to the equivalent hex string\n * @example\n * ```\n * bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'\n * ```\n */\nexport function bytesToHex(uint8a: Uint8Array): string {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (const u of uint8a) {\n    hex += hexes[u];\n  }\n  return hex;\n}\n\n/**\n * Converts a hex string to the equivalent bytes\n * @example\n * ```\n * hexToBytes('deadbeef') // Uint8Array(4) [ 222, 173, 190, 239 ]\n * ```\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') {\n    throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);\n  }\n  const paddedHex = hex.length % 2 ? `0${hex}` : hex; // left pad with a zero if odd length\n  const array = new Uint8Array(paddedHex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = paddedHex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts a UTF-8 string to the equivalent bytes\n * @example\n * ```\n * utf8ToBytes('stacks Ӿ'); // Uint8Array(9) [ 115, 116, 97, 99, 107, 115, 32, 211, 190 ];\n * ```\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  return new TextEncoder().encode(str);\n}\n\n/**\n * Converts bytes to the equivalent UTF-8 string\n * @example\n * ```\n * bytesToUtf8(Uint8Array.from([115, 116, 97, 99, 107, 115, 32, 211, 190])); // 'stacks Ӿ'\n * ```\n */\nexport function bytesToUtf8(arr: Uint8Array): string {\n  return new TextDecoder().decode(arr);\n}\n\n/**\n * Converts an ASCII string to the equivalent bytes\n * @example\n * ```\n * asciiToBytes('stacks $'); // Uint8Array(8) [ 115, 116, 97, 99, 107, 115, 32, 36 ]\n * ```\n */\nexport function asciiToBytes(str: string) {\n  const byteArray = [];\n  for (let i = 0; i < str.length; i++) {\n    byteArray.push(str.charCodeAt(i) & 0xff); // ignore second bytes of UTF-16 character\n  }\n  return new Uint8Array(byteArray);\n}\n\n/**\n * Converts bytes to the equivalent ASCII string\n * @example\n * ```\n * bytesToAscii(Uint8Array.from([115, 116, 97, 99, 107, 115, 32, 36])); // 'stacks $'\n * ```\n */\nexport function bytesToAscii(arr: Uint8Array) {\n  return String.fromCharCode.apply(null, arr as any as number[]);\n}\n\nfunction isNotOctet(octet: number) {\n  return !Number.isInteger(octet) || octet < 0 || octet > 255;\n}\n\n/** @ignore */\nexport function octetsToBytes(numbers: number[]) {\n  if (numbers.some(isNotOctet)) throw new Error('Some values are invalid bytes.');\n  return new Uint8Array(numbers);\n}\n\n/** @ignore */\nexport function toBytes(data: Uint8Array | string): Uint8Array {\n  if (typeof data === 'string') return utf8ToBytes(data);\n  if (data instanceof Uint8Array) return data;\n  throw new TypeError(`Expected input type is (Uint8Array | string) but got (${typeof data})`);\n}\n\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n * @ignore\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\n\n/** @ignore */\nexport function concatArray(elements: (Uint8Array | number[] | number)[]) {\n  return concatBytes(\n    ...elements.map(e => {\n      if (typeof e === 'number') return octetsToBytes([e]);\n      if (e instanceof Array) return octetsToBytes(e);\n      return e;\n    })\n  );\n}\n\n/**\n * Better `instanceof` check for types in different environments\n * @ignore\n */\nexport function isInstance(object: any, type: any) {\n  return object instanceof type || object?.constructor?.name?.toLowerCase() === type.name;\n}\n","import { UserSession } from '@stacks/auth';\nimport type { AuthOptions } from '../types/auth';\nimport {\n  PostConditionMode,\n  PostCondition,\n  AnchorMode,\n  ClarityValue,\n  StacksTransaction,\n} from '@stacks/transactions';\nimport { StacksNetwork } from '@stacks/network';\n\nexport interface TxBase {\n  appDetails?: AuthOptions['appDetails'];\n  postConditionMode?: PostConditionMode;\n  postConditions?: (string | PostCondition)[];\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  attachment?: string;\n  fee?: number | string;\n  /**\n   * Provide the Hiro Wallet with a suggested account to sign this transaction with.\n   * This is set by default if a `userSession` option is provided.\n   */\n  stxAddress?: string;\n  /** @deprecated `unused - only included for compatibility with @stacks/transactions` */\n  senderKey?: string;\n  /** @deprecated `unused - only included for compatibility with @stacks/transactions` */\n  nonce?: number;\n}\n\nexport interface SignTransactionBase {\n  appDetails?: AuthOptions['appDetails'];\n  network?: StacksNetwork;\n  attachment?: string;\n  /**\n   * Provide wallets with a suggested account to sign this transaction with.\n   * This is set by default if a `userSession` option is provided.\n   */\n  stxAddress?: string;\n  txHex: string;\n  /** @deprecated `unused - only included for compatibility with other transaction types` */\n  postConditions?: (string | PostCondition)[];\n}\n\nexport interface SponsoredFinishedTxPayload {\n  txRaw: string;\n}\n\nexport interface SponsoredFinishedTxData extends SponsoredFinishedTxPayload {\n  stacksTransaction: StacksTransaction;\n}\n\nexport interface FinishedTxPayload extends SponsoredFinishedTxPayload {\n  txId: string;\n}\n\nexport interface FinishedTxData extends FinishedTxPayload {\n  stacksTransaction: StacksTransaction;\n}\n\nexport enum TransactionTypes {\n  ContractCall = 'contract_call',\n  ContractDeploy = 'smart_contract',\n  STXTransfer = 'token_transfer',\n}\n\n/**\n * Contract Call\n */\n\nexport enum ContractCallArgumentType {\n  BUFFER = 'buffer',\n  UINT = 'uint',\n  INT = 'int',\n  PRINCIPAL = 'principal',\n  BOOL = 'bool',\n}\n\nexport interface ContractCallBase extends TxBase {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: (string | ClarityValue)[];\n}\n\nexport interface OptionsBase {\n  /**\n   * @deprecated Authentication is no longer supported through a hosted\n   * version. Users must install an extension.\n   */\n  authOrigin?: string;\n  userSession?: UserSession;\n}\n\nexport type SponsoredFinished = (data: SponsoredFinishedTxData) => void;\nexport type Finished = (data: FinishedTxData) => void;\nexport type Canceled = () => void;\n\nexport interface SponsoredOptionsBase extends TxBase, OptionsBase {\n  sponsored: true;\n  onFinish?: SponsoredFinished;\n  onCancel?: Canceled;\n}\n\nexport interface RegularOptionsBase extends TxBase, OptionsBase {\n  sponsored?: false;\n  onFinish?: Finished;\n  onCancel?: Canceled;\n}\n\nexport type ContractCallRegularOptions = ContractCallBase & RegularOptionsBase;\nexport type ContractCallSponsoredOptions = ContractCallBase & SponsoredOptionsBase;\nexport type ContractCallOptions = ContractCallRegularOptions | ContractCallSponsoredOptions;\n\nexport interface ContractCallArgument {\n  type: ContractCallArgumentType;\n  value: string;\n}\n\nexport interface ContractCallPayload extends ContractCallBase {\n  txType: TransactionTypes.ContractCall;\n  publicKey: string;\n  functionArgs: string[];\n  sponsored?: boolean;\n}\n\n/**\n * Contract Deploy\n */\nexport interface ContractDeployBase extends TxBase {\n  contractName: string;\n  codeBody: string;\n}\n\nexport type ContractDeployRegularOptions = ContractDeployBase & RegularOptionsBase;\nexport type ContractDeploySponsoredOptions = ContractDeployBase & SponsoredOptionsBase;\nexport type ContractDeployOptions = ContractDeployRegularOptions | ContractDeploySponsoredOptions;\n\nexport interface ContractDeployPayload extends ContractDeployBase {\n  publicKey: string;\n  txType: TransactionTypes.ContractDeploy;\n  sponsored?: boolean;\n}\n\n/**\n * STX Transfer\n */\n\nexport interface STXTransferBase extends TxBase {\n  recipient: string;\n  amount: BigInt | string;\n  memo?: string;\n}\n\nexport type STXTransferRegularOptions = STXTransferBase & RegularOptionsBase;\nexport type STXTransferSponsoredOptions = STXTransferBase & SponsoredOptionsBase;\nexport type STXTransferOptions = STXTransferRegularOptions | STXTransferSponsoredOptions;\n\nexport interface STXTransferPayload extends STXTransferBase {\n  publicKey: string;\n  txType: TransactionTypes.STXTransfer;\n  amount: string;\n  sponsored?: boolean;\n}\n\n/**\n * Transaction Popup\n */\n\nexport type TransactionOptions =\n  | ContractCallOptions\n  | ContractDeployOptions\n  | STXTransferOptions\n  | SignTransactionOptions;\nexport type TransactionPayload =\n  | ContractCallPayload\n  | ContractDeployPayload\n  | STXTransferPayload\n  | SignTransactionPayload;\n\nexport interface TransactionPopup {\n  token: string;\n  options: TransactionOptions;\n}\n\nexport interface SignTransactionOptionBase extends SignTransactionBase, OptionsBase {\n  onFinish?: SignTransactionFinished;\n  onCancel?: Canceled;\n}\n\nexport interface SignTransactionPayload extends SignTransactionBase {\n  publicKey: string;\n}\n\nexport type SignTransactionFinished = (data: SignTransactionFinishedTxData) => void;\n\nexport type SignTransactionOptions = SignTransactionOptionBase;\n\nexport interface SignTransactionFinishedTxData {\n  stacksTransaction: StacksTransaction;\n}\n","import { StacksTestnet } from '@stacks/network';\nimport { ChainID } from '@stacks/transactions';\nimport { createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getKeys, getUserSession, hasAppPrivateKey } from '../transactions';\nimport {\n  CommonSignatureRequestOptions,\n  SignatureOptions,\n  SignaturePayload,\n  SignaturePopup,\n  SignatureRequestOptions,\n} from '../types/signature';\nimport { getStacksProvider } from '../utils';\nimport { StacksProvider } from '../types';\n\nfunction getStxAddress(options: CommonSignatureRequestOptions) {\n  const { userSession, network } = options;\n\n  if (!userSession || !network) return undefined;\n  const stxAddresses = userSession?.loadUserData().profile?.stxAddress;\n  const chainIdToKey = {\n    [ChainID.Mainnet]: 'mainnet',\n    [ChainID.Testnet]: 'testnet',\n  };\n  const address: string | undefined = stxAddresses?.[chainIdToKey[network.chainId]];\n  return address;\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: SignaturePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({ ...payload } as any);\n}\n\nexport function getDefaultSignatureRequestOptions(options: CommonSignatureRequestOptions) {\n  const network = options.network || new StacksTestnet();\n  const userSession = getUserSession(options.userSession);\n  const defaults: CommonSignatureRequestOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n  return {\n    stxAddress: getStxAddress(defaults),\n    ...defaults,\n  };\n}\n\nasync function openSignaturePopup({ token, options }: SignaturePopup, provider: StacksProvider) {\n  try {\n    const signatureResponse = await provider.signatureRequest(token);\n    options.onFinish?.(signatureResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\nexport interface SignatureRequestPayload {\n  message: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const signMessage = async (options: SignatureRequestOptions) => {\n  const { userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n\n    const payload: SignaturePayload = {\n      ..._options,\n      publicKey,\n    };\n\n    return signPayload(payload, privateKey);\n  }\n  const payload = { ..._options };\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return createUnsecuredToken(payload as any);\n};\n\nasync function generateTokenAndOpenPopup<T extends SignatureOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>,\n  provider: StacksProvider\n) {\n  const token = await makeTokenFn({\n    ...getDefaultSignatureRequestOptions(options),\n    ...options,\n  } as T);\n  return openSignaturePopup({ token, options }, provider);\n}\n\nexport function openSignatureRequestPopup(\n  options: SignatureRequestOptions,\n  provider: StacksProvider = getStacksProvider()\n) {\n  if (!provider) throw new Error('[Connect] No installed Stacks wallet found');\n  return generateTokenAndOpenPopup(options, signMessage, provider);\n}\n","import { bytesToHex } from '@stacks/common';\nimport { serializeCV } from '@stacks/transactions';\nimport { createUnsecuredToken, TokenSigner } from 'jsontokens';\nimport { getDefaultSignatureRequestOptions } from '.';\nimport { getKeys, hasAppPrivateKey } from '../transactions';\nimport {\n  StructuredDataSignatureOptions,\n  StructuredDataSignaturePayload,\n  StructuredDataSignaturePopup,\n  StructuredDataSignatureRequestOptions,\n} from '../types/structuredDataSignature';\nimport { getStacksProvider } from '../utils';\nimport { StacksProvider } from '../types';\n\nasync function generateTokenAndOpenPopup<T extends StructuredDataSignatureOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>,\n  provider: StacksProvider\n) {\n  const token = await makeTokenFn({\n    ...getDefaultSignatureRequestOptions(options),\n    ...options,\n  } as T);\n  return openStructuredDataSignaturePopup({ token, options }, provider);\n}\n\nfunction parseUnserializableBigIntValues(payload: any) {\n  return {\n    ...payload,\n    message: bytesToHex(serializeCV(payload.message)),\n    domain: bytesToHex(serializeCV(payload.domain)),\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: StructuredDataSignaturePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.signAsync(parseUnserializableBigIntValues(payload));\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function signStructuredMessage(options: StructuredDataSignatureRequestOptions) {\n  const { userSession, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n    const payload: StructuredDataSignaturePayload = {\n      ..._options,\n      publicKey,\n    };\n    return signPayload(payload, privateKey);\n  }\n  // Type casting `any` as payload contains non-serialisable content,\n  // such as `StacksNetwork`\n  return createUnsecuredToken(parseUnserializableBigIntValues(options));\n}\n\nasync function openStructuredDataSignaturePopup(\n  { token, options }: StructuredDataSignaturePopup,\n  provider: StacksProvider\n) {\n  try {\n    const signatureResponse = await provider.structuredDataSignatureRequest(token);\n\n    options.onFinish?.(signatureResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\nexport function openStructuredDataSignatureRequestPopup(\n  options: StructuredDataSignatureRequestOptions,\n  provider: StacksProvider = getStacksProvider()\n) {\n  if (!provider) throw new Error('[Connect] No installed Stacks wallet found');\n  return generateTokenAndOpenPopup(options, signStructuredMessage, provider);\n}\n","import { StacksTestnet } from '@stacks/network';\nimport { createUnsecuredToken, Json, TokenSigner } from 'jsontokens';\nimport { getKeys, getUserSession, hasAppPrivateKey } from '../transactions';\nimport {\n  ProfileUpdatePayload,\n  ProfileUpdatePopup,\n  ProfileUpdateRequestOptions,\n  StacksProvider,\n} from '../types';\n\nimport { getStacksProvider } from '../utils';\n\n// eslint-disable-next-line @typescript-eslint/require-await\nasync function signPayload(payload: ProfileUpdatePayload, privateKey: string) {\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return tokenSigner.signAsync({ ...payload } as any);\n}\n\nexport function getDefaultProfileUpdateRequestOptions(options: ProfileUpdateRequestOptions) {\n  const network = options.network || new StacksTestnet();\n  const userSession = getUserSession(options.userSession);\n  const defaults: ProfileUpdateRequestOptions = {\n    ...options,\n    network,\n    userSession,\n  };\n  return {\n    ...defaults,\n  };\n}\n\nasync function openProfileUpdatePopup(\n  { token, options }: ProfileUpdatePopup,\n  provider: StacksProvider\n) {\n  try {\n    const profileUpdateResponse = await provider.profileUpdateRequest(token);\n    options.onFinish?.(profileUpdateResponse);\n  } catch (error) {\n    console.error('[Connect] Error during signature request', error);\n    options.onCancel?.();\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const makeProfileUpdateToken = async (options: ProfileUpdateRequestOptions) => {\n  const { userSession, profile, ..._options } = options;\n  if (hasAppPrivateKey(userSession)) {\n    const { privateKey, publicKey } = getKeys(userSession);\n\n    const payload: ProfileUpdatePayload = {\n      ..._options,\n      profile,\n      publicKey,\n    };\n\n    return signPayload(payload, privateKey);\n  }\n  const payload = { ..._options };\n  return createUnsecuredToken(payload as Json);\n};\n\nasync function generateTokenAndOpenPopup<T extends ProfileUpdateRequestOptions>(\n  options: T,\n  makeTokenFn: (options: T) => Promise<string>,\n  provider: StacksProvider\n) {\n  const token = await makeTokenFn({\n    ...getDefaultProfileUpdateRequestOptions(options),\n    ...options,\n  } as T);\n  return openProfileUpdatePopup({ token, options }, provider);\n}\n\nexport function openProfileUpdateRequestPopup(\n  options: ProfileUpdateRequestOptions,\n  provider: StacksProvider = getStacksProvider()\n) {\n  if (!provider) throw new Error('[Connect] No installed Stacks wallet found');\n  return generateTokenAndOpenPopup(options, makeProfileUpdateToken, provider);\n}\n","import { UserSession } from '@stacks/auth';\nimport { StacksNetwork } from '@stacks/network';\n\nimport { AuthOptions } from './auth';\n\n// Taken from @scure/btc-signer\n// https://github.com/paulmillr/scure-btc-signer\nexport enum SignatureHash {\n  DEFAULT = 0,\n  ALL = 1,\n  NONE = 2,\n  SINGLE = 3,\n  ANYONECANPAY = 0x80,\n}\n\nexport interface PsbtData {\n  hex: string;\n}\n\nexport type PsbtCanceled = () => void;\nexport type PsbtFinished = (data: PsbtData) => void;\n\nexport interface PsbtBase {\n  appDetails?: AuthOptions['appDetails'];\n  authOrigin?: string;\n  network?: StacksNetwork;\n  onCancel?: PsbtCanceled;\n  onFinish?: PsbtFinished;\n  stxAddress?: string;\n  userSession?: UserSession;\n}\n\nexport interface PsbtRequestOptions extends PsbtBase {\n  allowedSighash?: SignatureHash[];\n  hex: string;\n  signAtIndex?: number | number[];\n}\n\nexport interface CommonPsbtPayload extends PsbtBase {\n  publicKey: string;\n}\n\nexport interface PsbtPayload extends CommonPsbtPayload {\n  allowedSighash?: SignatureHash[];\n  hex: string;\n  signAtIndex?: number | number[];\n}\n\n/**\n * Psbt Popup\n */\nexport interface PsbtPopup {\n  token: string;\n  options: PsbtRequestOptions;\n}\n","import { authenticate } from './auth';\nimport type { AuthOptions } from './types/auth';\nimport { defineCustomElements } from '@stacks/connect-ui/loader';\nimport { getStacksProvider } from './utils';\nimport { StacksProvider } from './types';\n\nexport const showConnect = (\n  authOptions: AuthOptions,\n  provider: StacksProvider = getStacksProvider()\n) => {\n  if (provider) {\n    void authenticate(authOptions, provider);\n    return;\n  }\n\n  if (typeof window !== undefined) {\n    void defineCustomElements(window);\n    const element = document.createElement('connect-modal');\n    element.authOptions = authOptions;\n    document.body.appendChild(element);\n    const handleEsc = (ev: KeyboardEvent) => {\n      if (ev.key === 'Escape') {\n        document.removeEventListener('keydown', handleEsc);\n        element.remove();\n      }\n    };\n    document.addEventListener('keydown', handleEsc);\n  }\n};\n\n/**\n * @deprecated Use the renamed `showConnect` method\n */\nexport const showBlockstackConnect = (authOptions: AuthOptions) => showConnect(authOptions);\n","export * from './auth';\nexport * from './bitcoin';\nexport * from './transactions';\nexport * from './signature';\nexport * from './signature/structuredData';\nexport * from './profile';\nexport * from './types';\nexport * from './utils';\nexport * from './ui';\nexport * from '@stacks/auth';\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}