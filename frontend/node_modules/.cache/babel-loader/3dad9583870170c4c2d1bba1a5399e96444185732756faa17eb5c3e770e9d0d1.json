{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { bytesToHex, bytesToUtf8, getGlobalObject, hexToBytes, makeUUID4, nextMonth, utf8ToBytes } from '@stacks/common';\nimport { decryptECIES, encryptECIES, makeECPrivateKey, publicKeyToBtcAddress } from '@stacks/encryption';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport { DEFAULT_SCOPE } from './constants';\nimport { makeDIDFromAddress } from './dids';\nvar VERSION = '1.4.0';\nexport function generateTransitKey() {\n  var transitKey = makeECPrivateKey();\n  return transitKey;\n}\nexport var makeAuthRequest = makeAuthRequestToken;\nexport function makeAuthRequestToken(transitPrivateKey, redirectURI, manifestURI) {\n  var scopes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_SCOPE.slice();\n  var appDomain = arguments.length > 4 ? arguments[4] : undefined;\n  var expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextMonth().getTime();\n  var extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n  var getWindowOrigin = function getWindowOrigin(paramName) {\n    var location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: \"makeAuthRequest([\".concat(paramName, \"=undefined])\")\n    });\n    return location === null || location === void 0 ? void 0 : location.origin;\n  };\n  if (!redirectURI) {\n    redirectURI = \"\".concat(getWindowOrigin('redirectURI'), \"/\");\n  }\n  if (!manifestURI) {\n    manifestURI = \"\".concat(getWindowOrigin('manifestURI'), \"/manifest.json\");\n  }\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n  var payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes: scopes\n  });\n  var publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  var address = publicKeyToBtcAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n  var tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  var token = tokenSigner.sign(payload);\n  return token;\n}\nexport function encryptPrivateKey(_x, _x2) {\n  return _encryptPrivateKey.apply(this, arguments);\n}\nfunction _encryptPrivateKey() {\n  _encryptPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(publicKey, privateKey) {\n    var encryptedObj, encryptedJSON;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return encryptECIES(publicKey, utf8ToBytes(privateKey), true);\n        case 2:\n          encryptedObj = _context.sent;\n          encryptedJSON = JSON.stringify(encryptedObj);\n          return _context.abrupt(\"return\", bytesToHex(utf8ToBytes(encryptedJSON)));\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _encryptPrivateKey.apply(this, arguments);\n}\nexport function decryptPrivateKey(_x3, _x4) {\n  return _decryptPrivateKey.apply(this, arguments);\n}\nfunction _decryptPrivateKey() {\n  _decryptPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(privateKey, hexedEncrypted) {\n    var unhexedString, encryptedObj, decrypted;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          unhexedString = bytesToUtf8(hexToBytes(hexedEncrypted));\n          encryptedObj = JSON.parse(unhexedString);\n          _context2.next = 4;\n          return decryptECIES(privateKey, encryptedObj);\n        case 4:\n          decrypted = _context2.sent;\n          if (!(typeof decrypted !== 'string')) {\n            _context2.next = 9;\n            break;\n          }\n          throw new Error('Unable to correctly decrypt private key');\n        case 9:\n          return _context2.abrupt(\"return\", decrypted);\n        case 10:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _decryptPrivateKey.apply(this, arguments);\n}\nexport function makeAuthResponse(_x5) {\n  return _makeAuthResponse.apply(this, arguments);\n}\nfunction _makeAuthResponse() {\n  _makeAuthResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(privateKey) {\n    var profile,\n      metadata,\n      coreToken,\n      appPrivateKey,\n      expiresAt,\n      transitPublicKey,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      appPrivateKeyFromWalletSalt,\n      publicKey,\n      address,\n      privateKeyPayload,\n      coreTokenPayload,\n      additionalProperties,\n      payload,\n      tokenSigner,\n      _args3 = arguments;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          profile = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n          metadata = _args3.length > 2 ? _args3[2] : undefined;\n          coreToken = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : null;\n          appPrivateKey = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : null;\n          expiresAt = _args3.length > 5 && _args3[5] !== undefined ? _args3[5] : nextMonth().getTime();\n          transitPublicKey = _args3.length > 6 && _args3[6] !== undefined ? _args3[6] : null;\n          hubUrl = _args3.length > 7 && _args3[7] !== undefined ? _args3[7] : null;\n          blockstackAPIUrl = _args3.length > 8 && _args3[8] !== undefined ? _args3[8] : null;\n          associationToken = _args3.length > 9 && _args3[9] !== undefined ? _args3[9] : null;\n          appPrivateKeyFromWalletSalt = _args3.length > 10 && _args3[10] !== undefined ? _args3[10] : null;\n          publicKey = SECP256K1Client.derivePublicKey(privateKey);\n          address = publicKeyToBtcAddress(publicKey);\n          privateKeyPayload = appPrivateKey;\n          coreTokenPayload = coreToken;\n          additionalProperties = {};\n          if (!(appPrivateKey !== undefined && appPrivateKey !== null)) {\n            _context3.next = 27;\n            break;\n          }\n          if (!(transitPublicKey !== undefined && transitPublicKey !== null)) {\n            _context3.next = 24;\n            break;\n          }\n          _context3.next = 19;\n          return encryptPrivateKey(transitPublicKey, appPrivateKey);\n        case 19:\n          privateKeyPayload = _context3.sent;\n          if (!(coreToken !== undefined && coreToken !== null)) {\n            _context3.next = 24;\n            break;\n          }\n          _context3.next = 23;\n          return encryptPrivateKey(transitPublicKey, coreToken);\n        case 23:\n          coreTokenPayload = _context3.sent;\n        case 24:\n          additionalProperties = {\n            email: metadata !== null && metadata !== void 0 && metadata.email ? metadata.email : null,\n            profile_url: metadata !== null && metadata !== void 0 && metadata.profileUrl ? metadata.profileUrl : null,\n            hubUrl: hubUrl,\n            blockstackAPIUrl: blockstackAPIUrl,\n            associationToken: associationToken,\n            version: VERSION\n          };\n          _context3.next = 27;\n          break;\n        case 27:\n          payload = Object.assign({}, {\n            jti: makeUUID4(),\n            iat: Math.floor(new Date().getTime() / 1000),\n            exp: Math.floor(expiresAt / 1000),\n            iss: makeDIDFromAddress(address),\n            private_key: privateKeyPayload,\n            public_keys: [publicKey],\n            appPrivateKeyFromWalletSalt: appPrivateKeyFromWalletSalt,\n            profile: profile,\n            core_token: coreTokenPayload\n          }, additionalProperties);\n          tokenSigner = new TokenSigner('ES256k', privateKey);\n          return _context3.abrupt(\"return\", tokenSigner.sign(payload));\n        case 30:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _makeAuthResponse.apply(this, arguments);\n}","map":{"version":3,"names":["bytesToHex","bytesToUtf8","getGlobalObject","hexToBytes","makeUUID4","nextMonth","utf8ToBytes","decryptECIES","encryptECIES","makeECPrivateKey","publicKeyToBtcAddress","SECP256K1Client","TokenSigner","DEFAULT_SCOPE","makeDIDFromAddress","VERSION","generateTransitKey","transitKey","makeAuthRequest","makeAuthRequestToken","transitPrivateKey","redirectURI","manifestURI","scopes","arguments","length","undefined","slice","appDomain","expiresAt","getTime","extraParams","getWindowOrigin","paramName","location","throwIfUnavailable","usageDesc","concat","origin","payload","Object","assign","jti","iat","Math","floor","Date","exp","iss","public_keys","domain_name","manifest_uri","redirect_uri","version","do_not_include_profile","supports_hub_url","publicKey","derivePublicKey","address","tokenSigner","token","sign","encryptPrivateKey","_x","_x2","_encryptPrivateKey","apply","_asyncToGenerator","_regeneratorRuntime","mark","_callee","privateKey","encryptedObj","encryptedJSON","wrap","_callee$","_context","prev","next","sent","JSON","stringify","abrupt","stop","decryptPrivateKey","_x3","_x4","_decryptPrivateKey","_callee2","hexedEncrypted","unhexedString","decrypted","_callee2$","_context2","parse","Error","makeAuthResponse","_x5","_makeAuthResponse","_callee3","profile","metadata","coreToken","appPrivateKey","transitPublicKey","hubUrl","blockstackAPIUrl","associationToken","appPrivateKeyFromWalletSalt","privateKeyPayload","coreTokenPayload","additionalProperties","_args3","_callee3$","_context3","email","profile_url","profileUrl","private_key","core_token"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\auth\\src\\messages.ts"],"sourcesContent":["import {\n  bytesToHex,\n  bytesToUtf8,\n  getGlobalObject,\n  hexToBytes,\n  makeUUID4,\n  nextMonth,\n  utf8ToBytes,\n} from '@stacks/common';\nimport {\n  decryptECIES,\n  encryptECIES,\n  makeECPrivateKey,\n  publicKeyToBtcAddress,\n} from '@stacks/encryption';\nimport { SECP256K1Client, TokenSigner } from 'jsontokens';\nimport { AuthScope, DEFAULT_SCOPE } from './constants';\nimport { makeDIDFromAddress } from './dids';\n\nconst VERSION = '1.4.0';\n\ntype AuthMetadata = {\n  email?: string;\n  profileUrl?: string;\n};\n\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\n\n/** @deprecated {@link makeAuthRequest} was renamed to {@link makeAuthRequestToken} */\nexport const makeAuthRequest = makeAuthRequestToken;\n\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {(AuthScope | string)[]} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\nexport function makeAuthRequestToken(\n  transitPrivateKey: string,\n  redirectURI?: string,\n  manifestURI?: string,\n  scopes: (AuthScope | string)[] = DEFAULT_SCOPE.slice(),\n  appDomain?: string,\n  expiresAt: number = nextMonth().getTime(),\n  extraParams: any = {}\n): string {\n  const getWindowOrigin = (paramName: string) => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`,\n    });\n    return location?.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n\n  /* Create the payload */\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n    exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes,\n  });\n\n  // Logger.info(`blockstack.js: generating v${VERSION} auth request`)\n\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToBtcAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n\n  return token;\n}\n\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\nexport async function encryptPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n  const encryptedObj = await encryptECIES(publicKey, utf8ToBytes(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return bytesToHex(utf8ToBytes(encryptedJSON));\n}\n\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\nexport async function decryptPrivateKey(\n  privateKey: string,\n  hexedEncrypted: string\n): Promise<string | null> {\n  const unhexedString = bytesToUtf8(hexToBytes(hexedEncrypted));\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\n\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\nexport async function makeAuthResponse(\n  privateKey: string,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  profile: {} = {},\n  metadata: AuthMetadata | null,\n  coreToken: string | null = null,\n  appPrivateKey: string | null = null,\n  expiresAt: number = nextMonth().getTime(),\n  transitPublicKey: string | null = null,\n  hubUrl: string | null = null,\n  blockstackAPIUrl: string | null = null,\n  associationToken: string | null = null,\n  appPrivateKeyFromWalletSalt: string | null = null\n): Promise<string> {\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToBtcAddress(publicKey);\n\n  /* See if we should encrypt with the transit key */\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    // Logger.info(`blockstack.js: generating v${VERSION} auth response`)\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n    additionalProperties = {\n      email: metadata?.email ? metadata.email : null,\n      profile_url: metadata?.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION,\n    };\n  } else {\n    // Logger.info('blockstack.js: generating legacy auth response')\n  }\n\n  /* Create the payload */\n  const payload = Object.assign(\n    {},\n    {\n      jti: makeUUID4(),\n      iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n      exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n      iss: makeDIDFromAddress(address),\n      private_key: privateKeyPayload,\n      public_keys: [publicKey],\n      appPrivateKeyFromWalletSalt,\n      profile,\n      core_token: coreTokenPayload,\n    },\n    additionalProperties\n  );\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}