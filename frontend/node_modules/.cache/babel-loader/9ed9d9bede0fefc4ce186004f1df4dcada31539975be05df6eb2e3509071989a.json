{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey, getSharedSecret, Point, Signature, signSync, utils, verify } from '@noble/secp256k1';\nimport { bigIntToBytes, bytesToHex, bytesToUtf8, concatBytes, FailedDecryptionError, hexToBigInt, hexToBytes, parseRecoverableSignatureVrs, signatureRsvToVrs, utf8ToBytes } from '@stacks/common';\nimport { fromByteArray, toByteArray } from 'base64-js';\nimport { createCipher } from './aesCipher';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { encodeMessage, hashMessage } from './messageSignature';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\nutils.hmacSha256Sync = function (key) {\n  var h = hmac.create(sha256, key);\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n  msgs.forEach(function (msg) {\n    return h.update(msg);\n  });\n  return h.digest();\n};\nexport var InvalidPublicKeyReason;\n(function (InvalidPublicKeyReason) {\n  InvalidPublicKeyReason[\"InvalidFormat\"] = \"InvalidFormat\";\n  InvalidPublicKeyReason[\"IsNotPoint\"] = \"IsNotPoint\";\n})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));\nexport function aes256CbcEncrypt(_x, _x2, _x3) {\n  return _aes256CbcEncrypt.apply(this, arguments);\n}\nfunction _aes256CbcEncrypt() {\n  _aes256CbcEncrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(iv, key, plaintext) {\n    var cipher;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return createCipher();\n        case 2:\n          cipher = _context.sent;\n          _context.next = 5;\n          return cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n        case 5:\n          return _context.abrupt(\"return\", _context.sent);\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _aes256CbcEncrypt.apply(this, arguments);\n}\nfunction aes256CbcDecrypt(_x4, _x5, _x6) {\n  return _aes256CbcDecrypt.apply(this, arguments);\n}\nfunction _aes256CbcDecrypt() {\n  _aes256CbcDecrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(iv, key, ciphertext) {\n    var cipher;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return createCipher();\n        case 2:\n          cipher = _context2.sent;\n          _context2.next = 5;\n          return cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n        case 5:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _aes256CbcDecrypt.apply(this, arguments);\n}\nexport function hmacSha256(key, content) {\n  return hmac(sha256, key, content);\n}\nfunction equalsConstTime(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < a.length; i++) {\n    res |= a[i] ^ b[i];\n  }\n  return res === 0;\n}\nfunction sharedSecretToKeys(sharedSecret) {\n  var hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\nfunction allHexChars(maybe) {\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\nfunction isValidPublicKey(pub) {\n  var invalidFormat = {\n    result: false,\n    reason_data: 'Invalid public key format',\n    reason: InvalidPublicKeyReason.InvalidFormat\n  };\n  var invalidPoint = {\n    result: false,\n    reason_data: 'Public key is not a point',\n    reason: InvalidPublicKeyReason.IsNotPoint\n  };\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\n  var firstByte = pub.slice(0, 2);\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\n  if (!allHexChars(pub)) return invalidFormat;\n  try {\n    var point = Point.fromHex(pub);\n    point.assertValidity();\n    return {\n      result: true,\n      reason_data: null,\n      reason: null\n    };\n  } catch (e) {\n    return invalidPoint;\n  }\n}\nexport function getHexFromBN(bnInput) {\n  var hexOut = bnInput.toString(16);\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    var padding = '0'.repeat(64 - hexOut.length);\n    return \"\".concat(padding).concat(hexOut);\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\nexport function getBytesFromBN(bnInput) {\n  var result = bigIntToBytes(bnInput, 32);\n  if (result.byteLength !== 32) {\n    throw new Error('Failed to generate a 32-byte Uint8Array');\n  }\n  return result;\n}\nexport function getCipherObjectWrapper(opts) {\n  var shell = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString\n  };\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n  var ivLength = 32;\n  var ephemeralPKLength = 66;\n  var macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell)\n  };\n}\nexport function getSignedCipherObjectWrapper(payloadShell) {\n  var shell = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell\n  };\n  var signatureLength = 144;\n  var publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell)\n  };\n}\nexport function eciesGetJsonStringLength(opts) {\n  var _getCipherObjectWrapp = getCipherObjectWrapper(opts),\n    payloadShell = _getCipherObjectWrapp.payloadShell,\n    payloadValuesLength = _getCipherObjectWrapp.payloadValuesLength;\n  var cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n  var encodedCipherTextLength;\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(\"Unexpected cipherTextEncoding \\\"\".concat(opts.cipherTextEncoding, \"\\\"\"));\n  }\n  if (!opts.sign) {\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    var _getSignedCipherObjec = getSignedCipherObjectWrapper(payloadShell),\n      signedPayloadShell = _getSignedCipherObjec.signedPayloadShell,\n      signedPayloadValuesLength = _getSignedCipherObjec.signedPayloadValuesLength;\n    return signedPayloadShell.length + signedPayloadValuesLength + payloadValuesLength + encodedCipherTextLength;\n  }\n}\nexport function encryptECIES(_x7, _x8, _x9, _x10) {\n  return _encryptECIES.apply(this, arguments);\n}\nfunction _encryptECIES() {\n  _encryptECIES = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(publicKey, content, wasString, cipherTextEncoding) {\n    var validity, ephemeralPrivateKey, ephemeralPublicKey, sharedSecret, sharedKeys, initializationVector, cipherText, macData, mac, cipherTextString, result;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          validity = isValidPublicKey(publicKey);\n          if (validity.result) {\n            _context3.next = 3;\n            break;\n          }\n          throw validity;\n        case 3:\n          ephemeralPrivateKey = utils.randomPrivateKey();\n          ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);\n          sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);\n          sharedSecret = sharedSecret.slice(1);\n          sharedKeys = sharedSecretToKeys(sharedSecret);\n          initializationVector = utils.randomBytes(16);\n          _context3.next = 11;\n          return aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);\n        case 11:\n          cipherText = _context3.sent;\n          macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);\n          mac = hmacSha256(sharedKeys.hmacKey, macData);\n          if (!(!cipherTextEncoding || cipherTextEncoding === 'hex')) {\n            _context3.next = 18;\n            break;\n          }\n          cipherTextString = bytesToHex(cipherText);\n          _context3.next = 23;\n          break;\n        case 18:\n          if (!(cipherTextEncoding === 'base64')) {\n            _context3.next = 22;\n            break;\n          }\n          cipherTextString = fromByteArray(cipherText);\n          _context3.next = 23;\n          break;\n        case 22:\n          throw new Error(\"Unexpected cipherTextEncoding \\\"\".concat(cipherTextEncoding, \"\\\"\"));\n        case 23:\n          result = {\n            iv: bytesToHex(initializationVector),\n            ephemeralPK: bytesToHex(ephemeralPublicKey),\n            cipherText: cipherTextString,\n            mac: bytesToHex(mac),\n            wasString: wasString\n          };\n          if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n            result.cipherTextEncoding = cipherTextEncoding;\n          }\n          return _context3.abrupt(\"return\", result);\n        case 26:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _encryptECIES.apply(this, arguments);\n}\nexport function decryptECIES(_x11, _x12) {\n  return _decryptECIES.apply(this, arguments);\n}\nfunction _decryptECIES() {\n  _decryptECIES = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(privateKey, cipherObject) {\n    var ephemeralPK, sharedSecret, sharedKeys, ivBytes, cipherTextBytes, macData, actualMac, expectedMac, plainText;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          if (cipherObject.ephemeralPK) {\n            _context4.next = 2;\n            break;\n          }\n          throw new FailedDecryptionError('Unable to get public key from cipher object. ' + 'You might be trying to decrypt an unencrypted object.');\n        case 2:\n          ephemeralPK = cipherObject.ephemeralPK;\n          sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);\n          sharedSecret = sharedSecret.slice(1);\n          sharedKeys = sharedSecretToKeys(sharedSecret);\n          ivBytes = hexToBytes(cipherObject.iv);\n          if (!(!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex')) {\n            _context4.next = 11;\n            break;\n          }\n          cipherTextBytes = hexToBytes(cipherObject.cipherText);\n          _context4.next = 16;\n          break;\n        case 11:\n          if (!(cipherObject.cipherTextEncoding === 'base64')) {\n            _context4.next = 15;\n            break;\n          }\n          cipherTextBytes = toByteArray(cipherObject.cipherText);\n          _context4.next = 16;\n          break;\n        case 15:\n          throw new Error(\"Unexpected cipherTextEncoding \\\"\".concat(cipherObject.cipherText, \"\\\"\"));\n        case 16:\n          macData = concatBytes(ivBytes, hexToBytes(ephemeralPK), cipherTextBytes);\n          actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n          expectedMac = hexToBytes(cipherObject.mac);\n          if (equalsConstTime(expectedMac, actualMac)) {\n            _context4.next = 21;\n            break;\n          }\n          throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n        case 21:\n          _context4.next = 23;\n          return aes256CbcDecrypt(ivBytes, sharedKeys.encryptionKey, cipherTextBytes);\n        case 23:\n          plainText = _context4.sent;\n          if (!cipherObject.wasString) {\n            _context4.next = 26;\n            break;\n          }\n          return _context4.abrupt(\"return\", bytesToUtf8(plainText));\n        case 26:\n          return _context4.abrupt(\"return\", plainText);\n        case 27:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _decryptECIES.apply(this, arguments);\n}\nexport function signECDSA(privateKey, content) {\n  var contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  var publicKey = getPublicKeyFromPrivate(privateKey);\n  var contentHash = hashSha256Sync(contentBytes);\n  var signature = signSync(contentHash, privateKey);\n  return {\n    signature: bytesToHex(signature),\n    publicKey: publicKey\n  };\n}\nexport function verifyECDSA(content, publicKey, signature) {\n  var contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  var contentHash = hashSha256Sync(contentBytes);\n  return verify(signature, contentHash, publicKey, {\n    strict: false\n  });\n}\nexport function verifyMessageSignature(_ref) {\n  var signature = _ref.signature,\n    message = _ref.message,\n    publicKey = _ref.publicKey;\n  var _parseRecoverableSign = parseRecoverableSignatureVrs(signature),\n    r = _parseRecoverableSign.r,\n    s = _parseRecoverableSign.s;\n  var sig = new Signature(hexToBigInt(r), hexToBigInt(s));\n  var hashedMsg = typeof message === 'string' ? hashMessage(message) : message;\n  var verificationResult = verify(sig, hashedMsg, publicKey, {\n    strict: false\n  });\n  if (verificationResult || typeof message !== 'string') return verificationResult;\n  var LEGACY_PREFIX = '\\x18Stacks Message Signing:\\n';\n  var legacyHash = sha256(encodeMessage(message, LEGACY_PREFIX));\n  return verify(sig, legacyHash, publicKey, {\n    strict: false\n  });\n}\nexport function verifyMessageSignatureRsv(_ref2) {\n  var signature = _ref2.signature,\n    message = _ref2.message,\n    publicKey = _ref2.publicKey;\n  return verifyMessageSignature({\n    signature: signatureRsvToVrs(signature),\n    message: message,\n    publicKey: publicKey\n  });\n}","map":{"version":3,"names":["hmac","sha256","getPublicKey","getSharedSecret","Point","Signature","signSync","utils","verify","bigIntToBytes","bytesToHex","bytesToUtf8","concatBytes","FailedDecryptionError","hexToBigInt","hexToBytes","parseRecoverableSignatureVrs","signatureRsvToVrs","utf8ToBytes","fromByteArray","toByteArray","createCipher","getPublicKeyFromPrivate","encodeMessage","hashMessage","hashSha256Sync","hashSha512Sync","getAesCbcOutputLength","getBase64OutputLength","hmacSha256Sync","key","h","create","_len","arguments","length","msgs","Array","_key","forEach","msg","update","digest","InvalidPublicKeyReason","aes256CbcEncrypt","_x","_x2","_x3","_aes256CbcEncrypt","apply","_asyncToGenerator","_regeneratorRuntime","mark","_callee","iv","plaintext","cipher","wrap","_callee$","_context","prev","next","sent","encrypt","abrupt","stop","aes256CbcDecrypt","_x4","_x5","_x6","_aes256CbcDecrypt","_callee2","ciphertext","_callee2$","_context2","decrypt","hmacSha256","content","equalsConstTime","a","b","res","i","sharedSecretToKeys","sharedSecret","hashedSecret","encryptionKey","slice","hmacKey","allHexChars","maybe","match","isValidPublicKey","pub","invalidFormat","result","reason_data","reason","InvalidFormat","invalidPoint","IsNotPoint","firstByte","point","fromHex","assertValidity","e","getHexFromBN","bnInput","hexOut","toString","padding","repeat","concat","Error","getBytesFromBN","byteLength","getCipherObjectWrapper","opts","shell","ephemeralPK","mac","cipherText","wasString","cipherTextEncoding","ivLength","ephemeralPKLength","macLength","payloadValuesLength","payloadShell","JSON","stringify","getSignedCipherObjectWrapper","signature","publicKey","signatureLength","publicKeyLength","signedPayloadValuesLength","signedPayloadShell","eciesGetJsonStringLength","_getCipherObjectWrapp","cipherTextLength","contentLength","encodedCipherTextLength","sign","_getSignedCipherObjec","encryptECIES","_x7","_x8","_x9","_x10","_encryptECIES","_callee3","validity","ephemeralPrivateKey","ephemeralPublicKey","sharedKeys","initializationVector","macData","cipherTextString","_callee3$","_context3","randomPrivateKey","randomBytes","decryptECIES","_x11","_x12","_decryptECIES","_callee4","privateKey","cipherObject","ivBytes","cipherTextBytes","actualMac","expectedMac","plainText","_callee4$","_context4","signECDSA","contentBytes","contentHash","verifyECDSA","strict","verifyMessageSignature","_ref","message","_parseRecoverableSign","r","s","sig","hashedMsg","verificationResult","LEGACY_PREFIX","legacyHash","verifyMessageSignatureRsv","_ref2"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\encryption\\src\\ec.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  getPublicKey,\n  getSharedSecret,\n  Point,\n  Signature,\n  signSync,\n  utils,\n  verify,\n} from '@noble/secp256k1';\nimport {\n  bigIntToBytes,\n  bytesToHex,\n  bytesToUtf8,\n  concatBytes,\n  FailedDecryptionError,\n  hexToBigInt,\n  hexToBytes,\n  parseRecoverableSignatureVrs,\n  signatureRsvToVrs,\n  utf8ToBytes,\n} from '@stacks/common';\nimport { fromByteArray, toByteArray } from 'base64-js';\nimport { createCipher } from './aesCipher';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { encodeMessage, hashMessage } from './messageSignature';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signECDSA in this file\n * secp256k1.signSync is used to maintain the semantics of signECDSA while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\n/**\n * Controls how the encrypted data bytes will be encoded as a string in the JSON payload.\n * Options:\n *    `hex` -- the legacy default, file size increase 100% (2x).\n *    `base64` -- file size increased ~33%.\n * @ignore\n */\nexport type CipherTextEncoding = 'hex' | 'base64';\n\n/**\n * @ignore\n */\nexport type CipherObject = {\n  iv: string;\n  ephemeralPK: string;\n  cipherText: string;\n  /** If undefined then hex encoding is used for the `cipherText` string. */\n  cipherTextEncoding?: CipherTextEncoding;\n  mac: string;\n  wasString: boolean;\n};\n\n/**\n * @ignore\n */\nexport type SignedCipherObject = {\n  /** Hex encoded DER signature (up to 144 chars) */\n  signature: string;\n  /** Hex encoded public key (66 char length) */\n  publicKey: string;\n  /** The stringified json of a `CipherObject` */\n  cipherText: string;\n};\n\n/**\n * @ignore\n */\nexport enum InvalidPublicKeyReason {\n  InvalidFormat = 'InvalidFormat',\n  IsNotPoint = 'IsNotPoint',\n}\n\n/**\n * @ignore\n */\nexport async function aes256CbcEncrypt(\n  iv: Uint8Array,\n  key: Uint8Array,\n  plaintext: Uint8Array\n): Promise<Uint8Array> {\n  const cipher = await createCipher();\n  return await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n}\n\n/**\n * @ignore\n */\nasync function aes256CbcDecrypt(\n  iv: Uint8Array,\n  key: Uint8Array,\n  ciphertext: Uint8Array\n): Promise<Uint8Array> {\n  const cipher = await createCipher();\n  return await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n}\n\n/**\n * @ignore\n */\nexport function hmacSha256(key: Uint8Array, content: Uint8Array): Uint8Array {\n  return hmac(sha256, key, content);\n}\n\n/**\n * @ignore\n */\nfunction equalsConstTime(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < a.length; i++) {\n    res |= a[i] ^ b[i];\n  }\n  return res === 0;\n}\n\n/**\n * @ignore\n */\nfunction sharedSecretToKeys(sharedSecret: Uint8Array): {\n  encryptionKey: Uint8Array;\n  hmacKey: Uint8Array;\n} {\n  // generate mac and encryption key from shared secret\n  const hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32),\n  };\n}\n\n/**\n * @ignore\n */\nfunction allHexChars(maybe: string): boolean {\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\n\n/**\n * @ignore\n */\nfunction isValidPublicKey(pub: string): {\n  result: boolean;\n  reason: string | null;\n  reason_data: string | null;\n} {\n  const invalidFormat = {\n    result: false,\n    reason_data: 'Invalid public key format',\n    reason: InvalidPublicKeyReason.InvalidFormat,\n  };\n  const invalidPoint = {\n    result: false,\n    reason_data: 'Public key is not a point',\n    reason: InvalidPublicKeyReason.IsNotPoint,\n  };\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\n\n  const firstByte = pub.slice(0, 2);\n\n  // uncompressed public key\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\n\n  // compressed public key\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\n\n  if (!allHexChars(pub)) return invalidFormat;\n\n  try {\n    // Converts public key to Point\n    const point = Point.fromHex(pub);\n\n    // Verify point on curve is valid if it conforms to equation\n    // Validate the public key\n    // Throws: Point is not on elliptic curve if point is not on curve\n    point.assertValidity();\n\n    // Validation passed\n    return {\n      result: true,\n      reason_data: null,\n      reason: null,\n    };\n  } catch (e) {\n    return invalidPoint;\n  }\n}\n\n/**\n * Hex encodes a 32-byte bigint instance.\n * The result string is zero padded and always 64 characters in length.\n * @ignore\n */\nexport function getHexFromBN(bnInput: bigint): string {\n  const hexOut = bnInput.toString(16);\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n\n/**\n * Converts to zero padded 32 bytes\n * @ignore\n */\nexport function getBytesFromBN(bnInput: bigint): Uint8Array {\n  // todo: remove method?\n  const result = bigIntToBytes(bnInput, 32);\n  if (result.byteLength !== 32) {\n    throw new Error('Failed to generate a 32-byte Uint8Array');\n  }\n  return result;\n}\n\n/**\n * Get details about the JSON envelope size overhead for ciphertext payloads.\n * @ignore\n */\nexport function getCipherObjectWrapper(opts: {\n  wasString: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): {\n  /** The stringified JSON string of an empty `CipherObject`. */\n  payloadShell: string;\n  /** Total string length of all the `CipherObject` values that always have constant lengths. */\n  payloadValuesLength: number;\n} {\n  // Placeholder structure of the ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: CipherObject = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString,\n  };\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n  // Hex encoded 16 bytes.\n  const ivLength = 32;\n  // Hex encoded, compressed EC pubkey of 33 bytes.\n  const ephemeralPKLength = 66;\n  // Hex encoded 32 byte hmac-sha256.\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Get details about the JSON envelope size overhead for signed ciphertext payloads.\n * @param payloadShell - The JSON stringified empty `CipherObject`\n * @ignore\n */\nexport function getSignedCipherObjectWrapper(payloadShell: string): {\n  /** The stringified JSON string of an empty `SignedCipherObject`. */\n  signedPayloadValuesLength: number;\n  /** Total string length of all the `SignedCipherObject` values\n   * that always have constant lengths */\n  signedPayloadShell: string;\n} {\n  // Placeholder structure of the signed ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: SignedCipherObject = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell,\n  };\n  // Hex encoded DER signature, up to 72 byte length.\n  const signatureLength = 144;\n  // Hex encoded 33 byte public key.\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Fast function that determines the final ASCII string byte length of the\n * JSON stringified ECIES encrypted payload.\n * @ignore\n */\nexport function eciesGetJsonStringLength(opts: {\n  contentLength: number;\n  wasString: boolean;\n  sign: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): number {\n  const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);\n\n  // Calculate the AES output length given the input length.\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n\n  // Get the encoded string length of the cipherText.\n  let encodedCipherTextLength: number;\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n\n  if (!opts.sign) {\n    // Add the length of the JSON envelope, ciphertext length, and length of const values.\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    // Get the signed version of the JSON envelope\n    const { signedPayloadShell, signedPayloadValuesLength } =\n      getSignedCipherObjectWrapper(payloadShell);\n    // Add length of the JSON envelope, ciphertext length, and length of the const values.\n    return (\n      signedPayloadShell.length +\n      signedPayloadValuesLength +\n      payloadValuesLength +\n      encodedCipherTextLength\n    );\n  }\n}\n\n// todo: simplify and remove wasstring\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param publicKey - secp256k1 public key hex string\n * @param content - content to encrypt\n * @return Object containing:\n *  iv (initialization vector, hex encoding),\n *  cipherText (cipher text either hex or base64 encoded),\n *  mac (message authentication code, hex encoded),\n *  ephemeral public key (hex encoded),\n *  wasString (boolean indicating with or not to return a Uint8Array or string on decrypt)\n * @ignore\n */\nexport async function encryptECIES(\n  publicKey: string,\n  content: Uint8Array,\n  wasString: boolean,\n  cipherTextEncoding?: CipherTextEncoding\n): Promise<CipherObject> {\n  const validity = isValidPublicKey(publicKey);\n  if (!validity.result) {\n    throw validity;\n  }\n  const ephemeralPrivateKey = utils.randomPrivateKey();\n  const ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);\n  let sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);\n  // Trim the compressed mode prefix byte\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\n  const initializationVector = utils.randomBytes(16);\n\n  const cipherText = await aes256CbcEncrypt(\n    initializationVector,\n    sharedKeys.encryptionKey,\n    content\n  );\n\n  const macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);\n  const mac = hmacSha256(sharedKeys.hmacKey, macData);\n\n  let cipherTextString: string;\n\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n    cipherTextString = bytesToHex(cipherText);\n  } else if (cipherTextEncoding === 'base64') {\n    cipherTextString = fromByteArray(cipherText);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n  }\n\n  const result: CipherObject = {\n    iv: bytesToHex(initializationVector),\n    ephemeralPK: bytesToHex(ephemeralPublicKey),\n    cipherText: cipherTextString,\n    mac: bytesToHex(mac),\n    wasString,\n  };\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n    result.cipherTextEncoding = cipherTextEncoding;\n  }\n  return result;\n}\n\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return bytes or string on decrypt)\n * @return {Uint8Array} plaintext\n * @throws {FailedDecryptionError} if unable to decrypt\n * @ignore\n */\nexport async function decryptECIES(\n  privateKey: string,\n  cipherObject: CipherObject\n): Promise<Uint8Array | string> {\n  if (!cipherObject.ephemeralPK) {\n    throw new FailedDecryptionError(\n      'Unable to get public key from cipher object. ' +\n        'You might be trying to decrypt an unencrypted object.'\n    );\n  }\n  const ephemeralPK = cipherObject.ephemeralPK;\n  let sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);\n  // Trim the compressed mode prefix byte\n  sharedSecret = sharedSecret.slice(1);\n  const sharedKeys = sharedSecretToKeys(sharedSecret);\n  const ivBytes = hexToBytes(cipherObject.iv);\n\n  let cipherTextBytes: Uint8Array;\n\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n    cipherTextBytes = hexToBytes(cipherObject.cipherText);\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\n    cipherTextBytes = toByteArray(cipherObject.cipherText);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n  }\n\n  const macData = concatBytes(ivBytes, hexToBytes(ephemeralPK), cipherTextBytes);\n  const actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n  const expectedMac = hexToBytes(cipherObject.mac);\n\n  if (!equalsConstTime(expectedMac, actualMac)) {\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n  }\n  const plainText = await aes256CbcDecrypt(ivBytes, sharedKeys.encryptionKey, cipherTextBytes);\n\n  if (cipherObject.wasString) {\n    return bytesToUtf8(plainText);\n  }\n  return plainText;\n}\n\n/**\n * Sign content using ECDSA\n *\n * @param {string} privateKey - secp256k1 private key hex string\n * @param {string | Uint8Array} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @ignore\n */\nexport function signECDSA(\n  privateKey: string,\n  content: string | Uint8Array\n): {\n  publicKey: string;\n  signature: string;\n} {\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const publicKey = getPublicKeyFromPrivate(privateKey);\n  const contentHash = hashSha256Sync(contentBytes);\n  const signature = signSync(contentHash, privateKey);\n\n  return {\n    signature: bytesToHex(signature),\n    publicKey,\n  };\n}\n\n/**\n * Verify content using ECDSA\n * @param {String | Uint8Array} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @ignore\n */\nexport function verifyECDSA(\n  content: string | Uint8Array,\n  publicKey: string,\n  signature: string\n): boolean {\n  const contentBytes = typeof content === 'string' ? utf8ToBytes(content) : content;\n  const contentHash = hashSha256Sync(contentBytes);\n  // verify() is strict: true by default. High-s signatures are rejected, which mirrors libsecp behavior\n  // Set verify options to strict: false, to support the legacy stacks implementations\n  // Reference: https://github.com/paulmillr/noble-secp256k1/releases/tag/1.4.0\n  return verify(signature, contentHash, publicKey, { strict: false });\n}\n\ninterface VerifyMessageSignatureArgs {\n  signature: string;\n  message: string | Uint8Array;\n  publicKey: string;\n}\n\n/**\n * Verify message signature (VRS format) with recoverable public key\n * @deprecated The Clarity compatible {@link verifyMessageSignatureRsv} is preferred\n */\nexport function verifyMessageSignature({\n  signature,\n  message,\n  publicKey,\n}: VerifyMessageSignatureArgs): boolean {\n  // todo: remove method and pull body to `verifyMessageSignatureRsv`\n  const { r, s } = parseRecoverableSignatureVrs(signature);\n  const sig = new Signature(hexToBigInt(r), hexToBigInt(s));\n  const hashedMsg = typeof message === 'string' ? hashMessage(message) : message;\n  // verify() is strict: true by default. High-s signatures are rejected, which mirrors libsecp behavior\n  // Set verify options to strict: false, to support the legacy stacks implementations\n  // Reference: https://github.com/paulmillr/noble-secp256k1/releases/tag/1.4.0\n  const verificationResult = verify(sig, hashedMsg, publicKey, { strict: false });\n\n  // Additional Check for Legacy Prefix ++++++++++++++++++++++++++++++++++++++++\n  if (verificationResult || typeof message !== 'string') return verificationResult;\n\n  const LEGACY_PREFIX = '\\x18Stacks Message Signing:\\n';\n  const legacyHash = sha256(encodeMessage(message, LEGACY_PREFIX));\n  return verify(sig, legacyHash, publicKey, { strict: false });\n  // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n}\n\n/**\n * Verifies a Clarity compatible signed message using a public key. The\n * `signature` option needs to be in RSV format.\n */\nexport function verifyMessageSignatureRsv({\n  signature,\n  message,\n  publicKey,\n}: VerifyMessageSignatureArgs): boolean {\n  return verifyMessageSignature({\n    signature: signatureRsvToVrs(signature),\n    message,\n    publicKey,\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}