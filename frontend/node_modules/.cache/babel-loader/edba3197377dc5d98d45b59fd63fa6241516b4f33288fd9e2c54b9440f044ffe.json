{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { AppConfig } from './appConfig';\nimport { InstanceDataStore, LocalStorageStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport { decryptContent as _decryptContent, encryptContent as _encryptContent, isValidPrivateKey } from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport { BLOCKSTACK_DEFAULT_GAIA_HUB_URL, getGlobalObject, InvalidStateError, isLaterVersion, Logger, LoginFailedError, MissingParameterError, nextHour } from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { DEFAULT_PROFILE } from './constants';\nimport { createFetchFn, StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\nexport var UserSession = /*#__PURE__*/function () {\n  function UserSession(options) {\n    _classCallCheck(this, UserSession);\n    var runningInBrowser = true;\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      runningInBrowser = false;\n    }\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n  _createClass(UserSession, [{\n    key: \"makeAuthRequestToken\",\n    value: function makeAuthRequestToken(transitKey, redirectURI, manifestURI, scopes, appDomain) {\n      var expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : nextHour().getTime();\n      var extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n      var appConfig = this.appConfig;\n      if (!appConfig) {\n        throw new InvalidStateError('Missing AppConfig');\n      }\n      transitKey = transitKey || this.generateAndStoreTransitKey();\n      redirectURI = redirectURI || appConfig.redirectURI();\n      manifestURI = manifestURI || appConfig.manifestURI();\n      scopes = scopes || appConfig.scopes;\n      appDomain = appDomain || appConfig.appDomain;\n      return authMessages.makeAuthRequestToken(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);\n    }\n  }, {\n    key: \"generateAndStoreTransitKey\",\n    value: function generateAndStoreTransitKey() {\n      var sessionData = this.store.getSessionData();\n      var transitKey = authMessages.generateTransitKey();\n      sessionData.transitKey = transitKey;\n      this.store.setSessionData(sessionData);\n      return transitKey;\n    }\n  }, {\n    key: \"getAuthResponseToken\",\n    value: function getAuthResponseToken() {\n      var _getGlobalObject, _params$get;\n      var search = (_getGlobalObject = getGlobalObject('location', {\n        throwIfUnavailable: true,\n        usageDesc: 'getAuthResponseToken'\n      })) === null || _getGlobalObject === void 0 ? void 0 : _getGlobalObject.search;\n      var params = new URLSearchParams(search);\n      return (_params$get = params.get('authResponse')) !== null && _params$get !== void 0 ? _params$get : '';\n    }\n  }, {\n    key: \"isSignInPending\",\n    value: function isSignInPending() {\n      try {\n        var isProtocolEcho = protocolEchoReplyDetection();\n        if (isProtocolEcho) {\n          Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n          return true;\n        }\n      } catch (error) {\n        Logger.error(\"Error checking for protocol echo reply isSignInPending: \".concat(error));\n      }\n      return !!this.getAuthResponseToken();\n    }\n  }, {\n    key: \"isUserSignedIn\",\n    value: function isUserSignedIn() {\n      return !!this.store.getSessionData().userData;\n    }\n  }, {\n    key: \"handlePendingSignIn\",\n    value: function () {\n      var _handlePendingSignIn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var authResponseToken,\n          fetchFn,\n          sessionData,\n          transitKey,\n          coreNode,\n          network,\n          tokenPayload,\n          isValid,\n          appPrivateKey,\n          coreSessionToken,\n          hubUrl,\n          gaiaAssociationToken,\n          userData,\n          profileURL,\n          response,\n          responseText,\n          wrappedProfile,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              authResponseToken = _args.length > 0 && _args[0] !== undefined ? _args[0] : this.getAuthResponseToken();\n              fetchFn = _args.length > 1 && _args[1] !== undefined ? _args[1] : createFetchFn();\n              sessionData = this.store.getSessionData();\n              if (!sessionData.userData) {\n                _context.next = 5;\n                break;\n              }\n              throw new LoginFailedError('Existing user session found.');\n            case 5:\n              transitKey = this.store.getSessionData().transitKey;\n              coreNode = this.appConfig && this.appConfig.coreNode;\n              if (!coreNode) {\n                network = new StacksMainnet();\n                coreNode = network.bnsLookupUrl;\n              }\n              tokenPayload = decodeToken(authResponseToken).payload;\n              if (!(typeof tokenPayload === 'string')) {\n                _context.next = 11;\n                break;\n              }\n              throw new Error('Unexpected token payload type of string');\n            case 11:\n              _context.next = 13;\n              return verifyAuthResponse(authResponseToken);\n            case 13:\n              isValid = _context.sent;\n              if (isValid) {\n                _context.next = 16;\n                break;\n              }\n              throw new LoginFailedError('Invalid authentication response.');\n            case 16:\n              appPrivateKey = tokenPayload.private_key;\n              coreSessionToken = tokenPayload.core_token;\n              if (!isLaterVersion(tokenPayload.version, '1.1.0')) {\n                _context.next = 45;\n                break;\n              }\n              if (!(transitKey !== undefined && transitKey != null)) {\n                _context.next = 44;\n                break;\n              }\n              if (!(tokenPayload.private_key !== undefined && tokenPayload.private_key !== null)) {\n                _context.next = 32;\n                break;\n              }\n              _context.prev = 21;\n              _context.next = 24;\n              return authMessages.decryptPrivateKey(transitKey, tokenPayload.private_key);\n            case 24:\n              appPrivateKey = _context.sent;\n              _context.next = 32;\n              break;\n            case 27:\n              _context.prev = 27;\n              _context.t0 = _context[\"catch\"](21);\n              Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n              if (isValidPrivateKey(tokenPayload.private_key)) {\n                _context.next = 32;\n                break;\n              }\n              throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n            case 32:\n              if (!(coreSessionToken !== undefined && coreSessionToken !== null)) {\n                _context.next = 42;\n                break;\n              }\n              _context.prev = 33;\n              _context.next = 36;\n              return authMessages.decryptPrivateKey(transitKey, coreSessionToken);\n            case 36:\n              coreSessionToken = _context.sent;\n              _context.next = 42;\n              break;\n            case 39:\n              _context.prev = 39;\n              _context.t1 = _context[\"catch\"](33);\n              Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n            case 42:\n              _context.next = 45;\n              break;\n            case 44:\n              throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n            case 45:\n              hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n              if (isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n                hubUrl = tokenPayload.hubUrl;\n              }\n              if (isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n                gaiaAssociationToken = tokenPayload.associationToken;\n              }\n              userData = {\n                profile: tokenPayload.profile,\n                email: tokenPayload.email,\n                decentralizedID: tokenPayload.iss,\n                identityAddress: getAddressFromDID(tokenPayload.iss),\n                appPrivateKey: appPrivateKey,\n                coreSessionToken: coreSessionToken,\n                authResponseToken: authResponseToken,\n                hubUrl: hubUrl,\n                appPrivateKeyFromWalletSalt: tokenPayload.appPrivateKeyFromWalletSalt,\n                coreNode: tokenPayload.blockstackAPIUrl,\n                gaiaAssociationToken: gaiaAssociationToken\n              };\n              profileURL = tokenPayload.profile_url;\n              if (!(!userData.profile && profileURL)) {\n                _context.next = 65;\n                break;\n              }\n              _context.next = 53;\n              return fetchFn(profileURL);\n            case 53:\n              response = _context.sent;\n              if (response.ok) {\n                _context.next = 58;\n                break;\n              }\n              userData.profile = Object.assign({}, DEFAULT_PROFILE);\n              _context.next = 63;\n              break;\n            case 58:\n              _context.next = 60;\n              return response.text();\n            case 60:\n              responseText = _context.sent;\n              wrappedProfile = JSON.parse(responseText);\n              userData.profile = extractProfile(wrappedProfile[0].token);\n            case 63:\n              _context.next = 66;\n              break;\n            case 65:\n              userData.profile = tokenPayload.profile;\n            case 66:\n              sessionData.userData = userData;\n              this.store.setSessionData(sessionData);\n              return _context.abrupt(\"return\", userData);\n            case 69:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[21, 27], [33, 39]]);\n      }));\n      function handlePendingSignIn() {\n        return _handlePendingSignIn.apply(this, arguments);\n      }\n      return handlePendingSignIn;\n    }()\n  }, {\n    key: \"loadUserData\",\n    value: function loadUserData() {\n      var userData = this.store.getSessionData().userData;\n      if (!userData) {\n        throw new InvalidStateError('No user data found. Did the user sign in?');\n      }\n      return userData;\n    }\n  }, {\n    key: \"encryptContent\",\n    value: function encryptContent(content, options) {\n      var opts = Object.assign({}, options);\n      if (!opts.privateKey) {\n        opts.privateKey = this.loadUserData().appPrivateKey;\n      }\n      return _encryptContent(content, opts);\n    }\n  }, {\n    key: \"decryptContent\",\n    value: function decryptContent(content, options) {\n      var opts = Object.assign({}, options);\n      if (!opts.privateKey) {\n        opts.privateKey = this.loadUserData().appPrivateKey;\n      }\n      return _decryptContent(content, opts);\n    }\n  }, {\n    key: \"signUserOut\",\n    value: function signUserOut(redirectURL) {\n      this.store.deleteSessionData();\n      if (redirectURL) {\n        if (typeof location !== 'undefined' && location.href) {\n          location.href = redirectURL;\n        }\n      }\n    }\n  }]);\n  return UserSession;\n}();\nUserSession.prototype.makeAuthRequest = UserSession.prototype.makeAuthRequestToken;","map":{"version":3,"names":["AppConfig","InstanceDataStore","LocalStorageStore","decodeToken","verifyAuthResponse","authMessages","decryptContent","encryptContent","isValidPrivateKey","getAddressFromDID","BLOCKSTACK_DEFAULT_GAIA_HUB_URL","getGlobalObject","InvalidStateError","isLaterVersion","Logger","LoginFailedError","MissingParameterError","nextHour","extractProfile","DEFAULT_PROFILE","createFetchFn","StacksMainnet","protocolEchoReplyDetection","UserSession","options","_classCallCheck","runningInBrowser","window","self","appConfig","sessionStore","store","sessionOptions","_createClass","key","value","makeAuthRequestToken","transitKey","redirectURI","manifestURI","scopes","appDomain","expiresAt","arguments","length","undefined","getTime","extraParams","generateAndStoreTransitKey","sessionData","getSessionData","generateTransitKey","setSessionData","getAuthResponseToken","_getGlobalObject","_params$get","search","throwIfUnavailable","usageDesc","params","URLSearchParams","get","isSignInPending","isProtocolEcho","info","error","concat","isUserSignedIn","userData","_handlePendingSignIn","_asyncToGenerator","_regeneratorRuntime","mark","_callee","authResponseToken","fetchFn","coreNode","network","tokenPayload","isValid","appPrivateKey","coreSessionToken","hubUrl","gaiaAssociationToken","profileURL","response","responseText","wrappedProfile","_args","wrap","_callee$","_context","prev","next","bnsLookupUrl","payload","Error","sent","private_key","core_token","version","decryptPrivateKey","t0","warn","t1","associationToken","profile","email","decentralizedID","iss","identityAddress","appPrivateKeyFromWalletSalt","blockstackAPIUrl","profile_url","ok","Object","assign","text","JSON","parse","token","abrupt","stop","handlePendingSignIn","apply","loadUserData","content","opts","privateKey","signUserOut","redirectURL","deleteSessionData","location","href","prototype","makeAuthRequest"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\auth\\src\\userSession.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\n// todo: fix eslint rule, rename UserSession?\nimport { AppConfig } from './appConfig';\nimport { SessionOptions } from './sessionData';\nimport { InstanceDataStore, LocalStorageStore, SessionDataStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport {\n  decryptContent,\n  encryptContent,\n  EncryptContentOptions,\n  isValidPrivateKey,\n} from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport {\n  BLOCKSTACK_DEFAULT_GAIA_HUB_URL,\n  getGlobalObject,\n  InvalidStateError,\n  isLaterVersion,\n  Logger,\n  LoginFailedError,\n  MissingParameterError,\n  nextHour,\n} from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { AuthScope, DEFAULT_PROFILE } from './constants';\n\nimport { UserData } from './userData';\nimport { createFetchFn, FetchFn, StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\n\n/**\n *\n * Represents an instance of a signed in user for a particular app.\n *\n * A signed in user has access to two major pieces of information\n * about the user, the user's private key for that app and the location\n * of the user's gaia storage bucket for the app.\n *\n * A user can be signed in either directly through the interactive\n * sign in process or by directly providing the app private key.\n *\n\n *\n */\nexport class UserSession {\n  appConfig: AppConfig;\n\n  store: SessionDataStore;\n\n  /**\n   * Creates a UserSession object\n   *\n   * @param options\n   */\n  constructor(options?: {\n    appConfig?: AppConfig;\n    sessionStore?: SessionDataStore;\n    sessionOptions?: SessionOptions;\n  }) {\n    let runningInBrowser = true;\n\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      // Logger.debug('UserSession: not running in browser')\n      runningInBrowser = false;\n    }\n\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n\n  /**\n   * Generates an authentication request that can be sent to the Blockstack\n   * browser for the user to approve sign in. This authentication request can\n   * then be used for sign in by passing it to the [[redirectToSignInWithAuthRequest]]\n   * method.\n   *\n   * *Note*: This method should only be used if you want to use a customized authentication\n   * flow. Typically, you'd use [[redirectToSignIn]] which is the default sign in method.\n   *\n   * @param transitKey A HEX encoded transit private key.\n   * @param redirectURI Location to redirect the user to after sign in approval.\n   * @param manifestURI Location of this app's manifest file.\n   * @param scopes The permissions this app is requesting. The default is `store_write`.\n   * @param appDomain The origin of the app.\n   * @param expiresAt The time at which this request is no longer valid.\n   * @param extraParams Any extra parameters to pass to the authenticator. Use this to\n   * pass options that aren't part of the Blockstack authentication specification,\n   * but might be supported by special authenticators.\n   *\n   * @returns {String} the authentication request token\n   */\n  makeAuthRequestToken(\n    transitKey?: string,\n    redirectURI?: string,\n    manifestURI?: string,\n    scopes?: (AuthScope | string)[],\n    appDomain?: string,\n    expiresAt: number = nextHour().getTime(),\n    extraParams: any = {}\n  ): string {\n    const appConfig = this.appConfig;\n    if (!appConfig) {\n      throw new InvalidStateError('Missing AppConfig');\n    }\n    transitKey = transitKey || this.generateAndStoreTransitKey();\n    redirectURI = redirectURI || appConfig.redirectURI();\n    manifestURI = manifestURI || appConfig.manifestURI();\n    scopes = scopes || appConfig.scopes;\n    appDomain = appDomain || appConfig.appDomain;\n    return authMessages.makeAuthRequestToken(\n      transitKey,\n      redirectURI,\n      manifestURI,\n      scopes,\n      appDomain,\n      expiresAt,\n      extraParams\n    );\n  }\n\n  /**\n   * Generates a ECDSA keypair to\n   * use as the ephemeral app transit private key\n   * and store in the session.\n   *\n   * @returns {String} the hex encoded private key\n   *\n   */\n  generateAndStoreTransitKey(): string {\n    const sessionData = this.store.getSessionData();\n    const transitKey = authMessages.generateTransitKey();\n    sessionData.transitKey = transitKey;\n    this.store.setSessionData(sessionData);\n    return transitKey;\n  }\n\n  /**\n   * Retrieve the authentication token from the URL query\n   * @return {String} the authentication token if it exists otherwise `null`\n   */\n  getAuthResponseToken(): string {\n    const search = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'getAuthResponseToken',\n    })?.search;\n\n    const params = new URLSearchParams(search);\n    return params.get('authResponse') ?? '';\n  }\n\n  /**\n   * Check if there is a authentication request that hasn't been handled.\n   *\n   * Also checks for a protocol echo reply (which if detected then the page\n   * will be automatically redirected after this call).\n   *\n   * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n   */\n  isSignInPending() {\n    try {\n      const isProtocolEcho = protocolEchoReplyDetection();\n      if (isProtocolEcho) {\n        Logger.info(\n          'protocolEchoReply detected from isSignInPending call, the page is about to redirect.'\n        );\n        return true;\n      }\n    } catch (error) {\n      Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n\n    return !!this.getAuthResponseToken();\n  }\n\n  /**\n   * Check if a user is currently signed in.\n   *\n   * @returns {Boolean} `true` if the user is signed in, `false` if not.\n   */\n  isUserSignedIn() {\n    return !!this.store.getSessionData().userData;\n  }\n\n  /**\n   * Try to process any pending sign in request by returning a `Promise` that resolves\n   * to the user data object if the sign in succeeds.\n   *\n   * @param {String} authResponseToken - the signed authentication response token\n   * @returns {Promise} that resolves to the user data object if successful and rejects\n   * if handling the sign in request fails or there was no pending sign in request.\n   */\n  async handlePendingSignIn(\n    authResponseToken: string = this.getAuthResponseToken(),\n    fetchFn: FetchFn = createFetchFn()\n  ): Promise<UserData> {\n    const sessionData = this.store.getSessionData();\n\n    if (sessionData.userData) {\n      throw new LoginFailedError('Existing user session found.');\n    }\n\n    const transitKey = this.store.getSessionData().transitKey;\n\n    // let nameLookupURL;\n    let coreNode = this.appConfig && this.appConfig.coreNode;\n    if (!coreNode) {\n      const network = new StacksMainnet();\n      coreNode = network.bnsLookupUrl;\n    }\n\n    const tokenPayload = decodeToken(authResponseToken).payload;\n\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    const isValid = await verifyAuthResponse(authResponseToken);\n    if (!isValid) {\n      throw new LoginFailedError('Invalid authentication response.');\n    }\n\n    // TODO: real version handling\n    let appPrivateKey: string = tokenPayload.private_key as string;\n    let coreSessionToken: string = tokenPayload.core_token as string;\n    if (isLaterVersion(tokenPayload.version as string, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            appPrivateKey = (await authMessages.decryptPrivateKey(\n              transitKey,\n              tokenPayload.private_key as string\n            )) as string;\n          } catch (e) {\n            Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n            if (!isValidPrivateKey(tokenPayload.private_key as string)) {\n              throw new LoginFailedError(\n                'Failed decrypting appPrivateKey. Usually means' +\n                  ' that the transit key has changed during login.'\n              );\n            }\n          }\n        }\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            coreSessionToken = (await authMessages.decryptPrivateKey(\n              transitKey,\n              coreSessionToken\n            )) as string;\n          } catch (e) {\n            Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new LoginFailedError(\n          'Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.'\n        );\n      }\n    }\n    let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken: string;\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.2.0') &&\n      tokenPayload.hubUrl !== null &&\n      tokenPayload.hubUrl !== undefined\n    ) {\n      hubUrl = tokenPayload.hubUrl as string;\n    }\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.3.0') &&\n      tokenPayload.associationToken !== null &&\n      tokenPayload.associationToken !== undefined\n    ) {\n      gaiaAssociationToken = tokenPayload.associationToken as string;\n    }\n\n    const userData: UserData = {\n      profile: tokenPayload.profile,\n      email: tokenPayload.email as string,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      appPrivateKeyFromWalletSalt: tokenPayload.appPrivateKeyFromWalletSalt as string,\n      coreNode: tokenPayload.blockstackAPIUrl as string,\n      // @ts-expect-error\n      gaiaAssociationToken,\n    };\n    const profileURL = tokenPayload.profile_url as string;\n    if (!userData.profile && profileURL) {\n      const response = await fetchFn(profileURL);\n      if (!response.ok) {\n        // return blank profile if we fail to fetch\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = await response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        userData.profile = extractProfile(wrappedProfile[0].token);\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n\n    sessionData.userData = userData;\n    this.store.setSessionData(sessionData);\n\n    return userData;\n  }\n\n  /**\n   * Retrieves the user data object. The user's profile is stored in the key [[Profile]].\n   *\n   * @returns {Object} User data object.\n   */\n  loadUserData() {\n    const userData = this.store.getSessionData().userData;\n    if (!userData) {\n      throw new InvalidStateError('No user data found. Did the user sign in?');\n    }\n    return userData;\n  }\n\n  /**\n   * Encrypts the data provided with the app public key.\n   * @param {string | Uint8Array} content  the data to encrypt\n   * @param options\n   * @param {string} options.publicKey the hex string of the ECDSA public\n   * key to use for encryption. If not provided, will use user's appPrivateKey.\n   *\n   * @returns {string} Stringified ciphertext object\n   */\n  encryptContent(content: string | Uint8Array, options?: EncryptContentOptions): Promise<string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return encryptContent(content, opts);\n  }\n\n  /**\n   * Decrypts data encrypted with `encryptContent` with the\n   * transit private key.\n   * @param {string | Uint8Array} content - encrypted content.\n   * @param options\n   * @param {string} options.privateKey - The hex string of the ECDSA private\n   * key to use for decryption. If not provided, will use user's appPrivateKey.\n   * @returns {string | Uint8Array} decrypted content.\n   */\n  decryptContent(content: string, options?: { privateKey?: string }): Promise<Uint8Array | string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return decryptContent(content, opts);\n  }\n\n  /**\n   * Sign the user out and optionally redirect to given location.\n   * @param  redirectURL\n   * Location to redirect user to after sign out.\n   * Only used in environments with `window` available\n   */\n\n  signUserOut(\n    redirectURL?: string\n    // TODO: this is not used?\n    // caller?: UserSession\n  ) {\n    this.store.deleteSessionData();\n    if (redirectURL) {\n      if (typeof location !== 'undefined' && location.href) {\n        location.href = redirectURL;\n      }\n      // TODO: Invalid left-hand side in assignment expression\n      // // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // // @ts-ignore\n      // getGlobalObject('location', {\n      //   throwIfUnavailable: true,\n      //   usageDesc: 'signUserOut',\n      // })?.href = redirectURL;\n    }\n  }\n}\n\n// Add method aliases for backwards compatibility\nexport interface UserSession {\n  /** @deprecated {@link makeAuthRequest} was renamed to {@link makeAuthRequestToken} */\n  makeAuthRequest(\n    ...args: Parameters<typeof UserSession.prototype.makeAuthRequestToken>\n  ): ReturnType<typeof UserSession.prototype.makeAuthRequestToken>;\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nUserSession.prototype.makeAuthRequest = UserSession.prototype.makeAuthRequestToken;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}