{"ast":null,"code":"import _slicedToArray from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, Point, Signature, signSync, utils } from '@noble/secp256k1';\nimport { bytesToHex, concatArray, hexToBigInt, hexToBytes, intToHex, parseRecoverableSignatureVrs, privateKeyToBytes, PRIVATE_KEY_COMPRESSED_LENGTH, signatureRsvToVrs, signatureVrsToRsv } from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { addressFromVersionHash, addressHashModeToVersion, addressToString, createMessageSignature } from './common';\nimport { AddressHashMode, COMPRESSED_PUBKEY_LENGTH_BYTES, PubKeyEncoding, StacksMessageType, TransactionVersion, UNCOMPRESSED_PUBKEY_LENGTH_BYTES } from './constants';\nimport { hash160, hashP2PKH } from './utils';\nutils.hmacSha256Sync = function (key) {\n  var h = hmac.create(sha256, key);\n  for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    msgs[_key - 1] = arguments[_key];\n  }\n  msgs.forEach(function (msg) {\n    return h.update(msg);\n  });\n  return h.digest();\n};\nexport function getAddressFromPrivateKey(privateKey) {\n  var transactionVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionVersion.Mainnet;\n  var pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\nexport function getAddressFromPublicKey(publicKey) {\n  var transactionVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionVersion.Mainnet;\n  publicKey = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  var addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  var addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));\n  var addrString = addressToString(addr);\n  return addrString;\n}\nexport function createStacksPublicKey(key) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: hexToBytes(key)\n  };\n}\nexport function publicKeyFromSignatureVrs(messageHash, messageSignature) {\n  var pubKeyEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PubKeyEncoding.Compressed;\n  var parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  var signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  var point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);\n  var compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\nexport function publicKeyFromSignatureRsv(messageHash, messageSignature) {\n  var pubKeyEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PubKeyEncoding.Compressed;\n  return publicKeyFromSignatureVrs(messageHash, _objectSpread(_objectSpread({}, messageSignature), {}, {\n    data: signatureRsvToVrs(messageSignature.data)\n  }), pubKeyEncoding);\n}\nexport function publicKeyFromBytes(data) {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: data\n  };\n}\nexport function isCompressed(key) {\n  return !bytesToHex(key.data).startsWith('04');\n}\nexport function publicKeyToString(key) {\n  return bytesToHex(key.data);\n}\nexport function serializePublicKey(key) {\n  return key.data.slice();\n}\nexport function pubKeyfromPrivKey(privateKey) {\n  var privKey = createStacksPrivateKey(privateKey);\n  var publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\nexport function compressPublicKey(publicKey) {\n  var hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  var compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\nexport function deserializePublicKey(bytesReader) {\n  var fieldId = bytesReader.readUInt8();\n  var keyLength = fieldId === 4 ? UNCOMPRESSED_PUBKEY_LENGTH_BYTES : COMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));\n}\nexport function createStacksPrivateKey(key) {\n  var data = privateKeyToBytes(key);\n  var compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return {\n    data: data,\n    compressed: compressed\n  };\n}\nexport function makeRandomPrivKey() {\n  return createStacksPrivateKey(utils.randomPrivateKey());\n}\nexport function signWithKey(privateKey, messageHash) {\n  var _signSync = signSync(messageHash, privateKey.data.slice(0, 32), {\n      canonical: true,\n      recovered: true\n    }),\n    _signSync2 = _slicedToArray(_signSync, 2),\n    rawSignature = _signSync2[0],\n    recoveryId = _signSync2[1];\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n  var recoveryIdHex = intToHex(recoveryId, 1);\n  var recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex();\n  return createMessageSignature(recoverableSignatureString);\n}\nexport function signMessageHashRsv(_ref) {\n  var messageHash = _ref.messageHash,\n    privateKey = _ref.privateKey;\n  var messageSignature = signWithKey(privateKey, messageHash);\n  return _objectSpread(_objectSpread({}, messageSignature), {}, {\n    data: signatureVrsToRsv(messageSignature.data)\n  });\n}\nexport function getPublicKey(privateKey) {\n  return pubKeyfromPrivKey(privateKey.data);\n}\nexport function privateKeyToString(privateKey) {\n  return bytesToHex(privateKey.data);\n}\nexport function publicKeyToAddress(version, publicKey) {\n  return c32address(version, bytesToHex(hash160(publicKey.data)));\n}","map":{"version":3,"names":["hmac","sha256","getPublicKey","nobleGetPublicKey","Point","Signature","signSync","utils","bytesToHex","concatArray","hexToBigInt","hexToBytes","intToHex","parseRecoverableSignatureVrs","privateKeyToBytes","PRIVATE_KEY_COMPRESSED_LENGTH","signatureRsvToVrs","signatureVrsToRsv","c32address","addressFromVersionHash","addressHashModeToVersion","addressToString","createMessageSignature","AddressHashMode","COMPRESSED_PUBKEY_LENGTH_BYTES","PubKeyEncoding","StacksMessageType","TransactionVersion","UNCOMPRESSED_PUBKEY_LENGTH_BYTES","hash160","hashP2PKH","hmacSha256Sync","key","h","create","_len","arguments","length","msgs","Array","_key","forEach","msg","update","digest","getAddressFromPrivateKey","privateKey","transactionVersion","undefined","Mainnet","pubKey","pubKeyfromPrivKey","getAddressFromPublicKey","data","publicKey","addrVer","SerializeP2PKH","addr","addrString","createStacksPublicKey","type","PublicKey","publicKeyFromSignatureVrs","messageHash","messageSignature","pubKeyEncoding","Compressed","parsedSignature","signature","r","s","point","fromSignature","recoveryId","compressed","toHex","publicKeyFromSignatureRsv","_objectSpread","publicKeyFromBytes","isCompressed","startsWith","publicKeyToString","serializePublicKey","slice","privKey","createStacksPrivateKey","compressPublicKey","hex","fromHex","deserializePublicKey","bytesReader","fieldId","readUInt8","keyLength","readBytes","makeRandomPrivKey","randomPrivateKey","signWithKey","_signSync","canonical","recovered","_signSync2","_slicedToArray","rawSignature","Error","recoveryIdHex","recoverableSignatureString","toCompactHex","signMessageHashRsv","_ref","privateKeyToString","publicKeyToAddress","version"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\keys.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  getPublicKey as nobleGetPublicKey,\n  Point,\n  Signature,\n  signSync,\n  utils,\n} from '@noble/secp256k1';\nimport {\n  bytesToHex,\n  concatArray,\n  hexToBigInt,\n  hexToBytes,\n  intToHex,\n  parseRecoverableSignatureVrs,\n  privateKeyToBytes,\n  PRIVATE_KEY_COMPRESSED_LENGTH,\n  signatureRsvToVrs,\n  signatureVrsToRsv,\n} from '@stacks/common';\nimport { c32address } from 'c32check';\nimport { BytesReader } from './bytesReader';\nimport {\n  addressFromVersionHash,\n  addressHashModeToVersion,\n  addressToString,\n  createMessageSignature,\n  MessageSignature,\n} from './common';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n} from './constants';\nimport { hash160, hashP2PKH } from './utils';\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signWithKey in this file\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Uint8Array;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key bytes or hex string */\n  privateKey: string | Uint8Array,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key bytes or hex string */\n  publicKey: string | Uint8Array,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(hexToBytes(publicKey)));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: hexToBytes(key),\n  };\n}\n\nexport function publicKeyFromSignatureVrs(\n  messageHash: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  const parsedSignature = parseRecoverableSignatureVrs(messageSignature.data);\n  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));\n  const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);\n  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;\n  return point.toHex(compressed);\n}\n\nexport function publicKeyFromSignatureRsv(\n  messageHash: string,\n  messageSignature: MessageSignature,\n  pubKeyEncoding = PubKeyEncoding.Compressed\n): string {\n  return publicKeyFromSignatureVrs(\n    messageHash,\n    { ...messageSignature, data: signatureRsvToVrs(messageSignature.data) },\n    pubKeyEncoding\n  );\n}\n\nexport function publicKeyFromBytes(data: Uint8Array): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !bytesToHex(key.data).startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return bytesToHex(key.data);\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Uint8Array {\n  return key.data.slice();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Uint8Array): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const publicKey = nobleGetPublicKey(privKey.data.slice(0, 32), privKey.compressed);\n  return createStacksPublicKey(bytesToHex(publicKey));\n}\n\nexport function compressPublicKey(publicKey: string | Uint8Array): StacksPublicKey {\n  const hex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);\n  const compressed = Point.fromHex(hex).toHex(true);\n  return createStacksPublicKey(compressed);\n}\n\nexport function deserializePublicKey(bytesReader: BytesReader): StacksPublicKey {\n  const fieldId = bytesReader.readUInt8();\n  const keyLength =\n    fieldId === 4 ? UNCOMPRESSED_PUBKEY_LENGTH_BYTES : COMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBytes(concatArray([fieldId, bytesReader.readBytes(keyLength)]));\n}\n\nexport interface StacksPrivateKey {\n  // \"compressed\" private key is a misnomer: https://web.archive.org/web/20220131144208/https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch04.html#comp_priv\n  // it actually means: should public keys be generated as \"compressed\" or \"uncompressed\" from this private key\n  compressed: boolean;\n  data: Uint8Array;\n}\n\nexport function createStacksPrivateKey(key: string | Uint8Array): StacksPrivateKey {\n  const data = privateKeyToBytes(key);\n  const compressed = data.length == PRIVATE_KEY_COMPRESSED_LENGTH;\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(): StacksPrivateKey {\n  return createStacksPrivateKey(utils.randomPrivateKey());\n}\n\n/**\n * @deprecated The Clarity compatible {@link signMessageHashRsv} is preferred, but differs in signature format\n * @returns A recoverable signature (in VRS order)\n */\nexport function signWithKey(privateKey: StacksPrivateKey, messageHash: string): MessageSignature {\n  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.data.slice(0, 32), {\n    canonical: true,\n    recovered: true,\n  });\n  if (recoveryId == null) {\n    throw new Error('No signature recoveryId received');\n  }\n  const recoveryIdHex = intToHex(recoveryId, 1);\n  const recoverableSignatureString = recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex(); // V + RS\n  return createMessageSignature(recoverableSignatureString);\n}\n\n/**\n * Signs a message using a private key. The resulting signature along with the\n * original message can be verified using {@link verifyMessageSignatureRsv}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signMessageHashRsv({\n  messageHash,\n  privateKey,\n}: {\n  messageHash: string;\n  privateKey: StacksPrivateKey;\n}): MessageSignature {\n  const messageSignature = signWithKey(privateKey, messageHash);\n  return { ...messageSignature, data: signatureVrsToRsv(messageSignature.data) };\n}\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return bytesToHex(privateKey.data);\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, bytesToHex(hash160(publicKey.data)));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}