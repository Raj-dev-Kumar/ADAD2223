{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { publicKeyToBtcAddress } from '@stacks/encryption';\nimport { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { fetchAppManifest } from './provider';\nexport function doSignaturesMatchPublicKeys(token) {\n  var payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  var publicKeys = payload.public_keys;\n  if (publicKeys.length === 1) {\n    var publicKey = publicKeys[0];\n    try {\n      var tokenVerifier = new TokenVerifier('ES256k', publicKey);\n      return tokenVerifier.verify(token);\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\nexport function doPublicKeysMatchIssuer(token) {\n  var payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  var publicKeys = payload.public_keys;\n  var addressFromIssuer = getAddressFromDID(payload.iss);\n  if (publicKeys.length === 1) {\n    var addressFromPublicKeys = publicKeyToBtcAddress(publicKeys[0]);\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n  return false;\n}\nexport function isIssuanceDateValid(token) {\n  var payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n    var issuedAt = new Date(payload.iat * 1000);\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isExpirationDateValid(token) {\n  var payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n    var expiresAt = new Date(payload.exp * 1000);\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isManifestUriValid(token) {\n  var payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\nexport function isRedirectUriValid(token) {\n  var payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\nexport function verifyAuthRequest(_x) {\n  return _verifyAuthRequest.apply(this, arguments);\n}\nfunction _verifyAuthRequest() {\n  _verifyAuthRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(token) {\n    var values;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!(decodeToken(token).header.alg === 'none')) {\n            _context.next = 2;\n            break;\n          }\n          throw new Error('Token must be signed in order to be verified');\n        case 2:\n          _context.next = 4;\n          return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]);\n        case 4:\n          values = _context.sent;\n          return _context.abrupt(\"return\", values.every(function (val) {\n            return val;\n          }));\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _verifyAuthRequest.apply(this, arguments);\n}\nexport function verifyAuthRequestAndLoadManifest(_x2) {\n  return _verifyAuthRequestAndLoadManifest.apply(this, arguments);\n}\nfunction _verifyAuthRequestAndLoadManifest() {\n  _verifyAuthRequestAndLoadManifest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(token) {\n    var valid;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return verifyAuthRequest(token);\n        case 2:\n          valid = _context2.sent;\n          if (valid) {\n            _context2.next = 5;\n            break;\n          }\n          throw new Error('Token is an invalid auth request');\n        case 5:\n          return _context2.abrupt(\"return\", fetchAppManifest(token));\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _verifyAuthRequestAndLoadManifest.apply(this, arguments);\n}\nexport function verifyAuthResponse(_x3) {\n  return _verifyAuthResponse.apply(this, arguments);\n}\nfunction _verifyAuthResponse() {\n  _verifyAuthResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(token) {\n    var conditions;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token)]);\n        case 2:\n          conditions = _context3.sent;\n          return _context3.abrupt(\"return\", conditions.every(function (val) {\n            return val;\n          }));\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _verifyAuthResponse.apply(this, arguments);\n}","map":{"version":3,"names":["isSameOriginAbsoluteUrl","publicKeyToBtcAddress","decodeToken","TokenVerifier","getAddressFromDID","fetchAppManifest","doSignaturesMatchPublicKeys","token","payload","Error","publicKeys","public_keys","length","publicKey","tokenVerifier","verify","e","doPublicKeysMatchIssuer","addressFromIssuer","iss","addressFromPublicKeys","isIssuanceDateValid","iat","issuedAt","Date","getTime","isExpirationDateValid","exp","expiresAt","isManifestUriValid","domain_name","manifest_uri","isRedirectUriValid","redirect_uri","verifyAuthRequest","_x","_verifyAuthRequest","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","values","wrap","_callee$","_context","prev","next","header","alg","Promise","all","sent","abrupt","every","val","stop","verifyAuthRequestAndLoadManifest","_x2","_verifyAuthRequestAndLoadManifest","_callee2","valid","_callee2$","_context2","verifyAuthResponse","_x3","_verifyAuthResponse","_callee3","conditions","_callee3$","_context3"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\auth\\src\\verification.ts"],"sourcesContent":["import { isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { publicKeyToBtcAddress } from '@stacks/encryption';\nimport { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { fetchAppManifest } from './provider';\n\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n * @ignore\n */\nexport function doSignaturesMatchPublicKeys(token: string): boolean {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys as string[];\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n    try {\n      const tokenVerifier = new TokenVerifier('ES256k', publicKey);\n      return tokenVerifier.verify(token);\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n * @ignore\n */\nexport function doPublicKeysMatchIssuer(token: string): boolean {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys as string[];\n  const addressFromIssuer = getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = publicKeyToBtcAddress(publicKeys[0]);\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n * @ignore\n */\nexport function isIssuanceDateValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n    const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n * @ignore\n */\nexport function isExpirationDateValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n    const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nexport function isManifestUriValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.manifest_uri as string);\n}\n\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nexport function isRedirectUriValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.redirect_uri as string);\n}\n\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n * @private\n * @ignore\n */\nexport async function verifyAuthRequest(token: string): Promise<boolean> {\n  if (decodeToken(token).header.alg === 'none') {\n    throw new Error('Token must be signed in order to be verified');\n  }\n  const values = await Promise.all([\n    isExpirationDateValid(token),\n    isIssuanceDateValid(token),\n    doSignaturesMatchPublicKeys(token),\n    doPublicKeysMatchIssuer(token),\n    isManifestUriValid(token),\n    isRedirectUriValid(token),\n  ]);\n  return values.every(val => val);\n}\n\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n * @ignore\n */\nexport async function verifyAuthRequestAndLoadManifest(token: string): Promise<any> {\n  const valid = await verifyAuthRequest(token);\n  if (!valid) {\n    throw new Error('Token is an invalid auth request');\n  }\n  return fetchAppManifest(token);\n}\n\n/**\n * Verify the authentication response is valid.\n * @param {String} token the authentication response token\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n * @ignore\n */\nexport async function verifyAuthResponse(token: string): Promise<boolean> {\n  const conditions = await Promise.all([\n    isExpirationDateValid(token),\n    isIssuanceDateValid(token),\n    doSignaturesMatchPublicKeys(token),\n    doPublicKeysMatchIssuer(token),\n  ]);\n  return conditions.every(val => val);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}