{"ast":null,"code":"\"use strict\";\n\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nvar _objectSpread = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _createClass = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;\nvar nodeCrypto = require(\"crypto\");\nvar _0n = BigInt(0);\nvar _1n = BigInt(1);\nvar _2n = BigInt(2);\nvar _3n = BigInt(3);\nvar _8n = BigInt(8);\nvar CURVE = Object.freeze({\n  a: _0n,\n  b: BigInt(7),\n  P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: _1n,\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')\n});\nexports.CURVE = CURVE;\nvar divNearest = function divNearest(a, b) {\n  return (a + b / _2n) / b;\n};\nvar endo = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n  splitScalar: function splitScalar(k) {\n    var n = CURVE.n;\n    var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    var b2 = a1;\n    var POW_2_128 = BigInt('0x100000000000000000000000000000000');\n    var c1 = divNearest(b2 * k, n);\n    var c2 = divNearest(-b1 * k, n);\n    var k1 = mod(k - c1 * a1 - c2 * a2, n);\n    var k2 = mod(-c1 * b1 - c2 * b2, n);\n    var k1neg = k1 > POW_2_128;\n    var k2neg = k2 > POW_2_128;\n    if (k1neg) k1 = n - k1;\n    if (k2neg) k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n      throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return {\n      k1neg: k1neg,\n      k1: k1,\n      k2neg: k2neg,\n      k2: k2\n    };\n  }\n};\nvar fieldLen = 32;\nvar groupLen = 32;\nvar hashLen = 32;\nvar compressedLen = fieldLen + 1;\nvar uncompressedLen = 2 * fieldLen + 1;\nfunction weierstrass(x) {\n  var a = CURVE.a,\n    b = CURVE.b;\n  var x2 = mod(x * x);\n  var x3 = mod(x2 * x);\n  return mod(x3 + a * x + b);\n}\nvar USE_ENDOMORPHISM = CURVE.a === _0n;\nvar ShaError = /*#__PURE__*/function (_Error) {\n  _inherits(ShaError, _Error);\n  var _super = _createSuper(ShaError);\n  function ShaError(message) {\n    _classCallCheck(this, ShaError);\n    return _super.call(this, message);\n  }\n  return _createClass(ShaError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nfunction assertJacPoint(other) {\n  if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n}\nvar JacobianPoint = /*#__PURE__*/function () {\n  function JacobianPoint(x, y, z) {\n    _classCallCheck(this, JacobianPoint);\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  _createClass(JacobianPoint, [{\n    key: \"equals\",\n    value: function equals(other) {\n      assertJacPoint(other);\n      var X1 = this.x,\n        Y1 = this.y,\n        Z1 = this.z;\n      var X2 = other.x,\n        Y2 = other.y,\n        Z2 = other.z;\n      var Z1Z1 = mod(Z1 * Z1);\n      var Z2Z2 = mod(Z2 * Z2);\n      var U1 = mod(X1 * Z2Z2);\n      var U2 = mod(X2 * Z1Z1);\n      var S1 = mod(mod(Y1 * Z2) * Z2Z2);\n      var S2 = mod(mod(Y2 * Z1) * Z1Z1);\n      return U1 === U2 && S1 === S2;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      var X1 = this.x,\n        Y1 = this.y,\n        Z1 = this.z;\n      var A = mod(X1 * X1);\n      var B = mod(Y1 * Y1);\n      var C = mod(B * B);\n      var x1b = X1 + B;\n      var D = mod(_2n * (mod(x1b * x1b) - A - C));\n      var E = mod(_3n * A);\n      var F = mod(E * E);\n      var X3 = mod(F - _2n * D);\n      var Y3 = mod(E * (D - X3) - _8n * C);\n      var Z3 = mod(_2n * Y1 * Z1);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      assertJacPoint(other);\n      var X1 = this.x,\n        Y1 = this.y,\n        Z1 = this.z;\n      var X2 = other.x,\n        Y2 = other.y,\n        Z2 = other.z;\n      if (X2 === _0n || Y2 === _0n) return this;\n      if (X1 === _0n || Y1 === _0n) return other;\n      var Z1Z1 = mod(Z1 * Z1);\n      var Z2Z2 = mod(Z2 * Z2);\n      var U1 = mod(X1 * Z2Z2);\n      var U2 = mod(X2 * Z1Z1);\n      var S1 = mod(mod(Y1 * Z2) * Z2Z2);\n      var S2 = mod(mod(Y2 * Z1) * Z1Z1);\n      var H = mod(U2 - U1);\n      var r = mod(S2 - S1);\n      if (H === _0n) {\n        if (r === _0n) {\n          return this.double();\n        } else {\n          return JacobianPoint.ZERO;\n        }\n      }\n      var HH = mod(H * H);\n      var HHH = mod(H * HH);\n      var V = mod(U1 * HH);\n      var X3 = mod(r * r - HHH - _2n * V);\n      var Y3 = mod(r * (V - X3) - S1 * HHH);\n      var Z3 = mod(Z1 * Z2 * H);\n      return new JacobianPoint(X3, Y3, Z3);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiplyUnsafe\",\n    value: function multiplyUnsafe(scalar) {\n      var P0 = JacobianPoint.ZERO;\n      if (typeof scalar === 'bigint' && scalar === _0n) return P0;\n      var n = normalizeScalar(scalar);\n      if (n === _1n) return this;\n      if (!USE_ENDOMORPHISM) {\n        var p = P0;\n        var _d = this;\n        while (n > _0n) {\n          if (n & _1n) p = p.add(_d);\n          _d = _d.double();\n          n >>= _1n;\n        }\n        return p;\n      }\n      var _endo$splitScalar = endo.splitScalar(n),\n        k1neg = _endo$splitScalar.k1neg,\n        k1 = _endo$splitScalar.k1,\n        k2neg = _endo$splitScalar.k2neg,\n        k2 = _endo$splitScalar.k2;\n      var k1p = P0;\n      var k2p = P0;\n      var d = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n      return k1p.add(k2p);\n    }\n  }, {\n    key: \"precomputeWindow\",\n    value: function precomputeWindow(W) {\n      var windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n      var points = [];\n      var p = this;\n      var base = p;\n      for (var window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        for (var i = 1; i < Math.pow(2, W - 1); i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    }\n  }, {\n    key: \"wNAF\",\n    value: function wNAF(n, affinePoint) {\n      if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n      var W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n      if (256 % W) {\n        throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n      }\n      var precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n      if (!precomputes) {\n        precomputes = this.precomputeWindow(W);\n        if (affinePoint && W !== 1) {\n          precomputes = JacobianPoint.normalizeZ(precomputes);\n          pointPrecomputes.set(affinePoint, precomputes);\n        }\n      }\n      var p = JacobianPoint.ZERO;\n      var f = JacobianPoint.BASE;\n      var windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n      var windowSize = Math.pow(2, W - 1);\n      var mask = BigInt(Math.pow(2, W) - 1);\n      var maxNumber = Math.pow(2, W);\n      var shiftBy = BigInt(W);\n      for (var window = 0; window < windows; window++) {\n        var offset = window * windowSize;\n        var wbits = Number(n & mask);\n        n >>= shiftBy;\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        var offset1 = offset;\n        var offset2 = offset + Math.abs(wbits) - 1;\n        var cond1 = window % 2 !== 0;\n        var cond2 = wbits < 0;\n        if (wbits === 0) {\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      return {\n        p: p,\n        f: f\n      };\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar, affinePoint) {\n      var n = normalizeScalar(scalar);\n      var point;\n      var fake;\n      if (USE_ENDOMORPHISM) {\n        var _endo$splitScalar2 = endo.splitScalar(n),\n          k1neg = _endo$splitScalar2.k1neg,\n          k1 = _endo$splitScalar2.k1,\n          k2neg = _endo$splitScalar2.k2neg,\n          k2 = _endo$splitScalar2.k2;\n        var _this$wNAF = this.wNAF(k1, affinePoint),\n          k1p = _this$wNAF.p,\n          f1p = _this$wNAF.f;\n        var _this$wNAF2 = this.wNAF(k2, affinePoint),\n          k2p = _this$wNAF2.p,\n          f2p = _this$wNAF2.f;\n        k1p = constTimeNegate(k1neg, k1p);\n        k2p = constTimeNegate(k2neg, k2p);\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        var _this$wNAF3 = this.wNAF(n, affinePoint),\n          p = _this$wNAF3.p,\n          f = _this$wNAF3.f;\n        point = p;\n        fake = f;\n      }\n      return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n  }, {\n    key: \"toAffine\",\n    value: function toAffine(invZ) {\n      var x = this.x,\n        y = this.y,\n        z = this.z;\n      var is0 = this.equals(JacobianPoint.ZERO);\n      if (invZ == null) invZ = is0 ? _8n : invert(z);\n      var iz1 = invZ;\n      var iz2 = mod(iz1 * iz1);\n      var iz3 = mod(iz2 * iz1);\n      var ax = mod(x * iz2);\n      var ay = mod(y * iz3);\n      var zz = mod(z * iz1);\n      if (is0) return Point.ZERO;\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return new Point(ax, ay);\n    }\n  }], [{\n    key: \"fromAffine\",\n    value: function fromAffine(p) {\n      if (!(p instanceof Point)) {\n        throw new TypeError('JacobianPoint#fromAffine: expected Point');\n      }\n      if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;\n      return new JacobianPoint(p.x, p.y, _1n);\n    }\n  }, {\n    key: \"toAffineBatch\",\n    value: function toAffineBatch(points) {\n      var toInv = invertBatch(points.map(function (p) {\n        return p.z;\n      }));\n      return points.map(function (p, i) {\n        return p.toAffine(toInv[i]);\n      });\n    }\n  }, {\n    key: \"normalizeZ\",\n    value: function normalizeZ(points) {\n      return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n  }]);\n  return JacobianPoint;\n}();\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n  var neg = item.negate();\n  return condition ? neg : item;\n}\nvar pointPrecomputes = new WeakMap();\nvar Point = /*#__PURE__*/function () {\n  function Point(x, y) {\n    _classCallCheck(this, Point);\n    this.x = x;\n    this.y = y;\n  }\n  _createClass(Point, [{\n    key: \"_setWindowSize\",\n    value: function _setWindowSize(windowSize) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n  }, {\n    key: \"hasEvenY\",\n    value: function hasEvenY() {\n      return this.y % _2n === _0n;\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return hexToBytes(this.toHex(isCompressed));\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var x = numTo32bStr(this.x);\n      if (isCompressed) {\n        var prefix = this.hasEvenY() ? '02' : '03';\n        return \"\".concat(prefix).concat(x);\n      } else {\n        return \"04\".concat(x).concat(numTo32bStr(this.y));\n      }\n    }\n  }, {\n    key: \"toHexX\",\n    value: function toHexX() {\n      return this.toHex(true).slice(2);\n    }\n  }, {\n    key: \"toRawX\",\n    value: function toRawX() {\n      return this.toRawBytes(true).slice(1);\n    }\n  }, {\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var msg = 'Point is not on elliptic curve';\n      var x = this.x,\n        y = this.y;\n      if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n      var left = mod(y * y);\n      var right = weierstrass(x);\n      if (mod(left - right) !== _0n) throw new Error(msg);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.x === other.x && this.y === other.y;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return new Point(this.x, mod(-this.y));\n    }\n  }, {\n    key: \"double\",\n    value: function double() {\n      return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(other) {\n      return this.add(other.negate());\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(scalar) {\n      return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n  }, {\n    key: \"multiplyAndAddUnsafe\",\n    value: function multiplyAndAddUnsafe(Q, a, b) {\n      var P = JacobianPoint.fromAffine(this);\n      var aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n      var bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n      var sum = aP.add(bQ);\n      return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n  }], [{\n    key: \"fromCompressedHex\",\n    value: function fromCompressedHex(bytes) {\n      var isShort = bytes.length === 32;\n      var x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n      if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n      var y2 = weierstrass(x);\n      var y = sqrtMod(y2);\n      var isYOdd = (y & _1n) === _1n;\n      if (isShort) {\n        if (isYOdd) y = mod(-y);\n      } else {\n        var isFirstByteOdd = (bytes[0] & 1) === 1;\n        if (isFirstByteOdd !== isYOdd) y = mod(-y);\n      }\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromUncompressedHex\",\n    value: function fromUncompressedHex(bytes) {\n      var x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n      var y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n      var point = new Point(x, y);\n      point.assertValidity();\n      return point;\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n      var len = bytes.length;\n      var header = bytes[0];\n      if (len === fieldLen) return this.fromCompressedHex(bytes);\n      if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n        return this.fromCompressedHex(bytes);\n      }\n      if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);\n      throw new Error(\"Point.fromHex: received invalid point. Expected 32-\".concat(compressedLen, \" compressed bytes or \").concat(uncompressedLen, \" uncompressed bytes, not \").concat(len));\n    }\n  }, {\n    key: \"fromPrivateKey\",\n    value: function fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n  }, {\n    key: \"fromSignature\",\n    value: function fromSignature(msgHash, signature, recovery) {\n      var _normalizeSignature = normalizeSignature(signature),\n        r = _normalizeSignature.r,\n        s = _normalizeSignature.s;\n      if (![0, 1, 2, 3].includes(recovery)) throw new Error('Cannot recover: invalid recovery bit');\n      var h = truncateHash(ensureBytes(msgHash));\n      var n = CURVE.n;\n      var radj = recovery === 2 || recovery === 3 ? r + n : r;\n      var rinv = invert(radj, n);\n      var u1 = mod(-h * rinv, n);\n      var u2 = mod(s * rinv, n);\n      var prefix = recovery & 1 ? '03' : '02';\n      var R = Point.fromHex(prefix + numTo32bStr(radj));\n      var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n      if (!Q) throw new Error('Cannot recover signature: point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n  }]);\n  return Point;\n}();\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n  if (data.length < 2 || data[0] !== 0x02) {\n    throw new Error(\"Invalid signature integer tag: \".concat(bytesToHex(data)));\n  }\n  var len = data[1];\n  var res = data.subarray(2, len + 2);\n  if (!len || res.length !== len) {\n    throw new Error(\"Invalid signature integer: wrong length\");\n  }\n  if (res[0] === 0x00 && res[1] <= 0x7f) {\n    throw new Error('Invalid signature integer: trailing length');\n  }\n  return {\n    data: bytesToNumber(res),\n    left: data.subarray(len + 2)\n  };\n}\nfunction parseDERSignature(data) {\n  if (data.length < 2 || data[0] != 0x30) {\n    throw new Error(\"Invalid signature tag: \".concat(bytesToHex(data)));\n  }\n  if (data[1] !== data.length - 2) {\n    throw new Error('Invalid signature: incorrect length');\n  }\n  var _parseDERInt = parseDERInt(data.subarray(2)),\n    r = _parseDERInt.data,\n    sBytes = _parseDERInt.left;\n  var _parseDERInt2 = parseDERInt(sBytes),\n    s = _parseDERInt2.data,\n    rBytesLeft = _parseDERInt2.left;\n  if (rBytesLeft.length) {\n    throw new Error(\"Invalid signature: left bytes after parsing: \".concat(bytesToHex(rBytesLeft)));\n  }\n  return {\n    r: r,\n    s: s\n  };\n}\nvar Signature = /*#__PURE__*/function () {\n  function Signature(r, s) {\n    _classCallCheck(this, Signature);\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  _createClass(Signature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n        s = this.s;\n      if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n      if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n  }, {\n    key: \"hasHighS\",\n    value: function hasHighS() {\n      var HALF = CURVE.n >> _1n;\n      return this.s > HALF;\n    }\n  }, {\n    key: \"normalizeS\",\n    value: function normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n  }, {\n    key: \"toDERRawBytes\",\n    value: function toDERRawBytes() {\n      return hexToBytes(this.toDERHex());\n    }\n  }, {\n    key: \"toDERHex\",\n    value: function toDERHex() {\n      var sHex = sliceDER(numberToHexUnpadded(this.s));\n      var rHex = sliceDER(numberToHexUnpadded(this.r));\n      var sHexL = sHex.length / 2;\n      var rHexL = rHex.length / 2;\n      var sLen = numberToHexUnpadded(sHexL);\n      var rLen = numberToHexUnpadded(rHexL);\n      var length = numberToHexUnpadded(rHexL + sHexL + 4);\n      return \"30\".concat(length, \"02\").concat(rLen).concat(rHex, \"02\").concat(sLen).concat(sHex);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return this.toDERRawBytes();\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return this.toDERHex();\n    }\n  }, {\n    key: \"toCompactRawBytes\",\n    value: function toCompactRawBytes() {\n      return hexToBytes(this.toCompactHex());\n    }\n  }, {\n    key: \"toCompactHex\",\n    value: function toCompactHex() {\n      return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n  }], [{\n    key: \"fromCompact\",\n    value: function fromCompact(hex) {\n      var arr = hex instanceof Uint8Array;\n      var name = 'Signature.fromCompact';\n      if (typeof hex !== 'string' && !arr) throw new TypeError(\"\".concat(name, \": Expected string or Uint8Array\"));\n      var str = arr ? bytesToHex(hex) : hex;\n      if (str.length !== 128) throw new Error(\"\".concat(name, \": Expected 64-byte hex\"));\n      return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n  }, {\n    key: \"fromDER\",\n    value: function fromDER(hex) {\n      var arr = hex instanceof Uint8Array;\n      if (typeof hex !== 'string' && !arr) throw new TypeError(\"Signature.fromDER: Expected string or Uint8Array\");\n      var _parseDERSignature = parseDERSignature(arr ? hex : hexToBytes(hex)),\n        r = _parseDERSignature.r,\n        s = _parseDERSignature.s;\n      return new Signature(r, s);\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      return this.fromDER(hex);\n    }\n  }]);\n  return Signature;\n}();\nexports.Signature = Signature;\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n  if (!arrays.every(function (b) {\n    return b instanceof Uint8Array;\n  })) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  var length = arrays.reduce(function (a, arr) {\n    return a + arr.length;\n  }, 0);\n  var result = new Uint8Array(length);\n  for (var i = 0, pad = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nvar hexes = Array.from({\n  length: 256\n}, function (v, i) {\n  return i.toString(16).padStart(2, '0');\n});\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  var hex = '';\n  for (var i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\nvar POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n  if (typeof num !== 'bigint') throw new Error('Expected bigint');\n  if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number 0 <= n < 2^256');\n  return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n  var b = hexToBytes(numTo32bStr(num));\n  if (b.length !== 32) throw new Error('Error: expected 32 bytes');\n  return b;\n}\nfunction numberToHexUnpadded(num) {\n  var hex = num.toString(16);\n  return hex.length & 1 ? \"0\".concat(hex) : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n  return BigInt(\"0x\".concat(hex));\n}\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n  var array = new Uint8Array(hex.length / 2);\n  for (var i = 0; i < array.length; i++) {\n    var j = i * 2;\n    var hexByte = hex.slice(j, j + 2);\n    var byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;\n  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var result = a % b;\n  return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n  var P = CURVE.P;\n  var res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n  return res;\n}\nfunction sqrtMod(x) {\n  var P = CURVE.P;\n  var _6n = BigInt(6);\n  var _11n = BigInt(11);\n  var _22n = BigInt(22);\n  var _23n = BigInt(23);\n  var _44n = BigInt(44);\n  var _88n = BigInt(88);\n  var b2 = x * x * x % P;\n  var b3 = b2 * b2 * x % P;\n  var b6 = pow2(b3, _3n) * b3 % P;\n  var b9 = pow2(b6, _3n) * b3 % P;\n  var b11 = pow2(b9, _2n) * b2 % P;\n  var b22 = pow2(b11, _11n) * b11 % P;\n  var b44 = pow2(b22, _22n) * b22 % P;\n  var b88 = pow2(b44, _44n) * b44 % P;\n  var b176 = pow2(b88, _88n) * b88 % P;\n  var b220 = pow2(b176, _44n) * b44 % P;\n  var b223 = pow2(b220, _3n) * b3 % P;\n  var t1 = pow2(b223, _23n) * b22 % P;\n  var t2 = pow2(t1, _6n) * b2 % P;\n  var rt = pow2(t2, _2n);\n  var xc = rt * rt % P;\n  if (xc !== x) throw new Error('Cannot find square root');\n  return rt;\n}\nfunction invert(number) {\n  var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(\"invert: expected positive integers, got n=\".concat(number, \" mod=\").concat(modulo));\n  }\n  var a = mod(number, modulo);\n  var b = modulo;\n  var x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    var q = b / a;\n    var r = b % a;\n    var m = x - u * q;\n    var n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  var gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\nfunction invertBatch(nums) {\n  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  var scratch = new Array(nums.length);\n  var lastMultiplied = nums.reduce(function (acc, num, i) {\n    if (num === _0n) return acc;\n    scratch[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  var inverted = invert(lastMultiplied, p);\n  nums.reduceRight(function (acc, num, i) {\n    if (num === _0n) return acc;\n    scratch[i] = mod(acc * scratch[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return scratch;\n}\nfunction bits2int_2(bytes) {\n  var delta = bytes.length * 8 - groupLen * 8;\n  var num = bytesToNumber(bytes);\n  return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash) {\n  var truncateOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var h = bits2int_2(hash);\n  if (truncateOnly) return h;\n  var n = CURVE.n;\n  return h >= n ? h - n : h;\n}\nvar _sha256Sync;\nvar _hmacSha256Sync;\nvar HmacDrbg = /*#__PURE__*/function () {\n  function HmacDrbg(hashLen, qByteLen) {\n    _classCallCheck(this, HmacDrbg);\n    this.hashLen = hashLen;\n    this.qByteLen = qByteLen;\n    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n    this.v = new Uint8Array(hashLen).fill(1);\n    this.k = new Uint8Array(hashLen).fill(0);\n    this.counter = 0;\n  }\n  _createClass(HmacDrbg, [{\n    key: \"hmac\",\n    value: function hmac() {\n      var _exports$utils;\n      for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        values[_key2] = arguments[_key2];\n      }\n      return (_exports$utils = exports.utils).hmacSha256.apply(_exports$utils, [this.k].concat(values));\n    }\n  }, {\n    key: \"hmacSync\",\n    value: function hmacSync() {\n      for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        values[_key3] = arguments[_key3];\n      }\n      return _hmacSha256Sync.apply(void 0, [this.k].concat(values));\n    }\n  }, {\n    key: \"checkSync\",\n    value: function checkSync() {\n      if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');\n    }\n  }, {\n    key: \"incr\",\n    value: function incr() {\n      if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');\n      this.counter += 1;\n    }\n  }, {\n    key: \"reseed\",\n    value: function () {\n      var _reseed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var seed,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              seed = _args.length > 0 && _args[0] !== undefined ? _args[0] : new Uint8Array();\n              _context.next = 3;\n              return this.hmac(this.v, Uint8Array.from([0x00]), seed);\n            case 3:\n              this.k = _context.sent;\n              _context.next = 6;\n              return this.hmac(this.v);\n            case 6:\n              this.v = _context.sent;\n              if (!(seed.length === 0)) {\n                _context.next = 9;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 9:\n              _context.next = 11;\n              return this.hmac(this.v, Uint8Array.from([0x01]), seed);\n            case 11:\n              this.k = _context.sent;\n              _context.next = 14;\n              return this.hmac(this.v);\n            case 14:\n              this.v = _context.sent;\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function reseed() {\n        return _reseed.apply(this, arguments);\n      }\n      return reseed;\n    }()\n  }, {\n    key: \"reseedSync\",\n    value: function reseedSync() {\n      var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();\n      this.checkSync();\n      this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n      this.v = this.hmacSync(this.v);\n      if (seed.length === 0) return;\n      this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n      this.v = this.hmacSync(this.v);\n    }\n  }, {\n    key: \"generate\",\n    value: function () {\n      var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var len, out, sl;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.incr();\n              len = 0;\n              out = [];\n            case 3:\n              if (!(len < this.qByteLen)) {\n                _context2.next = 12;\n                break;\n              }\n              _context2.next = 6;\n              return this.hmac(this.v);\n            case 6:\n              this.v = _context2.sent;\n              sl = this.v.slice();\n              out.push(sl);\n              len += this.v.length;\n              _context2.next = 3;\n              break;\n            case 12:\n              return _context2.abrupt(\"return\", concatBytes.apply(void 0, out));\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function generate() {\n        return _generate.apply(this, arguments);\n      }\n      return generate;\n    }()\n  }, {\n    key: \"generateSync\",\n    value: function generateSync() {\n      this.checkSync();\n      this.incr();\n      var len = 0;\n      var out = [];\n      while (len < this.qByteLen) {\n        this.v = this.hmacSync(this.v);\n        var sl = this.v.slice();\n        out.push(sl);\n        len += this.v.length;\n      }\n      return concatBytes.apply(void 0, out);\n    }\n  }]);\n  return HmacDrbg;\n}();\nfunction isWithinCurveOrder(num) {\n  return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n  return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d) {\n  var lowS = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var n = CURVE.n;\n  var k = truncateHash(kBytes, true);\n  if (!isWithinCurveOrder(k)) return;\n  var kinv = invert(k, n);\n  var q = Point.BASE.multiply(k);\n  var r = mod(q.x, n);\n  if (r === _0n) return;\n  var s = mod(kinv * mod(m + d * r, n), n);\n  if (s === _0n) return;\n  var sig = new Signature(r, s);\n  var recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n  if (lowS && sig.hasHighS()) {\n    sig = sig.normalizeS();\n    recovery ^= 1;\n  }\n  return {\n    sig: sig,\n    recovery: recovery\n  };\n}\nfunction normalizePrivateKey(key) {\n  var num;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 2 * groupLen) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (key instanceof Uint8Array) {\n    if (key.length !== groupLen) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  }\n  try {\n    return Signature.fromDER(signature);\n  } catch (error) {\n    return Signature.fromCompact(signature);\n  }\n}\nfunction getPublicKey(privateKey) {\n  var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery) {\n  var isCompressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isProbPub(item) {\n  var arr = item instanceof Uint8Array;\n  var str = typeof item === 'string';\n  var len = (arr || str) && item.length;\n  if (arr) return len === compressedLen || len === uncompressedLen;\n  if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;\n  if (item instanceof Point) return true;\n  return false;\n}\nfunction getSharedSecret(privateA, publicB) {\n  var isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (isProbPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isProbPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  var b = normalizePublicKey(publicB);\n  b.assertValidity();\n  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction bits2int(bytes) {\n  var slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n  return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n  var z1 = bits2int(bytes);\n  var z2 = mod(z1, CURVE.n);\n  return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n  return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n  if (msgHash == null) throw new Error(\"sign: expected valid message hash, not \\\"\".concat(msgHash, \"\\\"\"));\n  var h1 = ensureBytes(msgHash);\n  var d = normalizePrivateKey(privateKey);\n  var seedArgs = [int2octets(d), bits2octets(h1)];\n  if (extraEntropy != null) {\n    if (extraEntropy === true) extraEntropy = exports.utils.randomBytes(fieldLen);\n    var e = ensureBytes(extraEntropy);\n    if (e.length !== fieldLen) throw new Error(\"sign: Expected \".concat(fieldLen, \" bytes of extra data\"));\n    seedArgs.push(e);\n  }\n  var seed = concatBytes.apply(void 0, seedArgs);\n  var m = bits2int(h1);\n  return {\n    seed: seed,\n    m: m,\n    d: d\n  };\n}\nfunction finalizeSig(recSig, opts) {\n  var sig = recSig.sig,\n    recovery = recSig.recovery;\n  var _Object$assign = Object.assign({\n      canonical: true,\n      der: true\n    }, opts),\n    der = _Object$assign.der,\n    recovered = _Object$assign.recovered;\n  var hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n  return recovered ? [hashed, recovery] : hashed;\n}\nfunction sign(_x, _x2) {\n  return _sign.apply(this, arguments);\n}\nfunction _sign() {\n  _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(msgHash, privKey) {\n    var opts,\n      _initSigArgs2,\n      seed,\n      m,\n      d,\n      drbg,\n      sig,\n      _args7 = arguments;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) switch (_context7.prev = _context7.next) {\n        case 0:\n          opts = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};\n          _initSigArgs2 = initSigArgs(msgHash, privKey, opts.extraEntropy), seed = _initSigArgs2.seed, m = _initSigArgs2.m, d = _initSigArgs2.d;\n          drbg = new HmacDrbg(hashLen, groupLen);\n          _context7.next = 5;\n          return drbg.reseed(seed);\n        case 5:\n          _context7.t0 = kmdToSig;\n          _context7.next = 8;\n          return drbg.generate();\n        case 8:\n          _context7.t1 = _context7.sent;\n          _context7.t2 = m;\n          _context7.t3 = d;\n          _context7.t4 = opts.canonical;\n          if (sig = (0, _context7.t0)(_context7.t1, _context7.t2, _context7.t3, _context7.t4)) {\n            _context7.next = 17;\n            break;\n          }\n          _context7.next = 15;\n          return drbg.reseed();\n        case 15:\n          _context7.next = 5;\n          break;\n        case 17:\n          return _context7.abrupt(\"return\", finalizeSig(sig, opts));\n        case 18:\n        case \"end\":\n          return _context7.stop();\n      }\n    }, _callee7);\n  }));\n  return _sign.apply(this, arguments);\n}\nexports.sign = sign;\nfunction signSync(msgHash, privKey) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _initSigArgs = initSigArgs(msgHash, privKey, opts.extraEntropy),\n    seed = _initSigArgs.seed,\n    m = _initSigArgs.m,\n    d = _initSigArgs.d;\n  var drbg = new HmacDrbg(hashLen, groupLen);\n  drbg.reseedSync(seed);\n  var sig;\n  while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical))) drbg.reseedSync();\n  return finalizeSig(sig, opts);\n}\nexports.signSync = signSync;\nvar vopts = {\n  strict: true\n};\nfunction verify(signature, msgHash, publicKey) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : vopts;\n  var sig;\n  try {\n    sig = normalizeSignature(signature);\n    msgHash = ensureBytes(msgHash);\n  } catch (error) {\n    return false;\n  }\n  var _sig = sig,\n    r = _sig.r,\n    s = _sig.s;\n  if (opts.strict && sig.hasHighS()) return false;\n  var h = truncateHash(msgHash);\n  var P;\n  try {\n    P = normalizePublicKey(publicKey);\n  } catch (error) {\n    return false;\n  }\n  var n = CURVE.n;\n  var sinv = invert(s, n);\n  var u1 = mod(h * sinv, n);\n  var u2 = mod(r * sinv, n);\n  var R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n  if (!R) return false;\n  var v = mod(R.x, n);\n  return v === r;\n}\nexports.verify = verify;\nfunction schnorrChallengeFinalize(ch) {\n  return mod(bytesToNumber(ch), CURVE.n);\n}\nvar SchnorrSignature = /*#__PURE__*/function () {\n  function SchnorrSignature(r, s) {\n    _classCallCheck(this, SchnorrSignature);\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  _createClass(SchnorrSignature, [{\n    key: \"assertValidity\",\n    value: function assertValidity() {\n      var r = this.r,\n        s = this.s;\n      if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n  }, {\n    key: \"toRawBytes\",\n    value: function toRawBytes() {\n      return hexToBytes(this.toHex());\n    }\n  }], [{\n    key: \"fromHex\",\n    value: function fromHex(hex) {\n      var bytes = ensureBytes(hex);\n      if (bytes.length !== 64) throw new TypeError(\"SchnorrSignature.fromHex: expected 64 bytes, not \".concat(bytes.length));\n      var r = bytesToNumber(bytes.subarray(0, 32));\n      var s = bytesToNumber(bytes.subarray(32, 64));\n      return new SchnorrSignature(r, s);\n    }\n  }]);\n  return SchnorrSignature;\n}();\nfunction schnorrGetPublicKey(privateKey) {\n  return Point.fromPrivateKey(privateKey).toRawX();\n}\nvar InternalSchnorrSignature = /*#__PURE__*/function () {\n  function InternalSchnorrSignature(message, privateKey) {\n    var auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.utils.randomBytes();\n    _classCallCheck(this, InternalSchnorrSignature);\n    if (message == null) throw new TypeError(\"sign: Expected valid message, not \\\"\".concat(message, \"\\\"\"));\n    this.m = ensureBytes(message);\n    var _this$getScalar = this.getScalar(normalizePrivateKey(privateKey)),\n      x = _this$getScalar.x,\n      scalar = _this$getScalar.scalar;\n    this.px = x;\n    this.d = scalar;\n    this.rand = ensureBytes(auxRand);\n    if (this.rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  }\n  _createClass(InternalSchnorrSignature, [{\n    key: \"getScalar\",\n    value: function getScalar(priv) {\n      var point = Point.fromPrivateKey(priv);\n      var scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n      return {\n        point: point,\n        scalar: scalar,\n        x: point.toRawX()\n      };\n    }\n  }, {\n    key: \"initNonce\",\n    value: function initNonce(d, t0h) {\n      return numTo32b(d ^ bytesToNumber(t0h));\n    }\n  }, {\n    key: \"finalizeNonce\",\n    value: function finalizeNonce(k0h) {\n      var k0 = mod(bytesToNumber(k0h), CURVE.n);\n      if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');\n      var _this$getScalar2 = this.getScalar(k0),\n        R = _this$getScalar2.point,\n        rx = _this$getScalar2.x,\n        k = _this$getScalar2.scalar;\n      return {\n        R: R,\n        rx: rx,\n        k: k\n      };\n    }\n  }, {\n    key: \"finalizeSig\",\n    value: function finalizeSig(R, k, e, d) {\n      return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      throw new Error('sign: Invalid signature produced');\n    }\n  }, {\n    key: \"calc\",\n    value: function () {\n      var _calc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var m, d, px, rand, tag, t, _this$finalizeNonce, R, rx, k, e, sig;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              m = this.m, d = this.d, px = this.px, rand = this.rand;\n              tag = exports.utils.taggedHash;\n              _context3.t0 = this;\n              _context3.t1 = d;\n              _context3.next = 6;\n              return tag(TAGS.aux, rand);\n            case 6:\n              _context3.t2 = _context3.sent;\n              t = _context3.t0.initNonce.call(_context3.t0, _context3.t1, _context3.t2);\n              _context3.t3 = this;\n              _context3.next = 11;\n              return tag(TAGS.nonce, t, px, m);\n            case 11:\n              _context3.t4 = _context3.sent;\n              _this$finalizeNonce = _context3.t3.finalizeNonce.call(_context3.t3, _context3.t4);\n              R = _this$finalizeNonce.R;\n              rx = _this$finalizeNonce.rx;\n              k = _this$finalizeNonce.k;\n              _context3.t5 = schnorrChallengeFinalize;\n              _context3.next = 19;\n              return tag(TAGS.challenge, rx, px, m);\n            case 19:\n              _context3.t6 = _context3.sent;\n              e = (0, _context3.t5)(_context3.t6);\n              sig = this.finalizeSig(R, k, e, d);\n              _context3.next = 24;\n              return schnorrVerify(sig, m, px);\n            case 24:\n              if (_context3.sent) {\n                _context3.next = 26;\n                break;\n              }\n              this.error();\n            case 26:\n              return _context3.abrupt(\"return\", sig);\n            case 27:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function calc() {\n        return _calc.apply(this, arguments);\n      }\n      return calc;\n    }()\n  }, {\n    key: \"calcSync\",\n    value: function calcSync() {\n      var m = this.m,\n        d = this.d,\n        px = this.px,\n        rand = this.rand;\n      var tag = exports.utils.taggedHashSync;\n      var t = this.initNonce(d, tag(TAGS.aux, rand));\n      var _this$finalizeNonce2 = this.finalizeNonce(tag(TAGS.nonce, t, px, m)),\n        R = _this$finalizeNonce2.R,\n        rx = _this$finalizeNonce2.rx,\n        k = _this$finalizeNonce2.k;\n      var e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n      var sig = this.finalizeSig(R, k, e, d);\n      if (!schnorrVerifySync(sig, m, px)) this.error();\n      return sig;\n    }\n  }]);\n  return InternalSchnorrSignature;\n}();\nfunction schnorrSign(_x3, _x4, _x5) {\n  return _schnorrSign.apply(this, arguments);\n}\nfunction _schnorrSign() {\n  _schnorrSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(msg, privKey, auxRand) {\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          return _context8.abrupt(\"return\", new InternalSchnorrSignature(msg, privKey, auxRand).calc());\n        case 1:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return _schnorrSign.apply(this, arguments);\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n  return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n  var raw = signature instanceof SchnorrSignature;\n  var sig = raw ? signature : SchnorrSignature.fromHex(signature);\n  if (raw) sig.assertValidity();\n  return _objectSpread(_objectSpread({}, sig), {}, {\n    m: ensureBytes(message),\n    P: normalizePublicKey(publicKey)\n  });\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n  var R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n  if (!R || !R.hasEvenY() || R.x !== r) return false;\n  return true;\n}\nfunction schnorrVerify(_x6, _x7, _x8) {\n  return _schnorrVerify.apply(this, arguments);\n}\nfunction _schnorrVerify() {\n  _schnorrVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(signature, message, publicKey) {\n    var _initSchnorrVerify2, r, s, m, P, e;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          _context9.prev = 0;\n          _initSchnorrVerify2 = initSchnorrVerify(signature, message, publicKey), r = _initSchnorrVerify2.r, s = _initSchnorrVerify2.s, m = _initSchnorrVerify2.m, P = _initSchnorrVerify2.P;\n          _context9.t0 = schnorrChallengeFinalize;\n          _context9.next = 5;\n          return exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m);\n        case 5:\n          _context9.t1 = _context9.sent;\n          e = (0, _context9.t0)(_context9.t1);\n          return _context9.abrupt(\"return\", finalizeSchnorrVerify(r, P, s, e));\n        case 10:\n          _context9.prev = 10;\n          _context9.t2 = _context9[\"catch\"](0);\n          return _context9.abrupt(\"return\", false);\n        case 13:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee9, null, [[0, 10]]);\n  }));\n  return _schnorrVerify.apply(this, arguments);\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n  try {\n    var _initSchnorrVerify = initSchnorrVerify(signature, message, publicKey),\n      r = _initSchnorrVerify.r,\n      s = _initSchnorrVerify.s,\n      m = _initSchnorrVerify.m,\n      P = _initSchnorrVerify.P;\n    var e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    if (error instanceof ShaError) throw error;\n    return false;\n  }\n}\nexports.schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  signSync: schnorrSignSync,\n  verifySync: schnorrVerifySync\n};\nPoint.BASE._setWindowSize(8);\nvar crypto = {\n  node: nodeCrypto,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nvar TAGS = {\n  challenge: 'BIP0340/challenge',\n  aux: 'BIP0340/aux',\n  nonce: 'BIP0340/nonce'\n};\nvar TAGGED_HASH_PREFIXES = {};\nexports.utils = {\n  bytesToHex: bytesToHex,\n  hexToBytes: hexToBytes,\n  concatBytes: concatBytes,\n  mod: mod,\n  invert: invert,\n  isValidPrivateKey: function isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  _bigintTo32Bytes: numTo32b,\n  _normalizePrivateKey: normalizePrivateKey,\n  hashToPrivateKey: function hashToPrivateKey(hash) {\n    hash = ensureBytes(hash);\n    var minLen = groupLen + 8;\n    if (hash.length < minLen || hash.length > 1024) {\n      throw new Error(\"Expected valid bytes of private key as per FIPS 186\");\n    }\n    var num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n    return numTo32b(num);\n  },\n  randomBytes: function randomBytes() {\n    var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      var randomBytes = crypto.node.randomBytes;\n      return Uint8Array.from(randomBytes(bytesLength));\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: function randomPrivateKey() {\n    return exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8));\n  },\n  precompute: function precompute() {\n    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    var cached = point === Point.BASE ? point : new Point(point.x, point.y);\n    cached._setWindowSize(windowSize);\n    cached.multiply(_3n);\n    return cached;\n  },\n  sha256: function () {\n    var _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var _len4,\n        messages,\n        _key4,\n        buffer,\n        createHash,\n        hash,\n        _args4 = arguments;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            for (_len4 = _args4.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              messages[_key4] = _args4[_key4];\n            }\n            if (!crypto.web) {\n              _context4.next = 8;\n              break;\n            }\n            _context4.next = 4;\n            return crypto.web.subtle.digest('SHA-256', concatBytes.apply(void 0, messages));\n          case 4:\n            buffer = _context4.sent;\n            return _context4.abrupt(\"return\", new Uint8Array(buffer));\n          case 8:\n            if (!crypto.node) {\n              _context4.next = 15;\n              break;\n            }\n            createHash = crypto.node.createHash;\n            hash = createHash('sha256');\n            messages.forEach(function (m) {\n              return hash.update(m);\n            });\n            return _context4.abrupt(\"return\", Uint8Array.from(hash.digest()));\n          case 15:\n            throw new Error(\"The environment doesn't have sha256 function\");\n          case 16:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    function sha256() {\n      return _sha.apply(this, arguments);\n    }\n    return sha256;\n  }(),\n  hmacSha256: function () {\n    var _hmacSha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {\n      var _len5,\n        messages,\n        _key5,\n        ckey,\n        message,\n        buffer,\n        createHmac,\n        hash,\n        _args5 = arguments;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            for (_len5 = _args5.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n              messages[_key5 - 1] = _args5[_key5];\n            }\n            if (!crypto.web) {\n              _context5.next = 12;\n              break;\n            }\n            _context5.next = 4;\n            return crypto.web.subtle.importKey('raw', key, {\n              name: 'HMAC',\n              hash: {\n                name: 'SHA-256'\n              }\n            }, false, ['sign']);\n          case 4:\n            ckey = _context5.sent;\n            message = concatBytes.apply(void 0, messages);\n            _context5.next = 8;\n            return crypto.web.subtle.sign('HMAC', ckey, message);\n          case 8:\n            buffer = _context5.sent;\n            return _context5.abrupt(\"return\", new Uint8Array(buffer));\n          case 12:\n            if (!crypto.node) {\n              _context5.next = 19;\n              break;\n            }\n            createHmac = crypto.node.createHmac;\n            hash = createHmac('sha256', key);\n            messages.forEach(function (m) {\n              return hash.update(m);\n            });\n            return _context5.abrupt(\"return\", Uint8Array.from(hash.digest()));\n          case 19:\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n          case 20:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    function hmacSha256(_x9) {\n      return _hmacSha.apply(this, arguments);\n    }\n    return hmacSha256;\n  }(),\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  taggedHash: function () {\n    var _taggedHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(tag) {\n      var _exports$utils2;\n      var tagP,\n        tagH,\n        _len6,\n        messages,\n        _key6,\n        _args6 = arguments;\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            tagP = TAGGED_HASH_PREFIXES[tag];\n            if (!(tagP === undefined)) {\n              _context6.next = 7;\n              break;\n            }\n            _context6.next = 4;\n            return exports.utils.sha256(Uint8Array.from(tag, function (c) {\n              return c.charCodeAt(0);\n            }));\n          case 4:\n            tagH = _context6.sent;\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n          case 7:\n            for (_len6 = _args6.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n              messages[_key6 - 1] = _args6[_key6];\n            }\n            return _context6.abrupt(\"return\", (_exports$utils2 = exports.utils).sha256.apply(_exports$utils2, [tagP].concat(messages)));\n          case 9:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n    function taggedHash(_x10) {\n      return _taggedHash.apply(this, arguments);\n    }\n    return taggedHash;\n  }(),\n  taggedHashSync: function taggedHashSync(tag) {\n    if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');\n    var tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n      var tagH = _sha256Sync(Uint8Array.from(tag, function (c) {\n        return c.charCodeAt(0);\n      }));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      messages[_key7 - 1] = arguments[_key7];\n    }\n    return _sha256Sync.apply(void 0, [tagP].concat(messages));\n  },\n  _JacobianPoint: JacobianPoint\n};\nObject.defineProperties(exports.utils, {\n  sha256Sync: {\n    configurable: false,\n    get: function get() {\n      return _sha256Sync;\n    },\n    set: function set(val) {\n      if (!_sha256Sync) _sha256Sync = val;\n    }\n  },\n  hmacSha256Sync: {\n    configurable: false,\n    get: function get() {\n      return _hmacSha256Sync;\n    },\n    set: function set(val) {\n      if (!_hmacSha256Sync) _hmacSha256Sync = val;\n    }\n  }\n});","map":{"version":3,"names":["_objectSpread","require","default","_regeneratorRuntime","_asyncToGenerator","_createClass","_classCallCheck","_inherits","_createSuper","_wrapNativeSuper","Object","defineProperty","exports","value","utils","schnorr","verify","signSync","sign","getSharedSecret","recoverPublicKey","getPublicKey","Signature","Point","CURVE","nodeCrypto","_0n","BigInt","_1n","_2n","_3n","_8n","freeze","a","b","P","n","h","Gx","Gy","beta","divNearest","endo","splitScalar","k","a1","b1","a2","b2","POW_2_128","c1","c2","k1","mod","k2","k1neg","k2neg","Error","fieldLen","groupLen","hashLen","compressedLen","uncompressedLen","weierstrass","x","x2","x3","USE_ENDOMORPHISM","ShaError","_Error","_super","message","call","assertJacPoint","other","JacobianPoint","TypeError","y","z","key","equals","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","A","B","C","x1b","D","E","F","X3","Y3","Z3","add","H","r","ZERO","HH","HHH","V","subtract","multiplyUnsafe","scalar","P0","normalizeScalar","p","d","_endo$splitScalar","k1p","k2p","precomputeWindow","W","windows","points","base","window","push","i","Math","pow","wNAF","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","get","normalizeZ","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","offset1","offset2","abs","cond1","cond2","constTimeNegate","multiply","point","fake","_endo$splitScalar2","_this$wNAF","f1p","_this$wNAF2","f2p","_this$wNAF3","toAffine","invZ","is0","invert","iz1","iz2","iz3","ax","ay","zz","fromAffine","toAffineBatch","toInv","invertBatch","map","condition","item","neg","WeakMap","_setWindowSize","delete","hasEvenY","toRawBytes","isCompressed","arguments","length","undefined","hexToBytes","toHex","numTo32bStr","prefix","concat","toHexX","slice","toRawX","assertValidity","msg","isValidFieldElement","left","right","multiplyAndAddUnsafe","Q","aP","bQ","sum","fromCompressedHex","bytes","isShort","bytesToNumber","subarray","y2","sqrtMod","isYOdd","isFirstByteOdd","fromUncompressedHex","fromHex","hex","ensureBytes","len","header","fromPrivateKey","privateKey","normalizePrivateKey","fromSignature","msgHash","signature","recovery","_normalizeSignature","normalizeSignature","s","includes","truncateHash","radj","rinv","u1","u2","R","sliceDER","parseInt","parseDERInt","data","bytesToHex","res","parseDERSignature","_parseDERInt","sBytes","_parseDERInt2","rBytesLeft","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","sHexL","rHexL","sLen","rLen","toCompactRawBytes","toCompactHex","fromCompact","arr","Uint8Array","name","str","hexToNumber","fromDER","_parseDERSignature","concatBytes","_len","arrays","Array","_key","every","reduce","result","pad","hexes","from","v","toString","padStart","uint8a","POW_2_256","num","numTo32b","array","j","hexByte","byte","isNaN","isSafeInteger","pow2","power","_6n","_11n","_22n","_23n","_44n","_88n","b3","b6","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","rt","xc","number","modulo","u","q","m","gcd","nums","scratch","lastMultiplied","acc","inverted","reduceRight","bits2int_2","delta","hash","truncateOnly","_sha256Sync","_hmacSha256Sync","HmacDrbg","qByteLen","fill","counter","hmac","_exports$utils","_len2","values","_key2","hmacSha256","apply","hmacSync","_len3","_key3","checkSync","incr","_reseed","mark","_callee","seed","_args","wrap","_callee$","_context","prev","next","sent","abrupt","stop","reseed","reseedSync","_generate","_callee2","out","sl","_callee2$","_context2","generate","generateSync","kmdToSig","kBytes","lowS","kinv","sig","normalizePublicKey","publicKey","error","isProbPub","privateA","publicB","bits2int","bits2octets","z1","z2","int2octets","initSigArgs","extraEntropy","h1","seedArgs","randomBytes","e","finalizeSig","recSig","opts","_Object$assign","assign","canonical","der","recovered","hashed","_x","_x2","_sign","_callee7","privKey","_initSigArgs2","drbg","_args7","_callee7$","_context7","t0","t3","t4","_initSigArgs","vopts","strict","_sig","sinv","schnorrChallengeFinalize","ch","SchnorrSignature","schnorrGetPublicKey","InternalSchnorrSignature","auxRand","_this$getScalar","getScalar","px","rand","priv","initNonce","t0h","finalizeNonce","k0h","k0","_this$getScalar2","rx","_calc","_callee3","tag","t","_this$finalizeNonce","_callee3$","_context3","taggedHash","TAGS","aux","nonce","t5","challenge","t6","schnorrVerify","calc","calcSync","taggedHashSync","_this$finalizeNonce2","schnorrVerifySync","schnorrSign","_x3","_x4","_x5","_schnorrSign","_callee8","_callee8$","_context8","schnorrSignSync","initSchnorrVerify","raw","finalizeSchnorrVerify","_x6","_x7","_x8","_schnorrVerify","_callee9","_initSchnorrVerify2","_callee9$","_context9","_initSchnorrVerify","verifySync","crypto","node","web","self","TAGGED_HASH_PREFIXES","isValidPrivateKey","_bigintTo32Bytes","_normalizePrivateKey","hashToPrivateKey","minLen","bytesLength","getRandomValues","randomPrivateKey","precompute","cached","sha256","_sha","_callee4","_len4","messages","_key4","buffer","createHash","_args4","_callee4$","_context4","subtle","digest","forEach","update","_hmacSha","_callee5","_len5","_key5","ckey","createHmac","_args5","_callee5$","_context5","importKey","_x9","sha256Sync","hmacSha256Sync","_taggedHash","_callee6","_exports$utils2","tagP","tagH","_len6","_key6","_args6","_callee6$","_context6","c","charCodeAt","_x10","_len7","_key7","_JacobianPoint","defineProperties","configurable","val"],"sources":["C:/Users/rajde/gitrep/deploy/frontend/node_modules/@noble/secp256k1/lib/index.js"],"sourcesContent":["\"use strict\";\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;\nconst nodeCrypto = require(\"crypto\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nexports.CURVE = CURVE;\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nexports.Signature = Signature;\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return exports.utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = exports.utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nexports.sign = sign;\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexports.signSync = signSync;\nconst vopts = { strict: true };\nfunction verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nexports.verify = verify;\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = exports.utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = exports.utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexports.schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexports.utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return exports.utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(exports.utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n"],"mappings":"AAAA,YAAY;;AACZ;AAAA,IAAAA,aAAA,GAAAC,OAAA,+FAAAC,OAAA;AAAA,IAAAC,mBAAA,GAAAF,OAAA,oGAAAC,OAAA;AAAA,IAAAE,iBAAA,GAAAH,OAAA,kGAAAC,OAAA;AAAA,IAAAG,YAAA,GAAAJ,OAAA,6FAAAC,OAAA;AAAA,IAAAI,eAAA,GAAAL,OAAA,gGAAAC,OAAA;AAAA,IAAAK,SAAA,GAAAN,OAAA,0FAAAC,OAAA;AAAA,IAAAM,YAAA,GAAAP,OAAA,6FAAAC,OAAA;AAAA,IAAAO,gBAAA,GAAAR,OAAA,iGAAAC,OAAA;AACAQ,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,KAAK,GAAGF,OAAO,CAACG,OAAO,GAAGH,OAAO,CAACI,MAAM,GAAGJ,OAAO,CAACK,QAAQ,GAAGL,OAAO,CAACM,IAAI,GAAGN,OAAO,CAACO,eAAe,GAAGP,OAAO,CAACQ,gBAAgB,GAAGR,OAAO,CAACS,YAAY,GAAGT,OAAO,CAACU,SAAS,GAAGV,OAAO,CAACW,KAAK,GAAGX,OAAO,CAACY,KAAK,GAAG,KAAK,CAAC;AAC3N,IAAMC,UAAU,GAAGxB,OAAO,CAAC,QAAQ,CAAC;AACpC,IAAMyB,GAAG,GAAGC,MAAM,CAAC,CAAC,CAAC;AACrB,IAAMC,GAAG,GAAGD,MAAM,CAAC,CAAC,CAAC;AACrB,IAAME,GAAG,GAAGF,MAAM,CAAC,CAAC,CAAC;AACrB,IAAMG,GAAG,GAAGH,MAAM,CAAC,CAAC,CAAC;AACrB,IAAMI,GAAG,GAAGJ,MAAM,CAAC,CAAC,CAAC;AACrB,IAAMH,KAAK,GAAGd,MAAM,CAACsB,MAAM,CAAC;EACxBC,CAAC,EAAEP,GAAG;EACNQ,CAAC,EAAEP,MAAM,CAAC,CAAC,CAAC;EACZQ,CAAC,EAAER,MAAM,CAAC,oEAAoE,CAAC;EAC/ES,CAAC,EAAET,MAAM,CAAC,oEAAoE,CAAC;EAC/EU,CAAC,EAAET,GAAG;EACNU,EAAE,EAAEX,MAAM,CAAC,+EAA+E,CAAC;EAC3FY,EAAE,EAAEZ,MAAM,CAAC,+EAA+E,CAAC;EAC3Fa,IAAI,EAAEb,MAAM,CAAC,oEAAoE;AACrF,CAAC,CAAC;AACFf,OAAO,CAACY,KAAK,GAAGA,KAAK;AACrB,IAAMiB,UAAU,GAAG,SAAbA,UAAUA,CAAIR,CAAC,EAAEC,CAAC;EAAA,OAAK,CAACD,CAAC,GAAGC,CAAC,GAAGL,GAAG,IAAIK,CAAC;AAAA;AAC9C,IAAMQ,IAAI,GAAG;EACTF,IAAI,EAAEb,MAAM,CAAC,oEAAoE,CAAC;EAClFgB,WAAW,WAAAA,YAACC,CAAC,EAAE;IACX,IAAQR,CAAC,GAAKZ,KAAK,CAAXY,CAAC;IACT,IAAMS,EAAE,GAAGlB,MAAM,CAAC,oCAAoC,CAAC;IACvD,IAAMmB,EAAE,GAAG,CAAClB,GAAG,GAAGD,MAAM,CAAC,oCAAoC,CAAC;IAC9D,IAAMoB,EAAE,GAAGpB,MAAM,CAAC,qCAAqC,CAAC;IACxD,IAAMqB,EAAE,GAAGH,EAAE;IACb,IAAMI,SAAS,GAAGtB,MAAM,CAAC,qCAAqC,CAAC;IAC/D,IAAMuB,EAAE,GAAGT,UAAU,CAACO,EAAE,GAAGJ,CAAC,EAAER,CAAC,CAAC;IAChC,IAAMe,EAAE,GAAGV,UAAU,CAAC,CAACK,EAAE,GAAGF,CAAC,EAAER,CAAC,CAAC;IACjC,IAAIgB,EAAE,GAAGC,GAAG,CAACT,CAAC,GAAGM,EAAE,GAAGL,EAAE,GAAGM,EAAE,GAAGJ,EAAE,EAAEX,CAAC,CAAC;IACtC,IAAIkB,EAAE,GAAGD,GAAG,CAAC,CAACH,EAAE,GAAGJ,EAAE,GAAGK,EAAE,GAAGH,EAAE,EAAEZ,CAAC,CAAC;IACnC,IAAMmB,KAAK,GAAGH,EAAE,GAAGH,SAAS;IAC5B,IAAMO,KAAK,GAAGF,EAAE,GAAGL,SAAS;IAC5B,IAAIM,KAAK,EACLH,EAAE,GAAGhB,CAAC,GAAGgB,EAAE;IACf,IAAII,KAAK,EACLF,EAAE,GAAGlB,CAAC,GAAGkB,EAAE;IACf,IAAIF,EAAE,GAAGH,SAAS,IAAIK,EAAE,GAAGL,SAAS,EAAE;MAClC,MAAM,IAAIQ,KAAK,CAAC,0CAA0C,GAAGb,CAAC,CAAC;IACnE;IACA,OAAO;MAAEW,KAAK,EAALA,KAAK;MAAEH,EAAE,EAAFA,EAAE;MAAEI,KAAK,EAALA,KAAK;MAAEF,EAAE,EAAFA;IAAG,CAAC;EACnC;AACJ,CAAC;AACD,IAAMI,QAAQ,GAAG,EAAE;AACnB,IAAMC,QAAQ,GAAG,EAAE;AACnB,IAAMC,OAAO,GAAG,EAAE;AAClB,IAAMC,aAAa,GAAGH,QAAQ,GAAG,CAAC;AAClC,IAAMI,eAAe,GAAG,CAAC,GAAGJ,QAAQ,GAAG,CAAC;AACxC,SAASK,WAAWA,CAACC,CAAC,EAAE;EACpB,IAAQ/B,CAAC,GAAQT,KAAK,CAAdS,CAAC;IAAEC,CAAC,GAAKV,KAAK,CAAXU,CAAC;EACZ,IAAM+B,EAAE,GAAGZ,GAAG,CAACW,CAAC,GAAGA,CAAC,CAAC;EACrB,IAAME,EAAE,GAAGb,GAAG,CAACY,EAAE,GAAGD,CAAC,CAAC;EACtB,OAAOX,GAAG,CAACa,EAAE,GAAGjC,CAAC,GAAG+B,CAAC,GAAG9B,CAAC,CAAC;AAC9B;AACA,IAAMiC,gBAAgB,GAAG3C,KAAK,CAACS,CAAC,KAAKP,GAAG;AAAC,IACnC0C,QAAQ,0BAAAC,MAAA;EAAA9D,SAAA,CAAA6D,QAAA,EAAAC,MAAA;EAAA,IAAAC,MAAA,GAAA9D,YAAA,CAAA4D,QAAA;EACV,SAAAA,SAAYG,OAAO,EAAE;IAAAjE,eAAA,OAAA8D,QAAA;IAAA,OAAAE,MAAA,CAAAE,IAAA,OACXD,OAAO;EACjB;EAAC,OAAAlE,YAAA,CAAA+D,QAAA;AAAA,gBAAA3D,gBAAA,CAHkBgD,KAAK;AAK5B,SAASgB,cAAcA,CAACC,KAAK,EAAE;EAC3B,IAAI,EAAEA,KAAK,YAAYC,aAAa,CAAC,EACjC,MAAM,IAAIC,SAAS,CAAC,wBAAwB,CAAC;AACrD;AAAC,IACKD,aAAa;EACf,SAAAA,cAAYX,CAAC,EAAEa,CAAC,EAAEC,CAAC,EAAE;IAAAxE,eAAA,OAAAqE,aAAA;IACjB,IAAI,CAACX,CAAC,GAAGA,CAAC;IACV,IAAI,CAACa,CAAC,GAAGA,CAAC;IACV,IAAI,CAACC,CAAC,GAAGA,CAAC;EACd;EAACzE,YAAA,CAAAsE,aAAA;IAAAI,GAAA;IAAAlE,KAAA,EAgBD,SAAAmE,OAAON,KAAK,EAAE;MACVD,cAAc,CAACC,KAAK,CAAC;MACrB,IAAWO,EAAE,GAAmB,IAAI,CAA5BjB,CAAC;QAASkB,EAAE,GAAY,IAAI,CAArBL,CAAC;QAASM,EAAE,GAAK,IAAI,CAAdL,CAAC;MACvB,IAAWM,EAAE,GAAmBV,KAAK,CAA7BV,CAAC;QAASqB,EAAE,GAAYX,KAAK,CAAtBG,CAAC;QAASS,EAAE,GAAKZ,KAAK,CAAfI,CAAC;MACvB,IAAMS,IAAI,GAAGlC,GAAG,CAAC8B,EAAE,GAAGA,EAAE,CAAC;MACzB,IAAMK,IAAI,GAAGnC,GAAG,CAACiC,EAAE,GAAGA,EAAE,CAAC;MACzB,IAAMG,EAAE,GAAGpC,GAAG,CAAC4B,EAAE,GAAGO,IAAI,CAAC;MACzB,IAAME,EAAE,GAAGrC,GAAG,CAAC+B,EAAE,GAAGG,IAAI,CAAC;MACzB,IAAMI,EAAE,GAAGtC,GAAG,CAACA,GAAG,CAAC6B,EAAE,GAAGI,EAAE,CAAC,GAAGE,IAAI,CAAC;MACnC,IAAMI,EAAE,GAAGvC,GAAG,CAACA,GAAG,CAACgC,EAAE,GAAGF,EAAE,CAAC,GAAGI,IAAI,CAAC;MACnC,OAAOE,EAAE,KAAKC,EAAE,IAAIC,EAAE,KAAKC,EAAE;IACjC;EAAC;IAAAb,GAAA;IAAAlE,KAAA,EACD,SAAAgF,OAAA,EAAS;MACL,OAAO,IAAIlB,aAAa,CAAC,IAAI,CAACX,CAAC,EAAEX,GAAG,CAAC,CAAC,IAAI,CAACwB,CAAC,CAAC,EAAE,IAAI,CAACC,CAAC,CAAC;IAC1D;EAAC;IAAAC,GAAA;IAAAlE,KAAA,EACD,SAAAiF,OAAA,EAAS;MACL,IAAWb,EAAE,GAAmB,IAAI,CAA5BjB,CAAC;QAASkB,EAAE,GAAY,IAAI,CAArBL,CAAC;QAASM,EAAE,GAAK,IAAI,CAAdL,CAAC;MACvB,IAAMiB,CAAC,GAAG1C,GAAG,CAAC4B,EAAE,GAAGA,EAAE,CAAC;MACtB,IAAMe,CAAC,GAAG3C,GAAG,CAAC6B,EAAE,GAAGA,EAAE,CAAC;MACtB,IAAMe,CAAC,GAAG5C,GAAG,CAAC2C,CAAC,GAAGA,CAAC,CAAC;MACpB,IAAME,GAAG,GAAGjB,EAAE,GAAGe,CAAC;MAClB,IAAMG,CAAC,GAAG9C,GAAG,CAACxB,GAAG,IAAIwB,GAAG,CAAC6C,GAAG,GAAGA,GAAG,CAAC,GAAGH,CAAC,GAAGE,CAAC,CAAC,CAAC;MAC7C,IAAMG,CAAC,GAAG/C,GAAG,CAACvB,GAAG,GAAGiE,CAAC,CAAC;MACtB,IAAMM,CAAC,GAAGhD,GAAG,CAAC+C,CAAC,GAAGA,CAAC,CAAC;MACpB,IAAME,EAAE,GAAGjD,GAAG,CAACgD,CAAC,GAAGxE,GAAG,GAAGsE,CAAC,CAAC;MAC3B,IAAMI,EAAE,GAAGlD,GAAG,CAAC+C,CAAC,IAAID,CAAC,GAAGG,EAAE,CAAC,GAAGvE,GAAG,GAAGkE,CAAC,CAAC;MACtC,IAAMO,EAAE,GAAGnD,GAAG,CAACxB,GAAG,GAAGqD,EAAE,GAAGC,EAAE,CAAC;MAC7B,OAAO,IAAIR,aAAa,CAAC2B,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACxC;EAAC;IAAAzB,GAAA;IAAAlE,KAAA,EACD,SAAA4F,IAAI/B,KAAK,EAAE;MACPD,cAAc,CAACC,KAAK,CAAC;MACrB,IAAWO,EAAE,GAAmB,IAAI,CAA5BjB,CAAC;QAASkB,EAAE,GAAY,IAAI,CAArBL,CAAC;QAASM,EAAE,GAAK,IAAI,CAAdL,CAAC;MACvB,IAAWM,EAAE,GAAmBV,KAAK,CAA7BV,CAAC;QAASqB,EAAE,GAAYX,KAAK,CAAtBG,CAAC;QAASS,EAAE,GAAKZ,KAAK,CAAfI,CAAC;MACvB,IAAIM,EAAE,KAAK1D,GAAG,IAAI2D,EAAE,KAAK3D,GAAG,EACxB,OAAO,IAAI;MACf,IAAIuD,EAAE,KAAKvD,GAAG,IAAIwD,EAAE,KAAKxD,GAAG,EACxB,OAAOgD,KAAK;MAChB,IAAMa,IAAI,GAAGlC,GAAG,CAAC8B,EAAE,GAAGA,EAAE,CAAC;MACzB,IAAMK,IAAI,GAAGnC,GAAG,CAACiC,EAAE,GAAGA,EAAE,CAAC;MACzB,IAAMG,EAAE,GAAGpC,GAAG,CAAC4B,EAAE,GAAGO,IAAI,CAAC;MACzB,IAAME,EAAE,GAAGrC,GAAG,CAAC+B,EAAE,GAAGG,IAAI,CAAC;MACzB,IAAMI,EAAE,GAAGtC,GAAG,CAACA,GAAG,CAAC6B,EAAE,GAAGI,EAAE,CAAC,GAAGE,IAAI,CAAC;MACnC,IAAMI,EAAE,GAAGvC,GAAG,CAACA,GAAG,CAACgC,EAAE,GAAGF,EAAE,CAAC,GAAGI,IAAI,CAAC;MACnC,IAAMmB,CAAC,GAAGrD,GAAG,CAACqC,EAAE,GAAGD,EAAE,CAAC;MACtB,IAAMkB,CAAC,GAAGtD,GAAG,CAACuC,EAAE,GAAGD,EAAE,CAAC;MACtB,IAAIe,CAAC,KAAKhF,GAAG,EAAE;QACX,IAAIiF,CAAC,KAAKjF,GAAG,EAAE;UACX,OAAO,IAAI,CAACoE,MAAM,CAAC,CAAC;QACxB,CAAC,MACI;UACD,OAAOnB,aAAa,CAACiC,IAAI;QAC7B;MACJ;MACA,IAAMC,EAAE,GAAGxD,GAAG,CAACqD,CAAC,GAAGA,CAAC,CAAC;MACrB,IAAMI,GAAG,GAAGzD,GAAG,CAACqD,CAAC,GAAGG,EAAE,CAAC;MACvB,IAAME,CAAC,GAAG1D,GAAG,CAACoC,EAAE,GAAGoB,EAAE,CAAC;MACtB,IAAMP,EAAE,GAAGjD,GAAG,CAACsD,CAAC,GAAGA,CAAC,GAAGG,GAAG,GAAGjF,GAAG,GAAGkF,CAAC,CAAC;MACrC,IAAMR,EAAE,GAAGlD,GAAG,CAACsD,CAAC,IAAII,CAAC,GAAGT,EAAE,CAAC,GAAGX,EAAE,GAAGmB,GAAG,CAAC;MACvC,IAAMN,EAAE,GAAGnD,GAAG,CAAC8B,EAAE,GAAGG,EAAE,GAAGoB,CAAC,CAAC;MAC3B,OAAO,IAAI/B,aAAa,CAAC2B,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACxC;EAAC;IAAAzB,GAAA;IAAAlE,KAAA,EACD,SAAAmG,SAAStC,KAAK,EAAE;MACZ,OAAO,IAAI,CAAC+B,GAAG,CAAC/B,KAAK,CAACmB,MAAM,CAAC,CAAC,CAAC;IACnC;EAAC;IAAAd,GAAA;IAAAlE,KAAA,EACD,SAAAoG,eAAeC,MAAM,EAAE;MACnB,IAAMC,EAAE,GAAGxC,aAAa,CAACiC,IAAI;MAC7B,IAAI,OAAOM,MAAM,KAAK,QAAQ,IAAIA,MAAM,KAAKxF,GAAG,EAC5C,OAAOyF,EAAE;MACb,IAAI/E,CAAC,GAAGgF,eAAe,CAACF,MAAM,CAAC;MAC/B,IAAI9E,CAAC,KAAKR,GAAG,EACT,OAAO,IAAI;MACf,IAAI,CAACuC,gBAAgB,EAAE;QACnB,IAAIkD,CAAC,GAAGF,EAAE;QACV,IAAIG,EAAC,GAAG,IAAI;QACZ,OAAOlF,CAAC,GAAGV,GAAG,EAAE;UACZ,IAAIU,CAAC,GAAGR,GAAG,EACPyF,CAAC,GAAGA,CAAC,CAACZ,GAAG,CAACa,EAAC,CAAC;UAChBA,EAAC,GAAGA,EAAC,CAACxB,MAAM,CAAC,CAAC;UACd1D,CAAC,KAAKR,GAAG;QACb;QACA,OAAOyF,CAAC;MACZ;MACA,IAAAE,iBAAA,GAA+B7E,IAAI,CAACC,WAAW,CAACP,CAAC,CAAC;QAA5CmB,KAAK,GAAAgE,iBAAA,CAALhE,KAAK;QAAEH,EAAE,GAAAmE,iBAAA,CAAFnE,EAAE;QAAEI,KAAK,GAAA+D,iBAAA,CAAL/D,KAAK;QAAEF,EAAE,GAAAiE,iBAAA,CAAFjE,EAAE;MAC1B,IAAIkE,GAAG,GAAGL,EAAE;MACZ,IAAIM,GAAG,GAAGN,EAAE;MACZ,IAAIG,CAAC,GAAG,IAAI;MACZ,OAAOlE,EAAE,GAAG1B,GAAG,IAAI4B,EAAE,GAAG5B,GAAG,EAAE;QACzB,IAAI0B,EAAE,GAAGxB,GAAG,EACR4F,GAAG,GAAGA,GAAG,CAACf,GAAG,CAACa,CAAC,CAAC;QACpB,IAAIhE,EAAE,GAAG1B,GAAG,EACR6F,GAAG,GAAGA,GAAG,CAAChB,GAAG,CAACa,CAAC,CAAC;QACpBA,CAAC,GAAGA,CAAC,CAACxB,MAAM,CAAC,CAAC;QACd1C,EAAE,KAAKxB,GAAG;QACV0B,EAAE,KAAK1B,GAAG;MACd;MACA,IAAI2B,KAAK,EACLiE,GAAG,GAAGA,GAAG,CAAC3B,MAAM,CAAC,CAAC;MACtB,IAAIrC,KAAK,EACLiE,GAAG,GAAGA,GAAG,CAAC5B,MAAM,CAAC,CAAC;MACtB4B,GAAG,GAAG,IAAI9C,aAAa,CAACtB,GAAG,CAACoE,GAAG,CAACzD,CAAC,GAAGtB,IAAI,CAACF,IAAI,CAAC,EAAEiF,GAAG,CAAC5C,CAAC,EAAE4C,GAAG,CAAC3C,CAAC,CAAC;MAC7D,OAAO0C,GAAG,CAACf,GAAG,CAACgB,GAAG,CAAC;IACvB;EAAC;IAAA1C,GAAA;IAAAlE,KAAA,EACD,SAAA6G,iBAAiBC,CAAC,EAAE;MAChB,IAAMC,OAAO,GAAGzD,gBAAgB,GAAG,GAAG,GAAGwD,CAAC,GAAG,CAAC,GAAG,GAAG,GAAGA,CAAC,GAAG,CAAC;MAC5D,IAAME,MAAM,GAAG,EAAE;MACjB,IAAIR,CAAC,GAAG,IAAI;MACZ,IAAIS,IAAI,GAAGT,CAAC;MACZ,KAAK,IAAIU,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGH,OAAO,EAAEG,MAAM,EAAE,EAAE;QAC7CD,IAAI,GAAGT,CAAC;QACRQ,MAAM,CAACG,IAAI,CAACF,IAAI,CAAC;QACjB,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAAC,IAAA,CAAAC,GAAA,CAAG,CAAC,EAAKR,CAAC,GAAG,CAAC,CAAC,EAAEM,CAAC,EAAE,EAAE;UACnCH,IAAI,GAAGA,IAAI,CAACrB,GAAG,CAACY,CAAC,CAAC;UAClBQ,MAAM,CAACG,IAAI,CAACF,IAAI,CAAC;QACrB;QACAT,CAAC,GAAGS,IAAI,CAAChC,MAAM,CAAC,CAAC;MACrB;MACA,OAAO+B,MAAM;IACjB;EAAC;IAAA9C,GAAA;IAAAlE,KAAA,EACD,SAAAuH,KAAKhG,CAAC,EAAEiG,WAAW,EAAE;MACjB,IAAI,CAACA,WAAW,IAAI,IAAI,CAACrD,MAAM,CAACL,aAAa,CAAC2D,IAAI,CAAC,EAC/CD,WAAW,GAAG9G,KAAK,CAAC+G,IAAI;MAC5B,IAAMX,CAAC,GAAIU,WAAW,IAAIA,WAAW,CAACE,YAAY,IAAK,CAAC;MACxD,IAAI,GAAG,GAAGZ,CAAC,EAAE;QACT,MAAM,IAAIlE,KAAK,CAAC,+DAA+D,CAAC;MACpF;MACA,IAAI+E,WAAW,GAAGH,WAAW,IAAII,gBAAgB,CAACC,GAAG,CAACL,WAAW,CAAC;MAClE,IAAI,CAACG,WAAW,EAAE;QACdA,WAAW,GAAG,IAAI,CAACd,gBAAgB,CAACC,CAAC,CAAC;QACtC,IAAIU,WAAW,IAAIV,CAAC,KAAK,CAAC,EAAE;UACxBa,WAAW,GAAG7D,aAAa,CAACgE,UAAU,CAACH,WAAW,CAAC;UACnDC,gBAAgB,CAACG,GAAG,CAACP,WAAW,EAAEG,WAAW,CAAC;QAClD;MACJ;MACA,IAAInB,CAAC,GAAG1C,aAAa,CAACiC,IAAI;MAC1B,IAAIiC,CAAC,GAAGlE,aAAa,CAAC2D,IAAI;MAC1B,IAAMV,OAAO,GAAG,CAAC,IAAIzD,gBAAgB,GAAG,GAAG,GAAGwD,CAAC,GAAG,GAAG,GAAGA,CAAC,CAAC;MAC1D,IAAMmB,UAAU,GAAAZ,IAAA,CAAAC,GAAA,CAAG,CAAC,EAAKR,CAAC,GAAG,CAAC,CAAC;MAC/B,IAAMoB,IAAI,GAAGpH,MAAM,CAACuG,IAAA,CAAAC,GAAA,EAAC,EAAIR,CAAC,IAAG,CAAC,CAAC;MAC/B,IAAMqB,SAAS,GAAAd,IAAA,CAAAC,GAAA,CAAG,CAAC,EAAIR,CAAC;MACxB,IAAMsB,OAAO,GAAGtH,MAAM,CAACgG,CAAC,CAAC;MACzB,KAAK,IAAII,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGH,OAAO,EAAEG,MAAM,EAAE,EAAE;QAC7C,IAAMmB,MAAM,GAAGnB,MAAM,GAAGe,UAAU;QAClC,IAAIK,KAAK,GAAGC,MAAM,CAAChH,CAAC,GAAG2G,IAAI,CAAC;QAC5B3G,CAAC,KAAK6G,OAAO;QACb,IAAIE,KAAK,GAAGL,UAAU,EAAE;UACpBK,KAAK,IAAIH,SAAS;UAClB5G,CAAC,IAAIR,GAAG;QACZ;QACA,IAAMyH,OAAO,GAAGH,MAAM;QACtB,IAAMI,OAAO,GAAGJ,MAAM,GAAGhB,IAAI,CAACqB,GAAG,CAACJ,KAAK,CAAC,GAAG,CAAC;QAC5C,IAAMK,KAAK,GAAGzB,MAAM,GAAG,CAAC,KAAK,CAAC;QAC9B,IAAM0B,KAAK,GAAGN,KAAK,GAAG,CAAC;QACvB,IAAIA,KAAK,KAAK,CAAC,EAAE;UACbN,CAAC,GAAGA,CAAC,CAACpC,GAAG,CAACiD,eAAe,CAACF,KAAK,EAAEhB,WAAW,CAACa,OAAO,CAAC,CAAC,CAAC;QAC3D,CAAC,MACI;UACDhC,CAAC,GAAGA,CAAC,CAACZ,GAAG,CAACiD,eAAe,CAACD,KAAK,EAAEjB,WAAW,CAACc,OAAO,CAAC,CAAC,CAAC;QAC3D;MACJ;MACA,OAAO;QAAEjC,CAAC,EAADA,CAAC;QAAEwB,CAAC,EAADA;MAAE,CAAC;IACnB;EAAC;IAAA9D,GAAA;IAAAlE,KAAA,EACD,SAAA8I,SAASzC,MAAM,EAAEmB,WAAW,EAAE;MAC1B,IAAIjG,CAAC,GAAGgF,eAAe,CAACF,MAAM,CAAC;MAC/B,IAAI0C,KAAK;MACT,IAAIC,IAAI;MACR,IAAI1F,gBAAgB,EAAE;QAClB,IAAA2F,kBAAA,GAAiCpH,IAAI,CAACC,WAAW,CAACP,CAAC,CAAC;UAA5CmB,KAAK,GAAAuG,kBAAA,CAALvG,KAAK;UAAEH,EAAE,GAAA0G,kBAAA,CAAF1G,EAAE;UAAEI,KAAK,GAAAsG,kBAAA,CAALtG,KAAK;UAAEF,EAAE,GAAAwG,kBAAA,CAAFxG,EAAE;QAC5B,IAAAyG,UAAA,GAAyB,IAAI,CAAC3B,IAAI,CAAChF,EAAE,EAAEiF,WAAW,CAAC;UAA1Cb,GAAG,GAAAuC,UAAA,CAAN1C,CAAC;UAAU2C,GAAG,GAAAD,UAAA,CAANlB,CAAC;QACf,IAAAoB,WAAA,GAAyB,IAAI,CAAC7B,IAAI,CAAC9E,EAAE,EAAE+E,WAAW,CAAC;UAA1CZ,GAAG,GAAAwC,WAAA,CAAN5C,CAAC;UAAU6C,GAAG,GAAAD,WAAA,CAANpB,CAAC;QACfrB,GAAG,GAAGkC,eAAe,CAACnG,KAAK,EAAEiE,GAAG,CAAC;QACjCC,GAAG,GAAGiC,eAAe,CAAClG,KAAK,EAAEiE,GAAG,CAAC;QACjCA,GAAG,GAAG,IAAI9C,aAAa,CAACtB,GAAG,CAACoE,GAAG,CAACzD,CAAC,GAAGtB,IAAI,CAACF,IAAI,CAAC,EAAEiF,GAAG,CAAC5C,CAAC,EAAE4C,GAAG,CAAC3C,CAAC,CAAC;QAC7D8E,KAAK,GAAGpC,GAAG,CAACf,GAAG,CAACgB,GAAG,CAAC;QACpBoC,IAAI,GAAGG,GAAG,CAACvD,GAAG,CAACyD,GAAG,CAAC;MACvB,CAAC,MACI;QACD,IAAAC,WAAA,GAAiB,IAAI,CAAC/B,IAAI,CAAChG,CAAC,EAAEiG,WAAW,CAAC;UAAlChB,CAAC,GAAA8C,WAAA,CAAD9C,CAAC;UAAEwB,CAAC,GAAAsB,WAAA,CAADtB,CAAC;QACZe,KAAK,GAAGvC,CAAC;QACTwC,IAAI,GAAGhB,CAAC;MACZ;MACA,OAAOlE,aAAa,CAACgE,UAAU,CAAC,CAACiB,KAAK,EAAEC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACrD;EAAC;IAAA9E,GAAA;IAAAlE,KAAA,EACD,SAAAuJ,SAASC,IAAI,EAAE;MACX,IAAQrG,CAAC,GAAW,IAAI,CAAhBA,CAAC;QAAEa,CAAC,GAAQ,IAAI,CAAbA,CAAC;QAAEC,CAAC,GAAK,IAAI,CAAVA,CAAC;MACf,IAAMwF,GAAG,GAAG,IAAI,CAACtF,MAAM,CAACL,aAAa,CAACiC,IAAI,CAAC;MAC3C,IAAIyD,IAAI,IAAI,IAAI,EACZA,IAAI,GAAGC,GAAG,GAAGvI,GAAG,GAAGwI,MAAM,CAACzF,CAAC,CAAC;MAChC,IAAM0F,GAAG,GAAGH,IAAI;MAChB,IAAMI,GAAG,GAAGpH,GAAG,CAACmH,GAAG,GAAGA,GAAG,CAAC;MAC1B,IAAME,GAAG,GAAGrH,GAAG,CAACoH,GAAG,GAAGD,GAAG,CAAC;MAC1B,IAAMG,EAAE,GAAGtH,GAAG,CAACW,CAAC,GAAGyG,GAAG,CAAC;MACvB,IAAMG,EAAE,GAAGvH,GAAG,CAACwB,CAAC,GAAG6F,GAAG,CAAC;MACvB,IAAMG,EAAE,GAAGxH,GAAG,CAACyB,CAAC,GAAG0F,GAAG,CAAC;MACvB,IAAIF,GAAG,EACH,OAAO/I,KAAK,CAACqF,IAAI;MACrB,IAAIiE,EAAE,KAAKjJ,GAAG,EACV,MAAM,IAAI6B,KAAK,CAAC,kBAAkB,CAAC;MACvC,OAAO,IAAIlC,KAAK,CAACoJ,EAAE,EAAEC,EAAE,CAAC;IAC5B;EAAC;IAAA7F,GAAA;IAAAlE,KAAA,EArND,SAAAiK,WAAkBzD,CAAC,EAAE;MACjB,IAAI,EAAEA,CAAC,YAAY9F,KAAK,CAAC,EAAE;QACvB,MAAM,IAAIqD,SAAS,CAAC,0CAA0C,CAAC;MACnE;MACA,IAAIyC,CAAC,CAACrC,MAAM,CAACzD,KAAK,CAACqF,IAAI,CAAC,EACpB,OAAOjC,aAAa,CAACiC,IAAI;MAC7B,OAAO,IAAIjC,aAAa,CAAC0C,CAAC,CAACrD,CAAC,EAAEqD,CAAC,CAACxC,CAAC,EAAEjD,GAAG,CAAC;IAC3C;EAAC;IAAAmD,GAAA;IAAAlE,KAAA,EACD,SAAAkK,cAAqBlD,MAAM,EAAE;MACzB,IAAMmD,KAAK,GAAGC,WAAW,CAACpD,MAAM,CAACqD,GAAG,CAAC,UAAC7D,CAAC;QAAA,OAAKA,CAAC,CAACvC,CAAC;MAAA,EAAC,CAAC;MACjD,OAAO+C,MAAM,CAACqD,GAAG,CAAC,UAAC7D,CAAC,EAAEY,CAAC;QAAA,OAAKZ,CAAC,CAAC+C,QAAQ,CAACY,KAAK,CAAC/C,CAAC,CAAC,CAAC;MAAA,EAAC;IACrD;EAAC;IAAAlD,GAAA;IAAAlE,KAAA,EACD,SAAA8H,WAAkBd,MAAM,EAAE;MACtB,OAAOlD,aAAa,CAACoG,aAAa,CAAClD,MAAM,CAAC,CAACqD,GAAG,CAACvG,aAAa,CAACmG,UAAU,CAAC;IAC5E;EAAC;EAAA,OAAAnG,aAAA;AAAA;AAyMLA,aAAa,CAAC2D,IAAI,GAAG,IAAI3D,aAAa,CAACnD,KAAK,CAACc,EAAE,EAAEd,KAAK,CAACe,EAAE,EAAEX,GAAG,CAAC;AAC/D+C,aAAa,CAACiC,IAAI,GAAG,IAAIjC,aAAa,CAACjD,GAAG,EAAEE,GAAG,EAAEF,GAAG,CAAC;AACrD,SAASgI,eAAeA,CAACyB,SAAS,EAAEC,IAAI,EAAE;EACtC,IAAMC,GAAG,GAAGD,IAAI,CAACvF,MAAM,CAAC,CAAC;EACzB,OAAOsF,SAAS,GAAGE,GAAG,GAAGD,IAAI;AACjC;AACA,IAAM3C,gBAAgB,GAAG,IAAI6C,OAAO,CAAC,CAAC;AAAC,IACjC/J,KAAK;EACP,SAAAA,MAAYyC,CAAC,EAAEa,CAAC,EAAE;IAAAvE,eAAA,OAAAiB,KAAA;IACd,IAAI,CAACyC,CAAC,GAAGA,CAAC;IACV,IAAI,CAACa,CAAC,GAAGA,CAAC;EACd;EAACxE,YAAA,CAAAkB,KAAA;IAAAwD,GAAA;IAAAlE,KAAA,EACD,SAAA0K,eAAezC,UAAU,EAAE;MACvB,IAAI,CAACP,YAAY,GAAGO,UAAU;MAC9BL,gBAAgB,CAAC+C,MAAM,CAAC,IAAI,CAAC;IACjC;EAAC;IAAAzG,GAAA;IAAAlE,KAAA,EACD,SAAA4K,SAAA,EAAW;MACP,OAAO,IAAI,CAAC5G,CAAC,GAAGhD,GAAG,KAAKH,GAAG;IAC/B;EAAC;IAAAqD,GAAA;IAAAlE,KAAA,EA+DD,SAAA6K,WAAA,EAAiC;MAAA,IAAtBC,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;MAC3B,OAAOG,UAAU,CAAC,IAAI,CAACC,KAAK,CAACL,YAAY,CAAC,CAAC;IAC/C;EAAC;IAAA5G,GAAA;IAAAlE,KAAA,EACD,SAAAmL,MAAA,EAA4B;MAAA,IAAtBL,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;MACtB,IAAM5H,CAAC,GAAGiI,WAAW,CAAC,IAAI,CAACjI,CAAC,CAAC;MAC7B,IAAI2H,YAAY,EAAE;QACd,IAAMO,MAAM,GAAG,IAAI,CAACT,QAAQ,CAAC,CAAC,GAAG,IAAI,GAAG,IAAI;QAC5C,UAAAU,MAAA,CAAUD,MAAM,EAAAC,MAAA,CAAGnI,CAAC;MACxB,CAAC,MACI;QACD,YAAAmI,MAAA,CAAYnI,CAAC,EAAAmI,MAAA,CAAGF,WAAW,CAAC,IAAI,CAACpH,CAAC,CAAC;MACvC;IACJ;EAAC;IAAAE,GAAA;IAAAlE,KAAA,EACD,SAAAuL,OAAA,EAAS;MACL,OAAO,IAAI,CAACJ,KAAK,CAAC,IAAI,CAAC,CAACK,KAAK,CAAC,CAAC,CAAC;IACpC;EAAC;IAAAtH,GAAA;IAAAlE,KAAA,EACD,SAAAyL,OAAA,EAAS;MACL,OAAO,IAAI,CAACZ,UAAU,CAAC,IAAI,CAAC,CAACW,KAAK,CAAC,CAAC,CAAC;IACzC;EAAC;IAAAtH,GAAA;IAAAlE,KAAA,EACD,SAAA0L,eAAA,EAAiB;MACb,IAAMC,GAAG,GAAG,gCAAgC;MAC5C,IAAQxI,CAAC,GAAQ,IAAI,CAAbA,CAAC;QAAEa,CAAC,GAAK,IAAI,CAAVA,CAAC;MACZ,IAAI,CAAC4H,mBAAmB,CAACzI,CAAC,CAAC,IAAI,CAACyI,mBAAmB,CAAC5H,CAAC,CAAC,EAClD,MAAM,IAAIpB,KAAK,CAAC+I,GAAG,CAAC;MACxB,IAAME,IAAI,GAAGrJ,GAAG,CAACwB,CAAC,GAAGA,CAAC,CAAC;MACvB,IAAM8H,KAAK,GAAG5I,WAAW,CAACC,CAAC,CAAC;MAC5B,IAAIX,GAAG,CAACqJ,IAAI,GAAGC,KAAK,CAAC,KAAKjL,GAAG,EACzB,MAAM,IAAI+B,KAAK,CAAC+I,GAAG,CAAC;IAC5B;EAAC;IAAAzH,GAAA;IAAAlE,KAAA,EACD,SAAAmE,OAAON,KAAK,EAAE;MACV,OAAO,IAAI,CAACV,CAAC,KAAKU,KAAK,CAACV,CAAC,IAAI,IAAI,CAACa,CAAC,KAAKH,KAAK,CAACG,CAAC;IACnD;EAAC;IAAAE,GAAA;IAAAlE,KAAA,EACD,SAAAgF,OAAA,EAAS;MACL,OAAO,IAAItE,KAAK,CAAC,IAAI,CAACyC,CAAC,EAAEX,GAAG,CAAC,CAAC,IAAI,CAACwB,CAAC,CAAC,CAAC;IAC1C;EAAC;IAAAE,GAAA;IAAAlE,KAAA,EACD,SAAAiF,OAAA,EAAS;MACL,OAAOnB,aAAa,CAACmG,UAAU,CAAC,IAAI,CAAC,CAAChF,MAAM,CAAC,CAAC,CAACsE,QAAQ,CAAC,CAAC;IAC7D;EAAC;IAAArF,GAAA;IAAAlE,KAAA,EACD,SAAA4F,IAAI/B,KAAK,EAAE;MACP,OAAOC,aAAa,CAACmG,UAAU,CAAC,IAAI,CAAC,CAACrE,GAAG,CAAC9B,aAAa,CAACmG,UAAU,CAACpG,KAAK,CAAC,CAAC,CAAC0F,QAAQ,CAAC,CAAC;IACzF;EAAC;IAAArF,GAAA;IAAAlE,KAAA,EACD,SAAAmG,SAAStC,KAAK,EAAE;MACZ,OAAO,IAAI,CAAC+B,GAAG,CAAC/B,KAAK,CAACmB,MAAM,CAAC,CAAC,CAAC;IACnC;EAAC;IAAAd,GAAA;IAAAlE,KAAA,EACD,SAAA8I,SAASzC,MAAM,EAAE;MACb,OAAOvC,aAAa,CAACmG,UAAU,CAAC,IAAI,CAAC,CAACnB,QAAQ,CAACzC,MAAM,EAAE,IAAI,CAAC,CAACkD,QAAQ,CAAC,CAAC;IAC3E;EAAC;IAAArF,GAAA;IAAAlE,KAAA,EACD,SAAA+L,qBAAqBC,CAAC,EAAE5K,CAAC,EAAEC,CAAC,EAAE;MAC1B,IAAMC,CAAC,GAAGwC,aAAa,CAACmG,UAAU,CAAC,IAAI,CAAC;MACxC,IAAMgC,EAAE,GAAG7K,CAAC,KAAKP,GAAG,IAAIO,CAAC,KAAKL,GAAG,IAAI,IAAI,KAAKL,KAAK,CAAC+G,IAAI,GAAGnG,CAAC,CAAC8E,cAAc,CAAChF,CAAC,CAAC,GAAGE,CAAC,CAACwH,QAAQ,CAAC1H,CAAC,CAAC;MAC9F,IAAM8K,EAAE,GAAGpI,aAAa,CAACmG,UAAU,CAAC+B,CAAC,CAAC,CAAC5F,cAAc,CAAC/E,CAAC,CAAC;MACxD,IAAM8K,GAAG,GAAGF,EAAE,CAACrG,GAAG,CAACsG,EAAE,CAAC;MACtB,OAAOC,GAAG,CAAChI,MAAM,CAACL,aAAa,CAACiC,IAAI,CAAC,GAAGkF,SAAS,GAAGkB,GAAG,CAAC5C,QAAQ,CAAC,CAAC;IACtE;EAAC;IAAArF,GAAA;IAAAlE,KAAA,EAnHD,SAAAoM,kBAAyBC,KAAK,EAAE;MAC5B,IAAMC,OAAO,GAAGD,KAAK,CAACrB,MAAM,KAAK,EAAE;MACnC,IAAM7H,CAAC,GAAGoJ,aAAa,CAACD,OAAO,GAAGD,KAAK,GAAGA,KAAK,CAACG,QAAQ,CAAC,CAAC,CAAC,CAAC;MAC5D,IAAI,CAACZ,mBAAmB,CAACzI,CAAC,CAAC,EACvB,MAAM,IAAIP,KAAK,CAAC,uBAAuB,CAAC;MAC5C,IAAM6J,EAAE,GAAGvJ,WAAW,CAACC,CAAC,CAAC;MACzB,IAAIa,CAAC,GAAG0I,OAAO,CAACD,EAAE,CAAC;MACnB,IAAME,MAAM,GAAG,CAAC3I,CAAC,GAAGjD,GAAG,MAAMA,GAAG;MAChC,IAAIuL,OAAO,EAAE;QACT,IAAIK,MAAM,EACN3I,CAAC,GAAGxB,GAAG,CAAC,CAACwB,CAAC,CAAC;MACnB,CAAC,MACI;QACD,IAAM4I,cAAc,GAAG,CAACP,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC;QAC3C,IAAIO,cAAc,KAAKD,MAAM,EACzB3I,CAAC,GAAGxB,GAAG,CAAC,CAACwB,CAAC,CAAC;MACnB;MACA,IAAM+E,KAAK,GAAG,IAAIrI,KAAK,CAACyC,CAAC,EAAEa,CAAC,CAAC;MAC7B+E,KAAK,CAAC2C,cAAc,CAAC,CAAC;MACtB,OAAO3C,KAAK;IAChB;EAAC;IAAA7E,GAAA;IAAAlE,KAAA,EACD,SAAA6M,oBAA2BR,KAAK,EAAE;MAC9B,IAAMlJ,CAAC,GAAGoJ,aAAa,CAACF,KAAK,CAACG,QAAQ,CAAC,CAAC,EAAE3J,QAAQ,GAAG,CAAC,CAAC,CAAC;MACxD,IAAMmB,CAAC,GAAGuI,aAAa,CAACF,KAAK,CAACG,QAAQ,CAAC3J,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;MACvE,IAAMkG,KAAK,GAAG,IAAIrI,KAAK,CAACyC,CAAC,EAAEa,CAAC,CAAC;MAC7B+E,KAAK,CAAC2C,cAAc,CAAC,CAAC;MACtB,OAAO3C,KAAK;IAChB;EAAC;IAAA7E,GAAA;IAAAlE,KAAA,EACD,SAAA8M,QAAeC,GAAG,EAAE;MAChB,IAAMV,KAAK,GAAGW,WAAW,CAACD,GAAG,CAAC;MAC9B,IAAME,GAAG,GAAGZ,KAAK,CAACrB,MAAM;MACxB,IAAMkC,MAAM,GAAGb,KAAK,CAAC,CAAC,CAAC;MACvB,IAAIY,GAAG,KAAKpK,QAAQ,EAChB,OAAO,IAAI,CAACuJ,iBAAiB,CAACC,KAAK,CAAC;MACxC,IAAIY,GAAG,KAAKjK,aAAa,KAAKkK,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,IAAI,CAAC,EAAE;QAC/D,OAAO,IAAI,CAACd,iBAAiB,CAACC,KAAK,CAAC;MACxC;MACA,IAAIY,GAAG,KAAKhK,eAAe,IAAIiK,MAAM,KAAK,IAAI,EAC1C,OAAO,IAAI,CAACL,mBAAmB,CAACR,KAAK,CAAC;MAC1C,MAAM,IAAIzJ,KAAK,uDAAA0I,MAAA,CAAuDtI,aAAa,2BAAAsI,MAAA,CAAwBrI,eAAe,+BAAAqI,MAAA,CAA4B2B,GAAG,CAAE,CAAC;IAChK;EAAC;IAAA/I,GAAA;IAAAlE,KAAA,EACD,SAAAmN,eAAsBC,UAAU,EAAE;MAC9B,OAAO1M,KAAK,CAAC+G,IAAI,CAACqB,QAAQ,CAACuE,mBAAmB,CAACD,UAAU,CAAC,CAAC;IAC/D;EAAC;IAAAlJ,GAAA;IAAAlE,KAAA,EACD,SAAAsN,cAAqBC,OAAO,EAAEC,SAAS,EAAEC,QAAQ,EAAE;MAC/C,IAAAC,mBAAA,GAAiBC,kBAAkB,CAACH,SAAS,CAAC;QAAtC1H,CAAC,GAAA4H,mBAAA,CAAD5H,CAAC;QAAE8H,CAAC,GAAAF,mBAAA,CAADE,CAAC;MACZ,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACC,QAAQ,CAACJ,QAAQ,CAAC,EAChC,MAAM,IAAI7K,KAAK,CAAC,sCAAsC,CAAC;MAC3D,IAAMpB,CAAC,GAAGsM,YAAY,CAACd,WAAW,CAACO,OAAO,CAAC,CAAC;MAC5C,IAAQhM,CAAC,GAAKZ,KAAK,CAAXY,CAAC;MACT,IAAMwM,IAAI,GAAGN,QAAQ,KAAK,CAAC,IAAIA,QAAQ,KAAK,CAAC,GAAG3H,CAAC,GAAGvE,CAAC,GAAGuE,CAAC;MACzD,IAAMkI,IAAI,GAAGtE,MAAM,CAACqE,IAAI,EAAExM,CAAC,CAAC;MAC5B,IAAM0M,EAAE,GAAGzL,GAAG,CAAC,CAAChB,CAAC,GAAGwM,IAAI,EAAEzM,CAAC,CAAC;MAC5B,IAAM2M,EAAE,GAAG1L,GAAG,CAACoL,CAAC,GAAGI,IAAI,EAAEzM,CAAC,CAAC;MAC3B,IAAM8J,MAAM,GAAGoC,QAAQ,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI;MACzC,IAAMU,CAAC,GAAGzN,KAAK,CAACoM,OAAO,CAACzB,MAAM,GAAGD,WAAW,CAAC2C,IAAI,CAAC,CAAC;MACnD,IAAM/B,CAAC,GAAGtL,KAAK,CAAC+G,IAAI,CAACsE,oBAAoB,CAACoC,CAAC,EAAEF,EAAE,EAAEC,EAAE,CAAC;MACpD,IAAI,CAAClC,CAAC,EACF,MAAM,IAAIpJ,KAAK,CAAC,6CAA6C,CAAC;MAClEoJ,CAAC,CAACN,cAAc,CAAC,CAAC;MAClB,OAAOM,CAAC;IACZ;EAAC;EAAA,OAAAtL,KAAA;AAAA;AAwDLX,OAAO,CAACW,KAAK,GAAGA,KAAK;AACrBA,KAAK,CAAC+G,IAAI,GAAG,IAAI/G,KAAK,CAACC,KAAK,CAACc,EAAE,EAAEd,KAAK,CAACe,EAAE,CAAC;AAC1ChB,KAAK,CAACqF,IAAI,GAAG,IAAIrF,KAAK,CAACG,GAAG,EAAEA,GAAG,CAAC;AAChC,SAASuN,QAAQA,CAACR,CAAC,EAAE;EACjB,OAAOrF,MAAM,CAAC8F,QAAQ,CAACT,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,IAAI,GAAGA,CAAC,GAAGA,CAAC;AACxD;AACA,SAASU,WAAWA,CAACC,IAAI,EAAE;EACvB,IAAIA,IAAI,CAACvD,MAAM,GAAG,CAAC,IAAIuD,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;IACrC,MAAM,IAAI3L,KAAK,mCAAA0I,MAAA,CAAmCkD,UAAU,CAACD,IAAI,CAAC,CAAE,CAAC;EACzE;EACA,IAAMtB,GAAG,GAAGsB,IAAI,CAAC,CAAC,CAAC;EACnB,IAAME,GAAG,GAAGF,IAAI,CAAC/B,QAAQ,CAAC,CAAC,EAAES,GAAG,GAAG,CAAC,CAAC;EACrC,IAAI,CAACA,GAAG,IAAIwB,GAAG,CAACzD,MAAM,KAAKiC,GAAG,EAAE;IAC5B,MAAM,IAAIrK,KAAK,0CAA0C,CAAC;EAC9D;EACA,IAAI6L,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;IACnC,MAAM,IAAI7L,KAAK,CAAC,4CAA4C,CAAC;EACjE;EACA,OAAO;IAAE2L,IAAI,EAAEhC,aAAa,CAACkC,GAAG,CAAC;IAAE5C,IAAI,EAAE0C,IAAI,CAAC/B,QAAQ,CAACS,GAAG,GAAG,CAAC;EAAE,CAAC;AACrE;AACA,SAASyB,iBAAiBA,CAACH,IAAI,EAAE;EAC7B,IAAIA,IAAI,CAACvD,MAAM,GAAG,CAAC,IAAIuD,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;IACpC,MAAM,IAAI3L,KAAK,2BAAA0I,MAAA,CAA2BkD,UAAU,CAACD,IAAI,CAAC,CAAE,CAAC;EACjE;EACA,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAKA,IAAI,CAACvD,MAAM,GAAG,CAAC,EAAE;IAC7B,MAAM,IAAIpI,KAAK,CAAC,qCAAqC,CAAC;EAC1D;EACA,IAAA+L,YAAA,GAAkCL,WAAW,CAACC,IAAI,CAAC/B,QAAQ,CAAC,CAAC,CAAC,CAAC;IAAjD1G,CAAC,GAAA6I,YAAA,CAAPJ,IAAI;IAAWK,MAAM,GAAAD,YAAA,CAAZ9C,IAAI;EACrB,IAAAgD,aAAA,GAAsCP,WAAW,CAACM,MAAM,CAAC;IAA3ChB,CAAC,GAAAiB,aAAA,CAAPN,IAAI;IAAWO,UAAU,GAAAD,aAAA,CAAhBhD,IAAI;EACrB,IAAIiD,UAAU,CAAC9D,MAAM,EAAE;IACnB,MAAM,IAAIpI,KAAK,iDAAA0I,MAAA,CAAiDkD,UAAU,CAACM,UAAU,CAAC,CAAE,CAAC;EAC7F;EACA,OAAO;IAAEhJ,CAAC,EAADA,CAAC;IAAE8H,CAAC,EAADA;EAAE,CAAC;AACnB;AAAC,IACKnN,SAAS;EACX,SAAAA,UAAYqF,CAAC,EAAE8H,CAAC,EAAE;IAAAnO,eAAA,OAAAgB,SAAA;IACd,IAAI,CAACqF,CAAC,GAAGA,CAAC;IACV,IAAI,CAAC8H,CAAC,GAAGA,CAAC;IACV,IAAI,CAAClC,cAAc,CAAC,CAAC;EACzB;EAAClM,YAAA,CAAAiB,SAAA;IAAAyD,GAAA;IAAAlE,KAAA,EAqBD,SAAA0L,eAAA,EAAiB;MACb,IAAQ5F,CAAC,GAAQ,IAAI,CAAbA,CAAC;QAAE8H,CAAC,GAAK,IAAI,CAAVA,CAAC;MACZ,IAAI,CAACmB,kBAAkB,CAACjJ,CAAC,CAAC,EACtB,MAAM,IAAIlD,KAAK,CAAC,wCAAwC,CAAC;MAC7D,IAAI,CAACmM,kBAAkB,CAACnB,CAAC,CAAC,EACtB,MAAM,IAAIhL,KAAK,CAAC,wCAAwC,CAAC;IACjE;EAAC;IAAAsB,GAAA;IAAAlE,KAAA,EACD,SAAAgP,SAAA,EAAW;MACP,IAAMC,IAAI,GAAGtO,KAAK,CAACY,CAAC,IAAIR,GAAG;MAC3B,OAAO,IAAI,CAAC6M,CAAC,GAAGqB,IAAI;IACxB;EAAC;IAAA/K,GAAA;IAAAlE,KAAA,EACD,SAAAkP,WAAA,EAAa;MACT,OAAO,IAAI,CAACF,QAAQ,CAAC,CAAC,GAAG,IAAIvO,SAAS,CAAC,IAAI,CAACqF,CAAC,EAAEtD,GAAG,CAAC,CAAC,IAAI,CAACoL,CAAC,EAAEjN,KAAK,CAACY,CAAC,CAAC,CAAC,GAAG,IAAI;IAChF;EAAC;IAAA2C,GAAA;IAAAlE,KAAA,EACD,SAAAmP,cAAA,EAAgB;MACZ,OAAOjE,UAAU,CAAC,IAAI,CAACkE,QAAQ,CAAC,CAAC,CAAC;IACtC;EAAC;IAAAlL,GAAA;IAAAlE,KAAA,EACD,SAAAoP,SAAA,EAAW;MACP,IAAMC,IAAI,GAAGjB,QAAQ,CAACkB,mBAAmB,CAAC,IAAI,CAAC1B,CAAC,CAAC,CAAC;MAClD,IAAM2B,IAAI,GAAGnB,QAAQ,CAACkB,mBAAmB,CAAC,IAAI,CAACxJ,CAAC,CAAC,CAAC;MAClD,IAAM0J,KAAK,GAAGH,IAAI,CAACrE,MAAM,GAAG,CAAC;MAC7B,IAAMyE,KAAK,GAAGF,IAAI,CAACvE,MAAM,GAAG,CAAC;MAC7B,IAAM0E,IAAI,GAAGJ,mBAAmB,CAACE,KAAK,CAAC;MACvC,IAAMG,IAAI,GAAGL,mBAAmB,CAACG,KAAK,CAAC;MACvC,IAAMzE,MAAM,GAAGsE,mBAAmB,CAACG,KAAK,GAAGD,KAAK,GAAG,CAAC,CAAC;MACrD,YAAAlE,MAAA,CAAYN,MAAM,QAAAM,MAAA,CAAKqE,IAAI,EAAArE,MAAA,CAAGiE,IAAI,QAAAjE,MAAA,CAAKoE,IAAI,EAAApE,MAAA,CAAG+D,IAAI;IACtD;EAAC;IAAAnL,GAAA;IAAAlE,KAAA,EACD,SAAA6K,WAAA,EAAa;MACT,OAAO,IAAI,CAACsE,aAAa,CAAC,CAAC;IAC/B;EAAC;IAAAjL,GAAA;IAAAlE,KAAA,EACD,SAAAmL,MAAA,EAAQ;MACJ,OAAO,IAAI,CAACiE,QAAQ,CAAC,CAAC;IAC1B;EAAC;IAAAlL,GAAA;IAAAlE,KAAA,EACD,SAAA4P,kBAAA,EAAoB;MAChB,OAAO1E,UAAU,CAAC,IAAI,CAAC2E,YAAY,CAAC,CAAC,CAAC;IAC1C;EAAC;IAAA3L,GAAA;IAAAlE,KAAA,EACD,SAAA6P,aAAA,EAAe;MACX,OAAOzE,WAAW,CAAC,IAAI,CAACtF,CAAC,CAAC,GAAGsF,WAAW,CAAC,IAAI,CAACwC,CAAC,CAAC;IACpD;EAAC;IAAA1J,GAAA;IAAAlE,KAAA,EA1DD,SAAA8P,YAAmB/C,GAAG,EAAE;MACpB,IAAMgD,GAAG,GAAGhD,GAAG,YAAYiD,UAAU;MACrC,IAAMC,IAAI,GAAG,uBAAuB;MACpC,IAAI,OAAOlD,GAAG,KAAK,QAAQ,IAAI,CAACgD,GAAG,EAC/B,MAAM,IAAIhM,SAAS,IAAAuH,MAAA,CAAI2E,IAAI,oCAAiC,CAAC;MACjE,IAAMC,GAAG,GAAGH,GAAG,GAAGvB,UAAU,CAACzB,GAAG,CAAC,GAAGA,GAAG;MACvC,IAAImD,GAAG,CAAClF,MAAM,KAAK,GAAG,EAClB,MAAM,IAAIpI,KAAK,IAAA0I,MAAA,CAAI2E,IAAI,2BAAwB,CAAC;MACpD,OAAO,IAAIxP,SAAS,CAAC0P,WAAW,CAACD,GAAG,CAAC1E,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE2E,WAAW,CAACD,GAAG,CAAC1E,KAAK,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC;IACxF;EAAC;IAAAtH,GAAA;IAAAlE,KAAA,EACD,SAAAoQ,QAAerD,GAAG,EAAE;MAChB,IAAMgD,GAAG,GAAGhD,GAAG,YAAYiD,UAAU;MACrC,IAAI,OAAOjD,GAAG,KAAK,QAAQ,IAAI,CAACgD,GAAG,EAC/B,MAAM,IAAIhM,SAAS,mDAAmD,CAAC;MAC3E,IAAAsM,kBAAA,GAAiB3B,iBAAiB,CAACqB,GAAG,GAAGhD,GAAG,GAAG7B,UAAU,CAAC6B,GAAG,CAAC,CAAC;QAAvDjH,CAAC,GAAAuK,kBAAA,CAADvK,CAAC;QAAE8H,CAAC,GAAAyC,kBAAA,CAADzC,CAAC;MACZ,OAAO,IAAInN,SAAS,CAACqF,CAAC,EAAE8H,CAAC,CAAC;IAC9B;EAAC;IAAA1J,GAAA;IAAAlE,KAAA,EACD,SAAA8M,QAAeC,GAAG,EAAE;MAChB,OAAO,IAAI,CAACqD,OAAO,CAACrD,GAAG,CAAC;IAC5B;EAAC;EAAA,OAAAtM,SAAA;AAAA;AAyCLV,OAAO,CAACU,SAAS,GAAGA,SAAS;AAC7B,SAAS6P,WAAWA,CAAA,EAAY;EAAA,SAAAC,IAAA,GAAAxF,SAAA,CAAAC,MAAA,EAARwF,MAAM,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;IAANF,MAAM,CAAAE,IAAA,IAAA3F,SAAA,CAAA2F,IAAA;EAAA;EAC1B,IAAI,CAACF,MAAM,CAACG,KAAK,CAAC,UAACtP,CAAC;IAAA,OAAKA,CAAC,YAAY2O,UAAU;EAAA,EAAC,EAC7C,MAAM,IAAIpN,KAAK,CAAC,0BAA0B,CAAC;EAC/C,IAAI4N,MAAM,CAACxF,MAAM,KAAK,CAAC,EACnB,OAAOwF,MAAM,CAAC,CAAC,CAAC;EACpB,IAAMxF,MAAM,GAAGwF,MAAM,CAACI,MAAM,CAAC,UAACxP,CAAC,EAAE2O,GAAG;IAAA,OAAK3O,CAAC,GAAG2O,GAAG,CAAC/E,MAAM;EAAA,GAAE,CAAC,CAAC;EAC3D,IAAM6F,MAAM,GAAG,IAAIb,UAAU,CAAChF,MAAM,CAAC;EACrC,KAAK,IAAI5D,CAAC,GAAG,CAAC,EAAE0J,GAAG,GAAG,CAAC,EAAE1J,CAAC,GAAGoJ,MAAM,CAACxF,MAAM,EAAE5D,CAAC,EAAE,EAAE;IAC7C,IAAM2I,GAAG,GAAGS,MAAM,CAACpJ,CAAC,CAAC;IACrByJ,MAAM,CAAC9I,GAAG,CAACgI,GAAG,EAAEe,GAAG,CAAC;IACpBA,GAAG,IAAIf,GAAG,CAAC/E,MAAM;EACrB;EACA,OAAO6F,MAAM;AACjB;AACA,IAAME,KAAK,GAAGN,KAAK,CAACO,IAAI,CAAC;EAAEhG,MAAM,EAAE;AAAI,CAAC,EAAE,UAACiG,CAAC,EAAE7J,CAAC;EAAA,OAAKA,CAAC,CAAC8J,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;AAAA,EAAC;AACpF,SAAS3C,UAAUA,CAAC4C,MAAM,EAAE;EACxB,IAAI,EAAEA,MAAM,YAAYpB,UAAU,CAAC,EAC/B,MAAM,IAAIpN,KAAK,CAAC,qBAAqB,CAAC;EAC1C,IAAImK,GAAG,GAAG,EAAE;EACZ,KAAK,IAAI3F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgK,MAAM,CAACpG,MAAM,EAAE5D,CAAC,EAAE,EAAE;IACpC2F,GAAG,IAAIgE,KAAK,CAACK,MAAM,CAAChK,CAAC,CAAC,CAAC;EAC3B;EACA,OAAO2F,GAAG;AACd;AACA,IAAMsE,SAAS,GAAGvQ,MAAM,CAAC,qEAAqE,CAAC;AAC/F,SAASsK,WAAWA,CAACkG,GAAG,EAAE;EACtB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EACvB,MAAM,IAAI1O,KAAK,CAAC,iBAAiB,CAAC;EACtC,IAAI,EAAE/B,GAAG,IAAIyQ,GAAG,IAAIA,GAAG,GAAGD,SAAS,CAAC,EAChC,MAAM,IAAIzO,KAAK,CAAC,gCAAgC,CAAC;EACrD,OAAO0O,GAAG,CAACJ,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;AAC7C;AACA,SAASI,QAAQA,CAACD,GAAG,EAAE;EACnB,IAAMjQ,CAAC,GAAG6J,UAAU,CAACE,WAAW,CAACkG,GAAG,CAAC,CAAC;EACtC,IAAIjQ,CAAC,CAAC2J,MAAM,KAAK,EAAE,EACf,MAAM,IAAIpI,KAAK,CAAC,0BAA0B,CAAC;EAC/C,OAAOvB,CAAC;AACZ;AACA,SAASiO,mBAAmBA,CAACgC,GAAG,EAAE;EAC9B,IAAMvE,GAAG,GAAGuE,GAAG,CAACJ,QAAQ,CAAC,EAAE,CAAC;EAC5B,OAAOnE,GAAG,CAAC/B,MAAM,GAAG,CAAC,OAAAM,MAAA,CAAOyB,GAAG,IAAKA,GAAG;AAC3C;AACA,SAASoD,WAAWA,CAACpD,GAAG,EAAE;EACtB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IACzB,MAAM,IAAIhJ,SAAS,CAAC,oCAAoC,GAAG,OAAOgJ,GAAG,CAAC;EAC1E;EACA,OAAOjM,MAAM,MAAAwK,MAAA,CAAMyB,GAAG,CAAE,CAAC;AAC7B;AACA,SAAS7B,UAAUA,CAAC6B,GAAG,EAAE;EACrB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IACzB,MAAM,IAAIhJ,SAAS,CAAC,mCAAmC,GAAG,OAAOgJ,GAAG,CAAC;EACzE;EACA,IAAIA,GAAG,CAAC/B,MAAM,GAAG,CAAC,EACd,MAAM,IAAIpI,KAAK,CAAC,2CAA2C,GAAGmK,GAAG,CAAC/B,MAAM,CAAC;EAC7E,IAAMwG,KAAK,GAAG,IAAIxB,UAAU,CAACjD,GAAG,CAAC/B,MAAM,GAAG,CAAC,CAAC;EAC5C,KAAK,IAAI5D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoK,KAAK,CAACxG,MAAM,EAAE5D,CAAC,EAAE,EAAE;IACnC,IAAMqK,CAAC,GAAGrK,CAAC,GAAG,CAAC;IACf,IAAMsK,OAAO,GAAG3E,GAAG,CAACvB,KAAK,CAACiG,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;IACnC,IAAME,IAAI,GAAGpJ,MAAM,CAAC8F,QAAQ,CAACqD,OAAO,EAAE,EAAE,CAAC;IACzC,IAAInJ,MAAM,CAACqJ,KAAK,CAACD,IAAI,CAAC,IAAIA,IAAI,GAAG,CAAC,EAC9B,MAAM,IAAI/O,KAAK,CAAC,uBAAuB,CAAC;IAC5C4O,KAAK,CAACpK,CAAC,CAAC,GAAGuK,IAAI;EACnB;EACA,OAAOH,KAAK;AAChB;AACA,SAASjF,aAAaA,CAACF,KAAK,EAAE;EAC1B,OAAO8D,WAAW,CAAC3B,UAAU,CAACnC,KAAK,CAAC,CAAC;AACzC;AACA,SAASW,WAAWA,CAACD,GAAG,EAAE;EACtB,OAAOA,GAAG,YAAYiD,UAAU,GAAGA,UAAU,CAACgB,IAAI,CAACjE,GAAG,CAAC,GAAG7B,UAAU,CAAC6B,GAAG,CAAC;AAC7E;AACA,SAASxG,eAAeA,CAAC+K,GAAG,EAAE;EAC1B,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI/I,MAAM,CAACsJ,aAAa,CAACP,GAAG,CAAC,IAAIA,GAAG,GAAG,CAAC,EAC/D,OAAOxQ,MAAM,CAACwQ,GAAG,CAAC;EACtB,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIvC,kBAAkB,CAACuC,GAAG,CAAC,EAClD,OAAOA,GAAG;EACd,MAAM,IAAIvN,SAAS,CAAC,qDAAqD,CAAC;AAC9E;AACA,SAASvB,GAAGA,CAACpB,CAAC,EAAe;EAAA,IAAbC,CAAC,GAAA0J,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGpK,KAAK,CAACW,CAAC;EACvB,IAAMuP,MAAM,GAAGzP,CAAC,GAAGC,CAAC;EACpB,OAAOwP,MAAM,IAAIhQ,GAAG,GAAGgQ,MAAM,GAAGxP,CAAC,GAAGwP,MAAM;AAC9C;AACA,SAASiB,IAAIA,CAAC3O,CAAC,EAAE4O,KAAK,EAAE;EACpB,IAAQzQ,CAAC,GAAKX,KAAK,CAAXW,CAAC;EACT,IAAImN,GAAG,GAAGtL,CAAC;EACX,OAAO4O,KAAK,EAAE,GAAGlR,GAAG,EAAE;IAClB4N,GAAG,IAAIA,GAAG;IACVA,GAAG,IAAInN,CAAC;EACZ;EACA,OAAOmN,GAAG;AACd;AACA,SAAS/B,OAAOA,CAACvJ,CAAC,EAAE;EAChB,IAAQ7B,CAAC,GAAKX,KAAK,CAAXW,CAAC;EACT,IAAM0Q,GAAG,GAAGlR,MAAM,CAAC,CAAC,CAAC;EACrB,IAAMmR,IAAI,GAAGnR,MAAM,CAAC,EAAE,CAAC;EACvB,IAAMoR,IAAI,GAAGpR,MAAM,CAAC,EAAE,CAAC;EACvB,IAAMqR,IAAI,GAAGrR,MAAM,CAAC,EAAE,CAAC;EACvB,IAAMsR,IAAI,GAAGtR,MAAM,CAAC,EAAE,CAAC;EACvB,IAAMuR,IAAI,GAAGvR,MAAM,CAAC,EAAE,CAAC;EACvB,IAAMqB,EAAE,GAAIgB,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAI7B,CAAC;EAC1B,IAAMgR,EAAE,GAAInQ,EAAE,GAAGA,EAAE,GAAGgB,CAAC,GAAI7B,CAAC;EAC5B,IAAMiR,EAAE,GAAIT,IAAI,CAACQ,EAAE,EAAErR,GAAG,CAAC,GAAGqR,EAAE,GAAIhR,CAAC;EACnC,IAAMkR,EAAE,GAAIV,IAAI,CAACS,EAAE,EAAEtR,GAAG,CAAC,GAAGqR,EAAE,GAAIhR,CAAC;EACnC,IAAMmR,GAAG,GAAIX,IAAI,CAACU,EAAE,EAAExR,GAAG,CAAC,GAAGmB,EAAE,GAAIb,CAAC;EACpC,IAAMoR,GAAG,GAAIZ,IAAI,CAACW,GAAG,EAAER,IAAI,CAAC,GAAGQ,GAAG,GAAInR,CAAC;EACvC,IAAMqR,GAAG,GAAIb,IAAI,CAACY,GAAG,EAAER,IAAI,CAAC,GAAGQ,GAAG,GAAIpR,CAAC;EACvC,IAAMsR,GAAG,GAAId,IAAI,CAACa,GAAG,EAAEP,IAAI,CAAC,GAAGO,GAAG,GAAIrR,CAAC;EACvC,IAAMuR,IAAI,GAAIf,IAAI,CAACc,GAAG,EAAEP,IAAI,CAAC,GAAGO,GAAG,GAAItR,CAAC;EACxC,IAAMwR,IAAI,GAAIhB,IAAI,CAACe,IAAI,EAAET,IAAI,CAAC,GAAGO,GAAG,GAAIrR,CAAC;EACzC,IAAMyR,IAAI,GAAIjB,IAAI,CAACgB,IAAI,EAAE7R,GAAG,CAAC,GAAGqR,EAAE,GAAIhR,CAAC;EACvC,IAAM0R,EAAE,GAAIlB,IAAI,CAACiB,IAAI,EAAEZ,IAAI,CAAC,GAAGO,GAAG,GAAIpR,CAAC;EACvC,IAAM2R,EAAE,GAAInB,IAAI,CAACkB,EAAE,EAAEhB,GAAG,CAAC,GAAG7P,EAAE,GAAIb,CAAC;EACnC,IAAM4R,EAAE,GAAGpB,IAAI,CAACmB,EAAE,EAAEjS,GAAG,CAAC;EACxB,IAAMmS,EAAE,GAAID,EAAE,GAAGA,EAAE,GAAI5R,CAAC;EACxB,IAAI6R,EAAE,KAAKhQ,CAAC,EACR,MAAM,IAAIP,KAAK,CAAC,yBAAyB,CAAC;EAC9C,OAAOsQ,EAAE;AACb;AACA,SAASxJ,MAAMA,CAAC0J,MAAM,EAAoB;EAAA,IAAlBC,MAAM,GAAAtI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGpK,KAAK,CAACW,CAAC;EACpC,IAAI8R,MAAM,KAAKvS,GAAG,IAAIwS,MAAM,IAAIxS,GAAG,EAAE;IACjC,MAAM,IAAI+B,KAAK,8CAAA0I,MAAA,CAA8C8H,MAAM,WAAA9H,MAAA,CAAQ+H,MAAM,CAAE,CAAC;EACxF;EACA,IAAIjS,CAAC,GAAGoB,GAAG,CAAC4Q,MAAM,EAAEC,MAAM,CAAC;EAC3B,IAAIhS,CAAC,GAAGgS,MAAM;EACd,IAAIlQ,CAAC,GAAGtC,GAAG;IAAEmD,CAAC,GAAGjD,GAAG;IAAEuS,CAAC,GAAGvS,GAAG;IAAEkQ,CAAC,GAAGpQ,GAAG;EACtC,OAAOO,CAAC,KAAKP,GAAG,EAAE;IACd,IAAM0S,CAAC,GAAGlS,CAAC,GAAGD,CAAC;IACf,IAAM0E,CAAC,GAAGzE,CAAC,GAAGD,CAAC;IACf,IAAMoS,CAAC,GAAGrQ,CAAC,GAAGmQ,CAAC,GAAGC,CAAC;IACnB,IAAMhS,CAAC,GAAGyC,CAAC,GAAGiN,CAAC,GAAGsC,CAAC;IACnBlS,CAAC,GAAGD,CAAC,EAAEA,CAAC,GAAG0E,CAAC,EAAE3C,CAAC,GAAGmQ,CAAC,EAAEtP,CAAC,GAAGiN,CAAC,EAAEqC,CAAC,GAAGE,CAAC,EAAEvC,CAAC,GAAG1P,CAAC;EAC5C;EACA,IAAMkS,GAAG,GAAGpS,CAAC;EACb,IAAIoS,GAAG,KAAK1S,GAAG,EACX,MAAM,IAAI6B,KAAK,CAAC,wBAAwB,CAAC;EAC7C,OAAOJ,GAAG,CAACW,CAAC,EAAEkQ,MAAM,CAAC;AACzB;AACA,SAASjJ,WAAWA,CAACsJ,IAAI,EAAe;EAAA,IAAblN,CAAC,GAAAuE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGpK,KAAK,CAACW,CAAC;EAClC,IAAMqS,OAAO,GAAG,IAAIlD,KAAK,CAACiD,IAAI,CAAC1I,MAAM,CAAC;EACtC,IAAM4I,cAAc,GAAGF,IAAI,CAAC9C,MAAM,CAAC,UAACiD,GAAG,EAAEvC,GAAG,EAAElK,CAAC,EAAK;IAChD,IAAIkK,GAAG,KAAKzQ,GAAG,EACX,OAAOgT,GAAG;IACdF,OAAO,CAACvM,CAAC,CAAC,GAAGyM,GAAG;IAChB,OAAOrR,GAAG,CAACqR,GAAG,GAAGvC,GAAG,EAAE9K,CAAC,CAAC;EAC5B,CAAC,EAAEzF,GAAG,CAAC;EACP,IAAM+S,QAAQ,GAAGpK,MAAM,CAACkK,cAAc,EAAEpN,CAAC,CAAC;EAC1CkN,IAAI,CAACK,WAAW,CAAC,UAACF,GAAG,EAAEvC,GAAG,EAAElK,CAAC,EAAK;IAC9B,IAAIkK,GAAG,KAAKzQ,GAAG,EACX,OAAOgT,GAAG;IACdF,OAAO,CAACvM,CAAC,CAAC,GAAG5E,GAAG,CAACqR,GAAG,GAAGF,OAAO,CAACvM,CAAC,CAAC,EAAEZ,CAAC,CAAC;IACrC,OAAOhE,GAAG,CAACqR,GAAG,GAAGvC,GAAG,EAAE9K,CAAC,CAAC;EAC5B,CAAC,EAAEsN,QAAQ,CAAC;EACZ,OAAOH,OAAO;AAClB;AACA,SAASK,UAAUA,CAAC3H,KAAK,EAAE;EACvB,IAAM4H,KAAK,GAAG5H,KAAK,CAACrB,MAAM,GAAG,CAAC,GAAGlI,QAAQ,GAAG,CAAC;EAC7C,IAAMwO,GAAG,GAAG/E,aAAa,CAACF,KAAK,CAAC;EAChC,OAAO4H,KAAK,GAAG,CAAC,GAAG3C,GAAG,IAAIxQ,MAAM,CAACmT,KAAK,CAAC,GAAG3C,GAAG;AACjD;AACA,SAASxD,YAAYA,CAACoG,IAAI,EAAwB;EAAA,IAAtBC,YAAY,GAAApJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAC5C,IAAMvJ,CAAC,GAAGwS,UAAU,CAACE,IAAI,CAAC;EAC1B,IAAIC,YAAY,EACZ,OAAO3S,CAAC;EACZ,IAAQD,CAAC,GAAKZ,KAAK,CAAXY,CAAC;EACT,OAAOC,CAAC,IAAID,CAAC,GAAGC,CAAC,GAAGD,CAAC,GAAGC,CAAC;AAC7B;AACA,IAAI4S,WAAW;AACf,IAAIC,eAAe;AAAC,IACdC,QAAQ;EACV,SAAAA,SAAYvR,OAAO,EAAEwR,QAAQ,EAAE;IAAA9U,eAAA,OAAA6U,QAAA;IAC3B,IAAI,CAACvR,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACwR,QAAQ,GAAGA,QAAQ;IACxB,IAAI,OAAOxR,OAAO,KAAK,QAAQ,IAAIA,OAAO,GAAG,CAAC,EAC1C,MAAM,IAAIH,KAAK,CAAC,0BAA0B,CAAC;IAC/C,IAAI,OAAO2R,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,GAAG,CAAC,EAC5C,MAAM,IAAI3R,KAAK,CAAC,2BAA2B,CAAC;IAChD,IAAI,CAACqO,CAAC,GAAG,IAAIjB,UAAU,CAACjN,OAAO,CAAC,CAACyR,IAAI,CAAC,CAAC,CAAC;IACxC,IAAI,CAACzS,CAAC,GAAG,IAAIiO,UAAU,CAACjN,OAAO,CAAC,CAACyR,IAAI,CAAC,CAAC,CAAC;IACxC,IAAI,CAACC,OAAO,GAAG,CAAC;EACpB;EAACjV,YAAA,CAAA8U,QAAA;IAAApQ,GAAA;IAAAlE,KAAA,EACD,SAAA0U,KAAA,EAAgB;MAAA,IAAAC,cAAA;MAAA,SAAAC,KAAA,GAAA7J,SAAA,CAAAC,MAAA,EAAR6J,MAAM,OAAApE,KAAA,CAAAmE,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;QAAND,MAAM,CAAAC,KAAA,IAAA/J,SAAA,CAAA+J,KAAA;MAAA;MACV,OAAO,CAAAH,cAAA,GAAA5U,OAAO,CAACE,KAAK,EAAC8U,UAAU,CAAAC,KAAA,CAAAL,cAAA,GAAC,IAAI,CAAC5S,CAAC,EAAAuJ,MAAA,CAAKuJ,MAAM,EAAC;IACtD;EAAC;IAAA3Q,GAAA;IAAAlE,KAAA,EACD,SAAAiV,SAAA,EAAoB;MAAA,SAAAC,KAAA,GAAAnK,SAAA,CAAAC,MAAA,EAAR6J,MAAM,OAAApE,KAAA,CAAAyE,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAANN,MAAM,CAAAM,KAAA,IAAApK,SAAA,CAAAoK,KAAA;MAAA;MACd,OAAOd,eAAe,CAAAW,KAAA,UAAC,IAAI,CAACjT,CAAC,EAAAuJ,MAAA,CAAKuJ,MAAM,EAAC;IAC7C;EAAC;IAAA3Q,GAAA;IAAAlE,KAAA,EACD,SAAAoV,UAAA,EAAY;MACR,IAAI,OAAOf,eAAe,KAAK,UAAU,EACrC,MAAM,IAAI9Q,QAAQ,CAAC,gCAAgC,CAAC;IAC5D;EAAC;IAAAW,GAAA;IAAAlE,KAAA,EACD,SAAAqV,KAAA,EAAO;MACH,IAAI,IAAI,CAACZ,OAAO,IAAI,IAAI,EACpB,MAAM,IAAI7R,KAAK,CAAC,mDAAmD,CAAC;MACxE,IAAI,CAAC6R,OAAO,IAAI,CAAC;IACrB;EAAC;IAAAvQ,GAAA;IAAAlE,KAAA;MAAA,IAAAsV,OAAA,GAAA/V,iBAAA,eAAAD,mBAAA,GAAAiW,IAAA,CACD,SAAAC,QAAA;QAAA,IAAAC,IAAA;UAAAC,KAAA,GAAA3K,SAAA;QAAA,OAAAzL,mBAAA,GAAAqW,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cAAaN,IAAI,GAAAC,KAAA,CAAA1K,MAAA,QAAA0K,KAAA,QAAAzK,SAAA,GAAAyK,KAAA,MAAG,IAAI1F,UAAU,CAAC,CAAC;cAAA6F,QAAA,CAAAE,IAAA;cAAA,OACjB,IAAI,CAACrB,IAAI,CAAC,IAAI,CAACzD,CAAC,EAAEjB,UAAU,CAACgB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAEyE,IAAI,CAAC;YAAA;cAA/D,IAAI,CAAC1T,CAAC,GAAA8T,QAAA,CAAAG,IAAA;cAAAH,QAAA,CAAAE,IAAA;cAAA,OACS,IAAI,CAACrB,IAAI,CAAC,IAAI,CAACzD,CAAC,CAAC;YAAA;cAAhC,IAAI,CAACA,CAAC,GAAA4E,QAAA,CAAAG,IAAA;cAAA,MACFP,IAAI,CAACzK,MAAM,KAAK,CAAC;gBAAA6K,QAAA,CAAAE,IAAA;gBAAA;cAAA;cAAA,OAAAF,QAAA,CAAAI,MAAA;YAAA;cAAAJ,QAAA,CAAAE,IAAA;cAAA,OAEN,IAAI,CAACrB,IAAI,CAAC,IAAI,CAACzD,CAAC,EAAEjB,UAAU,CAACgB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAEyE,IAAI,CAAC;YAAA;cAA/D,IAAI,CAAC1T,CAAC,GAAA8T,QAAA,CAAAG,IAAA;cAAAH,QAAA,CAAAE,IAAA;cAAA,OACS,IAAI,CAACrB,IAAI,CAAC,IAAI,CAACzD,CAAC,CAAC;YAAA;cAAhC,IAAI,CAACA,CAAC,GAAA4E,QAAA,CAAAG,IAAA;YAAA;YAAA;cAAA,OAAAH,QAAA,CAAAK,IAAA;UAAA;QAAA,GAAAV,OAAA;MAAA,CACT;MAAA,SAAAW,OAAA;QAAA,OAAAb,OAAA,CAAAN,KAAA,OAAAjK,SAAA;MAAA;MAAA,OAAAoL,MAAA;IAAA;EAAA;IAAAjS,GAAA;IAAAlE,KAAA,EACD,SAAAoW,WAAA,EAAoC;MAAA,IAAzBX,IAAI,GAAA1K,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAIiF,UAAU,CAAC,CAAC;MAC9B,IAAI,CAACoF,SAAS,CAAC,CAAC;MAChB,IAAI,CAACrT,CAAC,GAAG,IAAI,CAACkT,QAAQ,CAAC,IAAI,CAAChE,CAAC,EAAEjB,UAAU,CAACgB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAEyE,IAAI,CAAC;MAC7D,IAAI,CAACxE,CAAC,GAAG,IAAI,CAACgE,QAAQ,CAAC,IAAI,CAAChE,CAAC,CAAC;MAC9B,IAAIwE,IAAI,CAACzK,MAAM,KAAK,CAAC,EACjB;MACJ,IAAI,CAACjJ,CAAC,GAAG,IAAI,CAACkT,QAAQ,CAAC,IAAI,CAAChE,CAAC,EAAEjB,UAAU,CAACgB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAEyE,IAAI,CAAC;MAC7D,IAAI,CAACxE,CAAC,GAAG,IAAI,CAACgE,QAAQ,CAAC,IAAI,CAAChE,CAAC,CAAC;IAClC;EAAC;IAAA/M,GAAA;IAAAlE,KAAA;MAAA,IAAAqW,SAAA,GAAA9W,iBAAA,eAAAD,mBAAA,GAAAiW,IAAA,CACD,SAAAe,SAAA;QAAA,IAAArJ,GAAA,EAAAsJ,GAAA,EAAAC,EAAA;QAAA,OAAAlX,mBAAA,GAAAqW,IAAA,UAAAc,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAZ,IAAA,GAAAY,SAAA,CAAAX,IAAA;YAAA;cACI,IAAI,CAACV,IAAI,CAAC,CAAC;cACPpI,GAAG,GAAG,CAAC;cACLsJ,GAAG,GAAG,EAAE;YAAA;cAAA,MACPtJ,GAAG,GAAG,IAAI,CAACsH,QAAQ;gBAAAmC,SAAA,CAAAX,IAAA;gBAAA;cAAA;cAAAW,SAAA,CAAAX,IAAA;cAAA,OACP,IAAI,CAACrB,IAAI,CAAC,IAAI,CAACzD,CAAC,CAAC;YAAA;cAAhC,IAAI,CAACA,CAAC,GAAAyF,SAAA,CAAAV,IAAA;cACAQ,EAAE,GAAG,IAAI,CAACvF,CAAC,CAACzF,KAAK,CAAC,CAAC;cACzB+K,GAAG,CAACpP,IAAI,CAACqP,EAAE,CAAC;cACZvJ,GAAG,IAAI,IAAI,CAACgE,CAAC,CAACjG,MAAM;cAAC0L,SAAA,CAAAX,IAAA;cAAA;YAAA;cAAA,OAAAW,SAAA,CAAAT,MAAA,WAElB3F,WAAW,CAAA0E,KAAA,SAAIuB,GAAG,CAAC;YAAA;YAAA;cAAA,OAAAG,SAAA,CAAAR,IAAA;UAAA;QAAA,GAAAI,QAAA;MAAA,CAC7B;MAAA,SAAAK,SAAA;QAAA,OAAAN,SAAA,CAAArB,KAAA,OAAAjK,SAAA;MAAA;MAAA,OAAA4L,QAAA;IAAA;EAAA;IAAAzS,GAAA;IAAAlE,KAAA,EACD,SAAA4W,aAAA,EAAe;MACX,IAAI,CAACxB,SAAS,CAAC,CAAC;MAChB,IAAI,CAACC,IAAI,CAAC,CAAC;MACX,IAAIpI,GAAG,GAAG,CAAC;MACX,IAAMsJ,GAAG,GAAG,EAAE;MACd,OAAOtJ,GAAG,GAAG,IAAI,CAACsH,QAAQ,EAAE;QACxB,IAAI,CAACtD,CAAC,GAAG,IAAI,CAACgE,QAAQ,CAAC,IAAI,CAAChE,CAAC,CAAC;QAC9B,IAAMuF,EAAE,GAAG,IAAI,CAACvF,CAAC,CAACzF,KAAK,CAAC,CAAC;QACzB+K,GAAG,CAACpP,IAAI,CAACqP,EAAE,CAAC;QACZvJ,GAAG,IAAI,IAAI,CAACgE,CAAC,CAACjG,MAAM;MACxB;MACA,OAAOsF,WAAW,CAAA0E,KAAA,SAAIuB,GAAG,CAAC;IAC9B;EAAC;EAAA,OAAAjC,QAAA;AAAA;AAEL,SAASvF,kBAAkBA,CAACuC,GAAG,EAAE;EAC7B,OAAOzQ,GAAG,GAAGyQ,GAAG,IAAIA,GAAG,GAAG3Q,KAAK,CAACY,CAAC;AACrC;AACA,SAASqK,mBAAmBA,CAAC0F,GAAG,EAAE;EAC9B,OAAOzQ,GAAG,GAAGyQ,GAAG,IAAIA,GAAG,GAAG3Q,KAAK,CAACW,CAAC;AACrC;AACA,SAASuV,QAAQA,CAACC,MAAM,EAAEtD,CAAC,EAAE/M,CAAC,EAAe;EAAA,IAAbsQ,IAAI,GAAAhM,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EACvC,IAAQxJ,CAAC,GAAKZ,KAAK,CAAXY,CAAC;EACT,IAAMQ,CAAC,GAAG+L,YAAY,CAACgJ,MAAM,EAAE,IAAI,CAAC;EACpC,IAAI,CAAC/H,kBAAkB,CAAChN,CAAC,CAAC,EACtB;EACJ,IAAMiV,IAAI,GAAGtN,MAAM,CAAC3H,CAAC,EAAER,CAAC,CAAC;EACzB,IAAMgS,CAAC,GAAG7S,KAAK,CAAC+G,IAAI,CAACqB,QAAQ,CAAC/G,CAAC,CAAC;EAChC,IAAM+D,CAAC,GAAGtD,GAAG,CAAC+Q,CAAC,CAACpQ,CAAC,EAAE5B,CAAC,CAAC;EACrB,IAAIuE,CAAC,KAAKjF,GAAG,EACT;EACJ,IAAM+M,CAAC,GAAGpL,GAAG,CAACwU,IAAI,GAAGxU,GAAG,CAACgR,CAAC,GAAG/M,CAAC,GAAGX,CAAC,EAAEvE,CAAC,CAAC,EAAEA,CAAC,CAAC;EAC1C,IAAIqM,CAAC,KAAK/M,GAAG,EACT;EACJ,IAAIoW,GAAG,GAAG,IAAIxW,SAAS,CAACqF,CAAC,EAAE8H,CAAC,CAAC;EAC7B,IAAIH,QAAQ,GAAG,CAAC8F,CAAC,CAACpQ,CAAC,KAAK8T,GAAG,CAACnR,CAAC,GAAG,CAAC,GAAG,CAAC,IAAIyC,MAAM,CAACgL,CAAC,CAACvP,CAAC,GAAGjD,GAAG,CAAC;EAC1D,IAAIgW,IAAI,IAAIE,GAAG,CAACjI,QAAQ,CAAC,CAAC,EAAE;IACxBiI,GAAG,GAAGA,GAAG,CAAC/H,UAAU,CAAC,CAAC;IACtBzB,QAAQ,IAAI,CAAC;EACjB;EACA,OAAO;IAAEwJ,GAAG,EAAHA,GAAG;IAAExJ,QAAQ,EAARA;EAAS,CAAC;AAC5B;AACA,SAASJ,mBAAmBA,CAACnJ,GAAG,EAAE;EAC9B,IAAIoN,GAAG;EACP,IAAI,OAAOpN,GAAG,KAAK,QAAQ,EAAE;IACzBoN,GAAG,GAAGpN,GAAG;EACb,CAAC,MACI,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIqE,MAAM,CAACsJ,aAAa,CAAC3N,GAAG,CAAC,IAAIA,GAAG,GAAG,CAAC,EAAE;IACtEoN,GAAG,GAAGxQ,MAAM,CAACoD,GAAG,CAAC;EACrB,CAAC,MACI,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC9B,IAAIA,GAAG,CAAC8G,MAAM,KAAK,CAAC,GAAGlI,QAAQ,EAC3B,MAAM,IAAIF,KAAK,CAAC,kCAAkC,CAAC;IACvD0O,GAAG,GAAGnB,WAAW,CAACjM,GAAG,CAAC;EAC1B,CAAC,MACI,IAAIA,GAAG,YAAY8L,UAAU,EAAE;IAChC,IAAI9L,GAAG,CAAC8G,MAAM,KAAKlI,QAAQ,EACvB,MAAM,IAAIF,KAAK,CAAC,kCAAkC,CAAC;IACvD0O,GAAG,GAAG/E,aAAa,CAACrI,GAAG,CAAC;EAC5B,CAAC,MACI;IACD,MAAM,IAAIH,SAAS,CAAC,4BAA4B,CAAC;EACrD;EACA,IAAI,CAACgL,kBAAkB,CAACuC,GAAG,CAAC,EACxB,MAAM,IAAI1O,KAAK,CAAC,mCAAmC,CAAC;EACxD,OAAO0O,GAAG;AACd;AACA,SAAS4F,kBAAkBA,CAACC,SAAS,EAAE;EACnC,IAAIA,SAAS,YAAYzW,KAAK,EAAE;IAC5ByW,SAAS,CAACzL,cAAc,CAAC,CAAC;IAC1B,OAAOyL,SAAS;EACpB,CAAC,MACI;IACD,OAAOzW,KAAK,CAACoM,OAAO,CAACqK,SAAS,CAAC;EACnC;AACJ;AACA,SAASxJ,kBAAkBA,CAACH,SAAS,EAAE;EACnC,IAAIA,SAAS,YAAY/M,SAAS,EAAE;IAChC+M,SAAS,CAAC9B,cAAc,CAAC,CAAC;IAC1B,OAAO8B,SAAS;EACpB;EACA,IAAI;IACA,OAAO/M,SAAS,CAAC2P,OAAO,CAAC5C,SAAS,CAAC;EACvC,CAAC,CACD,OAAO4J,KAAK,EAAE;IACV,OAAO3W,SAAS,CAACqP,WAAW,CAACtC,SAAS,CAAC;EAC3C;AACJ;AACA,SAAShN,YAAYA,CAAC4M,UAAU,EAAwB;EAAA,IAAtBtC,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAClD,OAAOrK,KAAK,CAACyM,cAAc,CAACC,UAAU,CAAC,CAACvC,UAAU,CAACC,YAAY,CAAC;AACpE;AACA/K,OAAO,CAACS,YAAY,GAAGA,YAAY;AACnC,SAASD,gBAAgBA,CAACgN,OAAO,EAAEC,SAAS,EAAEC,QAAQ,EAAwB;EAAA,IAAtB3C,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACxE,OAAOrK,KAAK,CAAC4M,aAAa,CAACC,OAAO,EAAEC,SAAS,EAAEC,QAAQ,CAAC,CAAC5C,UAAU,CAACC,YAAY,CAAC;AACrF;AACA/K,OAAO,CAACQ,gBAAgB,GAAGA,gBAAgB;AAC3C,SAAS8W,SAASA,CAAC9M,IAAI,EAAE;EACrB,IAAMwF,GAAG,GAAGxF,IAAI,YAAYyF,UAAU;EACtC,IAAME,GAAG,GAAG,OAAO3F,IAAI,KAAK,QAAQ;EACpC,IAAM0C,GAAG,GAAG,CAAC8C,GAAG,IAAIG,GAAG,KAAK3F,IAAI,CAACS,MAAM;EACvC,IAAI+E,GAAG,EACH,OAAO9C,GAAG,KAAKjK,aAAa,IAAIiK,GAAG,KAAKhK,eAAe;EAC3D,IAAIiN,GAAG,EACH,OAAOjD,GAAG,KAAKjK,aAAa,GAAG,CAAC,IAAIiK,GAAG,KAAKhK,eAAe,GAAG,CAAC;EACnE,IAAIsH,IAAI,YAAY7J,KAAK,EACrB,OAAO,IAAI;EACf,OAAO,KAAK;AAChB;AACA,SAASJ,eAAeA,CAACgX,QAAQ,EAAEC,OAAO,EAAwB;EAAA,IAAtBzM,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAC5D,IAAIsM,SAAS,CAACC,QAAQ,CAAC,EACnB,MAAM,IAAIvT,SAAS,CAAC,gDAAgD,CAAC;EACzE,IAAI,CAACsT,SAAS,CAACE,OAAO,CAAC,EACnB,MAAM,IAAIxT,SAAS,CAAC,gDAAgD,CAAC;EACzE,IAAM1C,CAAC,GAAG6V,kBAAkB,CAACK,OAAO,CAAC;EACrClW,CAAC,CAACqK,cAAc,CAAC,CAAC;EAClB,OAAOrK,CAAC,CAACyH,QAAQ,CAACuE,mBAAmB,CAACiK,QAAQ,CAAC,CAAC,CAACzM,UAAU,CAACC,YAAY,CAAC;AAC7E;AACA/K,OAAO,CAACO,eAAe,GAAGA,eAAe;AACzC,SAASkX,QAAQA,CAACnL,KAAK,EAAE;EACrB,IAAMb,KAAK,GAAGa,KAAK,CAACrB,MAAM,GAAGnI,QAAQ,GAAGwJ,KAAK,CAACb,KAAK,CAAC,CAAC,EAAE3I,QAAQ,CAAC,GAAGwJ,KAAK;EACxE,OAAOE,aAAa,CAACf,KAAK,CAAC;AAC/B;AACA,SAASiM,WAAWA,CAACpL,KAAK,EAAE;EACxB,IAAMqL,EAAE,GAAGF,QAAQ,CAACnL,KAAK,CAAC;EAC1B,IAAMsL,EAAE,GAAGnV,GAAG,CAACkV,EAAE,EAAE/W,KAAK,CAACY,CAAC,CAAC;EAC3B,OAAOqW,UAAU,CAACD,EAAE,GAAG9W,GAAG,GAAG6W,EAAE,GAAGC,EAAE,CAAC;AACzC;AACA,SAASC,UAAUA,CAACtG,GAAG,EAAE;EACrB,OAAOC,QAAQ,CAACD,GAAG,CAAC;AACxB;AACA,SAASuG,WAAWA,CAACtK,OAAO,EAAEH,UAAU,EAAE0K,YAAY,EAAE;EACpD,IAAIvK,OAAO,IAAI,IAAI,EACf,MAAM,IAAI3K,KAAK,6CAAA0I,MAAA,CAA4CiC,OAAO,OAAG,CAAC;EAC1E,IAAMwK,EAAE,GAAG/K,WAAW,CAACO,OAAO,CAAC;EAC/B,IAAM9G,CAAC,GAAG4G,mBAAmB,CAACD,UAAU,CAAC;EACzC,IAAM4K,QAAQ,GAAG,CAACJ,UAAU,CAACnR,CAAC,CAAC,EAAEgR,WAAW,CAACM,EAAE,CAAC,CAAC;EACjD,IAAID,YAAY,IAAI,IAAI,EAAE;IACtB,IAAIA,YAAY,KAAK,IAAI,EACrBA,YAAY,GAAG/X,OAAO,CAACE,KAAK,CAACgY,WAAW,CAACpV,QAAQ,CAAC;IACtD,IAAMqV,CAAC,GAAGlL,WAAW,CAAC8K,YAAY,CAAC;IACnC,IAAII,CAAC,CAAClN,MAAM,KAAKnI,QAAQ,EACrB,MAAM,IAAID,KAAK,mBAAA0I,MAAA,CAAmBzI,QAAQ,yBAAsB,CAAC;IACrEmV,QAAQ,CAAC7Q,IAAI,CAAC+Q,CAAC,CAAC;EACpB;EACA,IAAMzC,IAAI,GAAGnF,WAAW,CAAA0E,KAAA,SAAIgD,QAAQ,CAAC;EACrC,IAAMxE,CAAC,GAAGgE,QAAQ,CAACO,EAAE,CAAC;EACtB,OAAO;IAAEtC,IAAI,EAAJA,IAAI;IAAEjC,CAAC,EAADA,CAAC;IAAE/M,CAAC,EAADA;EAAE,CAAC;AACzB;AACA,SAAS0R,WAAWA,CAACC,MAAM,EAAEC,IAAI,EAAE;EAC/B,IAAQpB,GAAG,GAAemB,MAAM,CAAxBnB,GAAG;IAAExJ,QAAQ,GAAK2K,MAAM,CAAnB3K,QAAQ;EACrB,IAAA6K,cAAA,GAA2BzY,MAAM,CAAC0Y,MAAM,CAAC;MAAEC,SAAS,EAAE,IAAI;MAAEC,GAAG,EAAE;IAAK,CAAC,EAAEJ,IAAI,CAAC;IAAtEI,GAAG,GAAAH,cAAA,CAAHG,GAAG;IAAEC,SAAS,GAAAJ,cAAA,CAATI,SAAS;EACtB,IAAMC,MAAM,GAAGF,GAAG,GAAGxB,GAAG,CAAC9H,aAAa,CAAC,CAAC,GAAG8H,GAAG,CAACrH,iBAAiB,CAAC,CAAC;EAClE,OAAO8I,SAAS,GAAG,CAACC,MAAM,EAAElL,QAAQ,CAAC,GAAGkL,MAAM;AAClD;AAAC,SACctY,IAAIA,CAAAuY,EAAA,EAAAC,GAAA;EAAA,OAAAC,KAAA,CAAA9D,KAAA,OAAAjK,SAAA;AAAA;AAAA,SAAA+N,MAAA;EAAAA,KAAA,GAAAvZ,iBAAA,eAAAD,mBAAA,GAAAiW,IAAA,CAAnB,SAAAwD,SAAoBxL,OAAO,EAAEyL,OAAO;IAAA,IAAAX,IAAA;MAAAY,aAAA;MAAAxD,IAAA;MAAAjC,CAAA;MAAA/M,CAAA;MAAAyS,IAAA;MAAAjC,GAAA;MAAAkC,MAAA,GAAApO,SAAA;IAAA,OAAAzL,mBAAA,GAAAqW,IAAA,UAAAyD,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAvD,IAAA,GAAAuD,SAAA,CAAAtD,IAAA;QAAA;UAAEsC,IAAI,GAAAc,MAAA,CAAAnO,MAAA,QAAAmO,MAAA,QAAAlO,SAAA,GAAAkO,MAAA,MAAG,CAAC,CAAC;UAAAF,aAAA,GACpBpB,WAAW,CAACtK,OAAO,EAAEyL,OAAO,EAAEX,IAAI,CAACP,YAAY,CAAC,EAA/DrC,IAAI,GAAAwD,aAAA,CAAJxD,IAAI,EAAEjC,CAAC,GAAAyF,aAAA,CAADzF,CAAC,EAAE/M,CAAC,GAAAwS,aAAA,CAADxS,CAAC;UACZyS,IAAI,GAAG,IAAI5E,QAAQ,CAACvR,OAAO,EAAED,QAAQ,CAAC;UAAAuW,SAAA,CAAAtD,IAAA;UAAA,OACtCmD,IAAI,CAAC/C,MAAM,CAACV,IAAI,CAAC;QAAA;UAAA4D,SAAA,CAAAC,EAAA,GAERzC,QAAQ;UAAAwC,SAAA,CAAAtD,IAAA;UAAA,OAAOmD,IAAI,CAACvC,QAAQ,CAAC,CAAC;QAAA;UAAA0C,SAAA,CAAArG,EAAA,GAAAqG,SAAA,CAAArD,IAAA;UAAAqD,SAAA,CAAApG,EAAA,GAAEO,CAAC;UAAA6F,SAAA,CAAAE,EAAA,GAAE9S,CAAC;UAAA4S,SAAA,CAAAG,EAAA,GAAEnB,IAAI,CAACG,SAAS;UAAA,IAA1DvB,GAAG,OAAAoC,SAAA,CAAAC,EAAA,EAAAD,SAAA,CAAArG,EAAA,EAAAqG,SAAA,CAAApG,EAAA,EAAAoG,SAAA,CAAAE,EAAA,EAAAF,SAAA,CAAAG,EAAA;YAAAH,SAAA,CAAAtD,IAAA;YAAA;UAAA;UAAAsD,SAAA,CAAAtD,IAAA;UAAA,OACFmD,IAAI,CAAC/C,MAAM,CAAC,CAAC;QAAA;UAAAkD,SAAA,CAAAtD,IAAA;UAAA;QAAA;UAAA,OAAAsD,SAAA,CAAApD,MAAA,WAChBkC,WAAW,CAAClB,GAAG,EAAEoB,IAAI,CAAC;QAAA;QAAA;UAAA,OAAAgB,SAAA,CAAAnD,IAAA;MAAA;IAAA,GAAA6C,QAAA;EAAA,CAChC;EAAA,OAAAD,KAAA,CAAA9D,KAAA,OAAAjK,SAAA;AAAA;AACDhL,OAAO,CAACM,IAAI,GAAGA,IAAI;AACnB,SAASD,QAAQA,CAACmN,OAAO,EAAEyL,OAAO,EAAa;EAAA,IAAXX,IAAI,GAAAtN,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACzC,IAAA0O,YAAA,GAAuB5B,WAAW,CAACtK,OAAO,EAAEyL,OAAO,EAAEX,IAAI,CAACP,YAAY,CAAC;IAA/DrC,IAAI,GAAAgE,YAAA,CAAJhE,IAAI;IAAEjC,CAAC,GAAAiG,YAAA,CAADjG,CAAC;IAAE/M,CAAC,GAAAgT,YAAA,CAADhT,CAAC;EAClB,IAAMyS,IAAI,GAAG,IAAI5E,QAAQ,CAACvR,OAAO,EAAED,QAAQ,CAAC;EAC5CoW,IAAI,CAAC9C,UAAU,CAACX,IAAI,CAAC;EACrB,IAAIwB,GAAG;EACP,OAAO,EAAEA,GAAG,GAAGJ,QAAQ,CAACqC,IAAI,CAACtC,YAAY,CAAC,CAAC,EAAEpD,CAAC,EAAE/M,CAAC,EAAE4R,IAAI,CAACG,SAAS,CAAC,CAAC,EAC/DU,IAAI,CAAC9C,UAAU,CAAC,CAAC;EACrB,OAAO+B,WAAW,CAAClB,GAAG,EAAEoB,IAAI,CAAC;AACjC;AACAtY,OAAO,CAACK,QAAQ,GAAGA,QAAQ;AAC3B,IAAMsZ,KAAK,GAAG;EAAEC,MAAM,EAAE;AAAK,CAAC;AAC9B,SAASxZ,MAAMA,CAACqN,SAAS,EAAED,OAAO,EAAE4J,SAAS,EAAgB;EAAA,IAAdkB,IAAI,GAAAtN,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG2O,KAAK;EACvD,IAAIzC,GAAG;EACP,IAAI;IACAA,GAAG,GAAGtJ,kBAAkB,CAACH,SAAS,CAAC;IACnCD,OAAO,GAAGP,WAAW,CAACO,OAAO,CAAC;EAClC,CAAC,CACD,OAAO6J,KAAK,EAAE;IACV,OAAO,KAAK;EAChB;EACA,IAAAwC,IAAA,GAAiB3C,GAAG;IAAZnR,CAAC,GAAA8T,IAAA,CAAD9T,CAAC;IAAE8H,CAAC,GAAAgM,IAAA,CAADhM,CAAC;EACZ,IAAIyK,IAAI,CAACsB,MAAM,IAAI1C,GAAG,CAACjI,QAAQ,CAAC,CAAC,EAC7B,OAAO,KAAK;EAChB,IAAMxN,CAAC,GAAGsM,YAAY,CAACP,OAAO,CAAC;EAC/B,IAAIjM,CAAC;EACL,IAAI;IACAA,CAAC,GAAG4V,kBAAkB,CAACC,SAAS,CAAC;EACrC,CAAC,CACD,OAAOC,KAAK,EAAE;IACV,OAAO,KAAK;EAChB;EACA,IAAQ7V,CAAC,GAAKZ,KAAK,CAAXY,CAAC;EACT,IAAMsY,IAAI,GAAGnQ,MAAM,CAACkE,CAAC,EAAErM,CAAC,CAAC;EACzB,IAAM0M,EAAE,GAAGzL,GAAG,CAAChB,CAAC,GAAGqY,IAAI,EAAEtY,CAAC,CAAC;EAC3B,IAAM2M,EAAE,GAAG1L,GAAG,CAACsD,CAAC,GAAG+T,IAAI,EAAEtY,CAAC,CAAC;EAC3B,IAAM4M,CAAC,GAAGzN,KAAK,CAAC+G,IAAI,CAACsE,oBAAoB,CAACzK,CAAC,EAAE2M,EAAE,EAAEC,EAAE,CAAC;EACpD,IAAI,CAACC,CAAC,EACF,OAAO,KAAK;EAChB,IAAM8C,CAAC,GAAGzO,GAAG,CAAC2L,CAAC,CAAChL,CAAC,EAAE5B,CAAC,CAAC;EACrB,OAAO0P,CAAC,KAAKnL,CAAC;AAClB;AACA/F,OAAO,CAACI,MAAM,GAAGA,MAAM;AACvB,SAAS2Z,wBAAwBA,CAACC,EAAE,EAAE;EAClC,OAAOvX,GAAG,CAAC+J,aAAa,CAACwN,EAAE,CAAC,EAAEpZ,KAAK,CAACY,CAAC,CAAC;AAC1C;AAAC,IACKyY,gBAAgB;EAClB,SAAAA,iBAAYlU,CAAC,EAAE8H,CAAC,EAAE;IAAAnO,eAAA,OAAAua,gBAAA;IACd,IAAI,CAAClU,CAAC,GAAGA,CAAC;IACV,IAAI,CAAC8H,CAAC,GAAGA,CAAC;IACV,IAAI,CAAClC,cAAc,CAAC,CAAC;EACzB;EAAClM,YAAA,CAAAwa,gBAAA;IAAA9V,GAAA;IAAAlE,KAAA,EASD,SAAA0L,eAAA,EAAiB;MACb,IAAQ5F,CAAC,GAAQ,IAAI,CAAbA,CAAC;QAAE8H,CAAC,GAAK,IAAI,CAAVA,CAAC;MACZ,IAAI,CAAChC,mBAAmB,CAAC9F,CAAC,CAAC,IAAI,CAACiJ,kBAAkB,CAACnB,CAAC,CAAC,EACjD,MAAM,IAAIhL,KAAK,CAAC,mBAAmB,CAAC;IAC5C;EAAC;IAAAsB,GAAA;IAAAlE,KAAA,EACD,SAAAmL,MAAA,EAAQ;MACJ,OAAOC,WAAW,CAAC,IAAI,CAACtF,CAAC,CAAC,GAAGsF,WAAW,CAAC,IAAI,CAACwC,CAAC,CAAC;IACpD;EAAC;IAAA1J,GAAA;IAAAlE,KAAA,EACD,SAAA6K,WAAA,EAAa;MACT,OAAOK,UAAU,CAAC,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC;IACnC;EAAC;IAAAjH,GAAA;IAAAlE,KAAA,EAlBD,SAAA8M,QAAeC,GAAG,EAAE;MAChB,IAAMV,KAAK,GAAGW,WAAW,CAACD,GAAG,CAAC;MAC9B,IAAIV,KAAK,CAACrB,MAAM,KAAK,EAAE,EACnB,MAAM,IAAIjH,SAAS,qDAAAuH,MAAA,CAAqDe,KAAK,CAACrB,MAAM,CAAE,CAAC;MAC3F,IAAMlF,CAAC,GAAGyG,aAAa,CAACF,KAAK,CAACG,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;MAC9C,IAAMoB,CAAC,GAAGrB,aAAa,CAACF,KAAK,CAACG,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;MAC/C,OAAO,IAAIwN,gBAAgB,CAAClU,CAAC,EAAE8H,CAAC,CAAC;IACrC;EAAC;EAAA,OAAAoM,gBAAA;AAAA;AAaL,SAASC,mBAAmBA,CAAC7M,UAAU,EAAE;EACrC,OAAO1M,KAAK,CAACyM,cAAc,CAACC,UAAU,CAAC,CAAC3B,MAAM,CAAC,CAAC;AACpD;AAAC,IACKyO,wBAAwB;EAC1B,SAAAA,yBAAYxW,OAAO,EAAE0J,UAAU,EAAyC;IAAA,IAAvC+M,OAAO,GAAApP,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGhL,OAAO,CAACE,KAAK,CAACgY,WAAW,CAAC,CAAC;IAAAxY,eAAA,OAAAya,wBAAA;IAClE,IAAIxW,OAAO,IAAI,IAAI,EACf,MAAM,IAAIK,SAAS,wCAAAuH,MAAA,CAAuC5H,OAAO,OAAG,CAAC;IACzE,IAAI,CAAC8P,CAAC,GAAGxG,WAAW,CAACtJ,OAAO,CAAC;IAC7B,IAAA0W,eAAA,GAAsB,IAAI,CAACC,SAAS,CAAChN,mBAAmB,CAACD,UAAU,CAAC,CAAC;MAA7DjK,CAAC,GAAAiX,eAAA,CAADjX,CAAC;MAAEkD,MAAM,GAAA+T,eAAA,CAAN/T,MAAM;IACjB,IAAI,CAACiU,EAAE,GAAGnX,CAAC;IACX,IAAI,CAACsD,CAAC,GAAGJ,MAAM;IACf,IAAI,CAACkU,IAAI,GAAGvN,WAAW,CAACmN,OAAO,CAAC;IAChC,IAAI,IAAI,CAACI,IAAI,CAACvP,MAAM,KAAK,EAAE,EACvB,MAAM,IAAIjH,SAAS,CAAC,2CAA2C,CAAC;EACxE;EAACvE,YAAA,CAAA0a,wBAAA;IAAAhW,GAAA;IAAAlE,KAAA,EACD,SAAAqa,UAAUG,IAAI,EAAE;MACZ,IAAMzR,KAAK,GAAGrI,KAAK,CAACyM,cAAc,CAACqN,IAAI,CAAC;MACxC,IAAMnU,MAAM,GAAG0C,KAAK,CAAC6B,QAAQ,CAAC,CAAC,GAAG4P,IAAI,GAAG7Z,KAAK,CAACY,CAAC,GAAGiZ,IAAI;MACvD,OAAO;QAAEzR,KAAK,EAALA,KAAK;QAAE1C,MAAM,EAANA,MAAM;QAAElD,CAAC,EAAE4F,KAAK,CAAC0C,MAAM,CAAC;MAAE,CAAC;IAC/C;EAAC;IAAAvH,GAAA;IAAAlE,KAAA,EACD,SAAAya,UAAUhU,CAAC,EAAEiU,GAAG,EAAE;MACd,OAAOnJ,QAAQ,CAAC9K,CAAC,GAAG8F,aAAa,CAACmO,GAAG,CAAC,CAAC;IAC3C;EAAC;IAAAxW,GAAA;IAAAlE,KAAA,EACD,SAAA2a,cAAcC,GAAG,EAAE;MACf,IAAMC,EAAE,GAAGrY,GAAG,CAAC+J,aAAa,CAACqO,GAAG,CAAC,EAAEja,KAAK,CAACY,CAAC,CAAC;MAC3C,IAAIsZ,EAAE,KAAKha,GAAG,EACV,MAAM,IAAI+B,KAAK,CAAC,+CAA+C,CAAC;MACpE,IAAAkY,gBAAA,GAAuC,IAAI,CAACT,SAAS,CAACQ,EAAE,CAAC;QAA1C1M,CAAC,GAAA2M,gBAAA,CAAR/R,KAAK;QAAQgS,EAAE,GAAAD,gBAAA,CAAL3X,CAAC;QAAcpB,CAAC,GAAA+Y,gBAAA,CAATzU,MAAM;MAC/B,OAAO;QAAE8H,CAAC,EAADA,CAAC;QAAE4M,EAAE,EAAFA,EAAE;QAAEhZ,CAAC,EAADA;MAAE,CAAC;IACvB;EAAC;IAAAmC,GAAA;IAAAlE,KAAA,EACD,SAAAmY,YAAYhK,CAAC,EAAEpM,CAAC,EAAEmW,CAAC,EAAEzR,CAAC,EAAE;MACpB,OAAO,IAAIuT,gBAAgB,CAAC7L,CAAC,CAAChL,CAAC,EAAEX,GAAG,CAACT,CAAC,GAAGmW,CAAC,GAAGzR,CAAC,EAAE9F,KAAK,CAACY,CAAC,CAAC,CAAC,CAACsJ,UAAU,CAAC,CAAC;IAC1E;EAAC;IAAA3G,GAAA;IAAAlE,KAAA,EACD,SAAAoX,MAAA,EAAQ;MACJ,MAAM,IAAIxU,KAAK,CAAC,kCAAkC,CAAC;IACvD;EAAC;IAAAsB,GAAA;IAAAlE,KAAA;MAAA,IAAAgb,KAAA,GAAAzb,iBAAA,eAAAD,mBAAA,GAAAiW,IAAA,CACD,SAAA0F,SAAA;QAAA,IAAAzH,CAAA,EAAA/M,CAAA,EAAA6T,EAAA,EAAAC,IAAA,EAAAW,GAAA,EAAAC,CAAA,EAAAC,mBAAA,EAAAjN,CAAA,EAAA4M,EAAA,EAAAhZ,CAAA,EAAAmW,CAAA,EAAAjB,GAAA;QAAA,OAAA3X,mBAAA,GAAAqW,IAAA,UAAA0F,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAxF,IAAA,GAAAwF,SAAA,CAAAvF,IAAA;YAAA;cACYvC,CAAC,GAAkB,IAAI,CAAvBA,CAAC,EAAE/M,CAAC,GAAe,IAAI,CAApBA,CAAC,EAAE6T,EAAE,GAAW,IAAI,CAAjBA,EAAE,EAAEC,IAAI,GAAK,IAAI,CAAbA,IAAI;cAChBW,GAAG,GAAGnb,OAAO,CAACE,KAAK,CAACsb,UAAU;cAAAD,SAAA,CAAAhC,EAAA,GAC1B,IAAI;cAAAgC,SAAA,CAAAtI,EAAA,GAAWvM,CAAC;cAAA6U,SAAA,CAAAvF,IAAA;cAAA,OAAQmF,GAAG,CAACM,IAAI,CAACC,GAAG,EAAElB,IAAI,CAAC;YAAA;cAAAe,SAAA,CAAArI,EAAA,GAAAqI,SAAA,CAAAtF,IAAA;cAA/CmF,CAAC,GAAAG,SAAA,CAAAhC,EAAA,CAAQmB,SAAS,CAAA9W,IAAA,CAAA2X,SAAA,CAAAhC,EAAA,EAAAgC,SAAA,CAAAtI,EAAA,EAAAsI,SAAA,CAAArI,EAAA;cAAAqI,SAAA,CAAA/B,EAAA,GACH,IAAI;cAAA+B,SAAA,CAAAvF,IAAA;cAAA,OAAqBmF,GAAG,CAACM,IAAI,CAACE,KAAK,EAAEP,CAAC,EAAEb,EAAE,EAAE9G,CAAC,CAAC;YAAA;cAAA8H,SAAA,CAAA9B,EAAA,GAAA8B,SAAA,CAAAtF,IAAA;cAAAoF,mBAAA,GAAAE,SAAA,CAAA/B,EAAA,CAA7CoB,aAAa,CAAAhX,IAAA,CAAA2X,SAAA,CAAA/B,EAAA,EAAA+B,SAAA,CAAA9B,EAAA;cAA/BrL,CAAC,GAAAiN,mBAAA,CAADjN,CAAC;cAAE4M,EAAE,GAAAK,mBAAA,CAAFL,EAAE;cAAEhZ,CAAC,GAAAqZ,mBAAA,CAADrZ,CAAC;cAAAuZ,SAAA,CAAAK,EAAA,GACN7B,wBAAwB;cAAAwB,SAAA,CAAAvF,IAAA;cAAA,OAAOmF,GAAG,CAACM,IAAI,CAACI,SAAS,EAAEb,EAAE,EAAET,EAAE,EAAE9G,CAAC,CAAC;YAAA;cAAA8H,SAAA,CAAAO,EAAA,GAAAP,SAAA,CAAAtF,IAAA;cAAjEkC,CAAC,OAAAoD,SAAA,CAAAK,EAAA,EAAAL,SAAA,CAAAO,EAAA;cACD5E,GAAG,GAAG,IAAI,CAACkB,WAAW,CAAChK,CAAC,EAAEpM,CAAC,EAAEmW,CAAC,EAAEzR,CAAC,CAAC;cAAA6U,SAAA,CAAAvF,IAAA;cAAA,OAC5B+F,aAAa,CAAC7E,GAAG,EAAEzD,CAAC,EAAE8G,EAAE,CAAC;YAAA;cAAA,IAAAgB,SAAA,CAAAtF,IAAA;gBAAAsF,SAAA,CAAAvF,IAAA;gBAAA;cAAA;cACjC,IAAI,CAACqB,KAAK,CAAC,CAAC;YAAC;cAAA,OAAAkE,SAAA,CAAArF,MAAA,WACVgB,GAAG;YAAA;YAAA;cAAA,OAAAqE,SAAA,CAAApF,IAAA;UAAA;QAAA,GAAA+E,QAAA;MAAA,CACb;MAAA,SAAAc,KAAA;QAAA,OAAAf,KAAA,CAAAhG,KAAA,OAAAjK,SAAA;MAAA;MAAA,OAAAgR,IAAA;IAAA;EAAA;IAAA7X,GAAA;IAAAlE,KAAA,EACD,SAAAgc,SAAA,EAAW;MACP,IAAQxI,CAAC,GAAkB,IAAI,CAAvBA,CAAC;QAAE/M,CAAC,GAAe,IAAI,CAApBA,CAAC;QAAE6T,EAAE,GAAW,IAAI,CAAjBA,EAAE;QAAEC,IAAI,GAAK,IAAI,CAAbA,IAAI;MACtB,IAAMW,GAAG,GAAGnb,OAAO,CAACE,KAAK,CAACgc,cAAc;MACxC,IAAMd,CAAC,GAAG,IAAI,CAACV,SAAS,CAAChU,CAAC,EAAEyU,GAAG,CAACM,IAAI,CAACC,GAAG,EAAElB,IAAI,CAAC,CAAC;MAChD,IAAA2B,oBAAA,GAAqB,IAAI,CAACvB,aAAa,CAACO,GAAG,CAACM,IAAI,CAACE,KAAK,EAAEP,CAAC,EAAEb,EAAE,EAAE9G,CAAC,CAAC,CAAC;QAA1DrF,CAAC,GAAA+N,oBAAA,CAAD/N,CAAC;QAAE4M,EAAE,GAAAmB,oBAAA,CAAFnB,EAAE;QAAEhZ,CAAC,GAAAma,oBAAA,CAADna,CAAC;MAChB,IAAMmW,CAAC,GAAG4B,wBAAwB,CAACoB,GAAG,CAACM,IAAI,CAACI,SAAS,EAAEb,EAAE,EAAET,EAAE,EAAE9G,CAAC,CAAC,CAAC;MAClE,IAAMyD,GAAG,GAAG,IAAI,CAACkB,WAAW,CAAChK,CAAC,EAAEpM,CAAC,EAAEmW,CAAC,EAAEzR,CAAC,CAAC;MACxC,IAAI,CAAC0V,iBAAiB,CAAClF,GAAG,EAAEzD,CAAC,EAAE8G,EAAE,CAAC,EAC9B,IAAI,CAAClD,KAAK,CAAC,CAAC;MAChB,OAAOH,GAAG;IACd;EAAC;EAAA,OAAAiD,wBAAA;AAAA;AAAA,SAEUkC,WAAWA,CAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,YAAA,CAAAxH,KAAA,OAAAjK,SAAA;AAAA;AAAA,SAAAyR,aAAA;EAAAA,YAAA,GAAAjd,iBAAA,eAAAD,mBAAA,GAAAiW,IAAA,CAA1B,SAAAkH,SAA2B9Q,GAAG,EAAEqN,OAAO,EAAEmB,OAAO;IAAA,OAAA7a,mBAAA,GAAAqW,IAAA,UAAA+G,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAA7G,IAAA,GAAA6G,SAAA,CAAA5G,IAAA;QAAA;UAAA,OAAA4G,SAAA,CAAA1G,MAAA,WACrC,IAAIiE,wBAAwB,CAACvO,GAAG,EAAEqN,OAAO,EAAEmB,OAAO,CAAC,CAAC4B,IAAI,CAAC,CAAC;QAAA;QAAA;UAAA,OAAAY,SAAA,CAAAzG,IAAA;MAAA;IAAA,GAAAuG,QAAA;EAAA,CACpE;EAAA,OAAAD,YAAA,CAAAxH,KAAA,OAAAjK,SAAA;AAAA;AACD,SAAS6R,eAAeA,CAACjR,GAAG,EAAEqN,OAAO,EAAEmB,OAAO,EAAE;EAC5C,OAAO,IAAID,wBAAwB,CAACvO,GAAG,EAAEqN,OAAO,EAAEmB,OAAO,CAAC,CAAC6B,QAAQ,CAAC,CAAC;AACzE;AACA,SAASa,iBAAiBA,CAACrP,SAAS,EAAE9J,OAAO,EAAEyT,SAAS,EAAE;EACtD,IAAM2F,GAAG,GAAGtP,SAAS,YAAYwM,gBAAgB;EACjD,IAAM/C,GAAG,GAAG6F,GAAG,GAAGtP,SAAS,GAAGwM,gBAAgB,CAAClN,OAAO,CAACU,SAAS,CAAC;EACjE,IAAIsP,GAAG,EACH7F,GAAG,CAACvL,cAAc,CAAC,CAAC;EACxB,OAAAvM,aAAA,CAAAA,aAAA,KACO8X,GAAG;IACNzD,CAAC,EAAExG,WAAW,CAACtJ,OAAO,CAAC;IACvBpC,CAAC,EAAE4V,kBAAkB,CAACC,SAAS;EAAC;AAExC;AACA,SAAS4F,qBAAqBA,CAACjX,CAAC,EAAExE,CAAC,EAAEsM,CAAC,EAAEsK,CAAC,EAAE;EACvC,IAAM/J,CAAC,GAAGzN,KAAK,CAAC+G,IAAI,CAACsE,oBAAoB,CAACzK,CAAC,EAAE+L,mBAAmB,CAACO,CAAC,CAAC,EAAEpL,GAAG,CAAC,CAAC0V,CAAC,EAAEvX,KAAK,CAACY,CAAC,CAAC,CAAC;EACtF,IAAI,CAAC4M,CAAC,IAAI,CAACA,CAAC,CAACvD,QAAQ,CAAC,CAAC,IAAIuD,CAAC,CAAChL,CAAC,KAAK2C,CAAC,EAChC,OAAO,KAAK;EAChB,OAAO,IAAI;AACf;AAAC,SACcgW,aAAaA,CAAAkB,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,cAAA,CAAAnI,KAAA,OAAAjK,SAAA;AAAA;AAAA,SAAAoS,eAAA;EAAAA,cAAA,GAAA5d,iBAAA,eAAAD,mBAAA,GAAAiW,IAAA,CAA5B,SAAA6H,SAA6B5P,SAAS,EAAE9J,OAAO,EAAEyT,SAAS;IAAA,IAAAkG,mBAAA,EAAAvX,CAAA,EAAA8H,CAAA,EAAA4F,CAAA,EAAAlS,CAAA,EAAA4W,CAAA;IAAA,OAAA5Y,mBAAA,GAAAqW,IAAA,UAAA2H,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAzH,IAAA,GAAAyH,SAAA,CAAAxH,IAAA;QAAA;UAAAwH,SAAA,CAAAzH,IAAA;UAAAuH,mBAAA,GAE3BR,iBAAiB,CAACrP,SAAS,EAAE9J,OAAO,EAAEyT,SAAS,CAAC,EAA/DrR,CAAC,GAAAuX,mBAAA,CAADvX,CAAC,EAAE8H,CAAC,GAAAyP,mBAAA,CAADzP,CAAC,EAAE4F,CAAC,GAAA6J,mBAAA,CAAD7J,CAAC,EAAElS,CAAC,GAAA+b,mBAAA,CAAD/b,CAAC;UAAAic,SAAA,CAAAjE,EAAA,GACRQ,wBAAwB;UAAAyD,SAAA,CAAAxH,IAAA;UAAA,OAAOhW,OAAO,CAACE,KAAK,CAACsb,UAAU,CAACC,IAAI,CAACI,SAAS,EAAErK,QAAQ,CAACzL,CAAC,CAAC,EAAExE,CAAC,CAACmK,MAAM,CAAC,CAAC,EAAE+H,CAAC,CAAC;QAAA;UAAA+J,SAAA,CAAAvK,EAAA,GAAAuK,SAAA,CAAAvH,IAAA;UAAvGkC,CAAC,OAAAqF,SAAA,CAAAjE,EAAA,EAAAiE,SAAA,CAAAvK,EAAA;UAAA,OAAAuK,SAAA,CAAAtH,MAAA,WACA8G,qBAAqB,CAACjX,CAAC,EAAExE,CAAC,EAAEsM,CAAC,EAAEsK,CAAC,CAAC;QAAA;UAAAqF,SAAA,CAAAzH,IAAA;UAAAyH,SAAA,CAAAtK,EAAA,GAAAsK,SAAA;UAAA,OAAAA,SAAA,CAAAtH,MAAA,WAGjC,KAAK;QAAA;QAAA;UAAA,OAAAsH,SAAA,CAAArH,IAAA;MAAA;IAAA,GAAAkH,QAAA;EAAA,CAEnB;EAAA,OAAAD,cAAA,CAAAnI,KAAA,OAAAjK,SAAA;AAAA;AACD,SAASoR,iBAAiBA,CAAC3O,SAAS,EAAE9J,OAAO,EAAEyT,SAAS,EAAE;EACtD,IAAI;IACA,IAAAqG,kBAAA,GAAuBX,iBAAiB,CAACrP,SAAS,EAAE9J,OAAO,EAAEyT,SAAS,CAAC;MAA/DrR,CAAC,GAAA0X,kBAAA,CAAD1X,CAAC;MAAE8H,CAAC,GAAA4P,kBAAA,CAAD5P,CAAC;MAAE4F,CAAC,GAAAgK,kBAAA,CAADhK,CAAC;MAAElS,CAAC,GAAAkc,kBAAA,CAADlc,CAAC;IAClB,IAAM4W,CAAC,GAAG4B,wBAAwB,CAAC/Z,OAAO,CAACE,KAAK,CAACgc,cAAc,CAACT,IAAI,CAACI,SAAS,EAAErK,QAAQ,CAACzL,CAAC,CAAC,EAAExE,CAAC,CAACmK,MAAM,CAAC,CAAC,EAAE+H,CAAC,CAAC,CAAC;IAC5G,OAAOuJ,qBAAqB,CAACjX,CAAC,EAAExE,CAAC,EAAEsM,CAAC,EAAEsK,CAAC,CAAC;EAC5C,CAAC,CACD,OAAOd,KAAK,EAAE;IACV,IAAIA,KAAK,YAAY7T,QAAQ,EACzB,MAAM6T,KAAK;IACf,OAAO,KAAK;EAChB;AACJ;AACArX,OAAO,CAACG,OAAO,GAAG;EACdO,SAAS,EAAEuZ,gBAAgB;EAC3BxZ,YAAY,EAAEyZ,mBAAmB;EACjC5Z,IAAI,EAAE+b,WAAW;EACjBjc,MAAM,EAAE2b,aAAa;EACrB1b,QAAQ,EAAEwc,eAAe;EACzBa,UAAU,EAAEtB;AAChB,CAAC;AACDzb,KAAK,CAAC+G,IAAI,CAACiD,cAAc,CAAC,CAAC,CAAC;AAC5B,IAAMgT,MAAM,GAAG;EACXC,IAAI,EAAE/c,UAAU;EAChBgd,GAAG,EAAE,OAAOC,IAAI,KAAK,QAAQ,IAAI,QAAQ,IAAIA,IAAI,GAAGA,IAAI,CAACH,MAAM,GAAGzS;AACtE,CAAC;AACD,IAAMuQ,IAAI,GAAG;EACTI,SAAS,EAAE,mBAAmB;EAC9BH,GAAG,EAAE,aAAa;EAClBC,KAAK,EAAE;AACX,CAAC;AACD,IAAMoC,oBAAoB,GAAG,CAAC,CAAC;AAC/B/d,OAAO,CAACE,KAAK,GAAG;EACZuO,UAAU,EAAVA,UAAU;EACVtD,UAAU,EAAVA,UAAU;EACVoF,WAAW,EAAXA,WAAW;EACX9N,GAAG,EAAHA,GAAG;EACHkH,MAAM,EAANA,MAAM;EACNqU,iBAAiB,WAAAA,kBAAC3Q,UAAU,EAAE;IAC1B,IAAI;MACAC,mBAAmB,CAACD,UAAU,CAAC;MAC/B,OAAO,IAAI;IACf,CAAC,CACD,OAAOgK,KAAK,EAAE;MACV,OAAO,KAAK;IAChB;EACJ,CAAC;EACD4G,gBAAgB,EAAEzM,QAAQ;EAC1B0M,oBAAoB,EAAE5Q,mBAAmB;EACzC6Q,gBAAgB,EAAE,SAAAA,iBAAChK,IAAI,EAAK;IACxBA,IAAI,GAAGlH,WAAW,CAACkH,IAAI,CAAC;IACxB,IAAMiK,MAAM,GAAGrb,QAAQ,GAAG,CAAC;IAC3B,IAAIoR,IAAI,CAAClJ,MAAM,GAAGmT,MAAM,IAAIjK,IAAI,CAAClJ,MAAM,GAAG,IAAI,EAAE;MAC5C,MAAM,IAAIpI,KAAK,sDAAsD,CAAC;IAC1E;IACA,IAAM0O,GAAG,GAAG9O,GAAG,CAAC+J,aAAa,CAAC2H,IAAI,CAAC,EAAEvT,KAAK,CAACY,CAAC,GAAGR,GAAG,CAAC,GAAGA,GAAG;IACzD,OAAOwQ,QAAQ,CAACD,GAAG,CAAC;EACxB,CAAC;EACD2G,WAAW,EAAE,SAAAA,YAAA,EAAsB;IAAA,IAArBmG,WAAW,GAAArT,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IAC1B,IAAI2S,MAAM,CAACE,GAAG,EAAE;MACZ,OAAOF,MAAM,CAACE,GAAG,CAACS,eAAe,CAAC,IAAIrO,UAAU,CAACoO,WAAW,CAAC,CAAC;IAClE,CAAC,MACI,IAAIV,MAAM,CAACC,IAAI,EAAE;MAClB,IAAQ1F,WAAW,GAAKyF,MAAM,CAACC,IAAI,CAA3B1F,WAAW;MACnB,OAAOjI,UAAU,CAACgB,IAAI,CAACiH,WAAW,CAACmG,WAAW,CAAC,CAAC;IACpD,CAAC,MACI;MACD,MAAM,IAAIxb,KAAK,CAAC,mDAAmD,CAAC;IACxE;EACJ,CAAC;EACD0b,gBAAgB,EAAE,SAAAA,iBAAA;IAAA,OAAMve,OAAO,CAACE,KAAK,CAACie,gBAAgB,CAACne,OAAO,CAACE,KAAK,CAACgY,WAAW,CAACnV,QAAQ,GAAG,CAAC,CAAC,CAAC;EAAA;EAC/Fyb,UAAU,WAAAA,WAAA,EAAqC;IAAA,IAApCtW,UAAU,GAAA8C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAAA,IAAEhC,KAAK,GAAAgC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGrK,KAAK,CAAC+G,IAAI;IACzC,IAAM+W,MAAM,GAAGzV,KAAK,KAAKrI,KAAK,CAAC+G,IAAI,GAAGsB,KAAK,GAAG,IAAIrI,KAAK,CAACqI,KAAK,CAAC5F,CAAC,EAAE4F,KAAK,CAAC/E,CAAC,CAAC;IACzEwa,MAAM,CAAC9T,cAAc,CAACzC,UAAU,CAAC;IACjCuW,MAAM,CAAC1V,QAAQ,CAAC7H,GAAG,CAAC;IACpB,OAAOud,MAAM;EACjB,CAAC;EACDC,MAAM;IAAA,IAAAC,IAAA,GAAAnf,iBAAA,eAAAD,mBAAA,GAAAiW,IAAA,CAAE,SAAAoJ,SAAA;MAAA,IAAAC,KAAA;QAAAC,QAAA;QAAAC,KAAA;QAAAC,MAAA;QAAAC,UAAA;QAAA9K,IAAA;QAAA+K,MAAA,GAAAlU,SAAA;MAAA,OAAAzL,mBAAA,GAAAqW,IAAA,UAAAuJ,UAAAC,SAAA;QAAA,kBAAAA,SAAA,CAAArJ,IAAA,GAAAqJ,SAAA,CAAApJ,IAAA;UAAA;YAAA,KAAA6I,KAAA,GAAAK,MAAA,CAAAjU,MAAA,EAAU6T,QAAQ,OAAApO,KAAA,CAAAmO,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;cAARD,QAAQ,CAAAC,KAAA,IAAAG,MAAA,CAAAH,KAAA;YAAA;YAAA,KAClBpB,MAAM,CAACE,GAAG;cAAAuB,SAAA,CAAApJ,IAAA;cAAA;YAAA;YAAAoJ,SAAA,CAAApJ,IAAA;YAAA,OACW2H,MAAM,CAACE,GAAG,CAACwB,MAAM,CAACC,MAAM,CAAC,SAAS,EAAE/O,WAAW,CAAA0E,KAAA,SAAI6J,QAAQ,CAAC,CAAC;UAAA;YAA5EE,MAAM,GAAAI,SAAA,CAAAnJ,IAAA;YAAA,OAAAmJ,SAAA,CAAAlJ,MAAA,WACL,IAAIjG,UAAU,CAAC+O,MAAM,CAAC;UAAA;YAAA,KAExBrB,MAAM,CAACC,IAAI;cAAAwB,SAAA,CAAApJ,IAAA;cAAA;YAAA;YACRiJ,UAAU,GAAKtB,MAAM,CAACC,IAAI,CAA1BqB,UAAU;YACZ9K,IAAI,GAAG8K,UAAU,CAAC,QAAQ,CAAC;YACjCH,QAAQ,CAACS,OAAO,CAAC,UAAC9L,CAAC;cAAA,OAAKU,IAAI,CAACqL,MAAM,CAAC/L,CAAC,CAAC;YAAA,EAAC;YAAC,OAAA2L,SAAA,CAAAlJ,MAAA,WACjCjG,UAAU,CAACgB,IAAI,CAACkD,IAAI,CAACmL,MAAM,CAAC,CAAC,CAAC;UAAA;YAAA,MAG/B,IAAIzc,KAAK,CAAC,8CAA8C,CAAC;UAAA;UAAA;YAAA,OAAAuc,SAAA,CAAAjJ,IAAA;QAAA;MAAA,GAAAyI,QAAA;IAAA,CAEtE;IAAA,SAAAF,OAAA;MAAA,OAAAC,IAAA,CAAA1J,KAAA,OAAAjK,SAAA;IAAA;IAAA,OAAA0T,MAAA;EAAA;EACD1J,UAAU;IAAA,IAAAyK,QAAA,GAAAjgB,iBAAA,eAAAD,mBAAA,GAAAiW,IAAA,CAAE,SAAAkK,SAAOvb,GAAG;MAAA,IAAAwb,KAAA;QAAAb,QAAA;QAAAc,KAAA;QAAAC,IAAA;QAAAlc,OAAA;QAAAqb,MAAA;QAAAc,UAAA;QAAA3L,IAAA;QAAA4L,MAAA,GAAA/U,SAAA;MAAA,OAAAzL,mBAAA,GAAAqW,IAAA,UAAAoK,UAAAC,SAAA;QAAA,kBAAAA,SAAA,CAAAlK,IAAA,GAAAkK,SAAA,CAAAjK,IAAA;UAAA;YAAA,KAAA2J,KAAA,GAAAI,MAAA,CAAA9U,MAAA,EAAK6T,QAAQ,OAAApO,KAAA,CAAAiP,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;cAARd,QAAQ,CAAAc,KAAA,QAAAG,MAAA,CAAAH,KAAA;YAAA;YAAA,KAC3BjC,MAAM,CAACE,GAAG;cAAAoC,SAAA,CAAAjK,IAAA;cAAA;YAAA;YAAAiK,SAAA,CAAAjK,IAAA;YAAA,OACS2H,MAAM,CAACE,GAAG,CAACwB,MAAM,CAACa,SAAS,CAAC,KAAK,EAAE/b,GAAG,EAAE;cAAE+L,IAAI,EAAE,MAAM;cAAEiE,IAAI,EAAE;gBAAEjE,IAAI,EAAE;cAAU;YAAE,CAAC,EAAE,KAAK,EAAE,CAAC,MAAM,CAAC,CAAC;UAAA;YAAlH2P,IAAI,GAAAI,SAAA,CAAAhK,IAAA;YACJtS,OAAO,GAAG4M,WAAW,CAAA0E,KAAA,SAAI6J,QAAQ,CAAC;YAAAmB,SAAA,CAAAjK,IAAA;YAAA,OACnB2H,MAAM,CAACE,GAAG,CAACwB,MAAM,CAAC/e,IAAI,CAAC,MAAM,EAAEuf,IAAI,EAAElc,OAAO,CAAC;UAAA;YAA5Dqb,MAAM,GAAAiB,SAAA,CAAAhK,IAAA;YAAA,OAAAgK,SAAA,CAAA/J,MAAA,WACL,IAAIjG,UAAU,CAAC+O,MAAM,CAAC;UAAA;YAAA,KAExBrB,MAAM,CAACC,IAAI;cAAAqC,SAAA,CAAAjK,IAAA;cAAA;YAAA;YACR8J,UAAU,GAAKnC,MAAM,CAACC,IAAI,CAA1BkC,UAAU;YACZ3L,IAAI,GAAG2L,UAAU,CAAC,QAAQ,EAAE3b,GAAG,CAAC;YACtC2a,QAAQ,CAACS,OAAO,CAAC,UAAC9L,CAAC;cAAA,OAAKU,IAAI,CAACqL,MAAM,CAAC/L,CAAC,CAAC;YAAA,EAAC;YAAC,OAAAwM,SAAA,CAAA/J,MAAA,WACjCjG,UAAU,CAACgB,IAAI,CAACkD,IAAI,CAACmL,MAAM,CAAC,CAAC,CAAC;UAAA;YAAA,MAG/B,IAAIzc,KAAK,CAAC,mDAAmD,CAAC;UAAA;UAAA;YAAA,OAAAod,SAAA,CAAA9J,IAAA;QAAA;MAAA,GAAAuJ,QAAA;IAAA,CAE3E;IAAA,SAAA1K,WAAAmL,GAAA;MAAA,OAAAV,QAAA,CAAAxK,KAAA,OAAAjK,SAAA;IAAA;IAAA,OAAAgK,UAAA;EAAA;EACDoL,UAAU,EAAElV,SAAS;EACrBmV,cAAc,EAAEnV,SAAS;EACzBsQ,UAAU;IAAA,IAAA8E,WAAA,GAAA9gB,iBAAA,eAAAD,mBAAA,GAAAiW,IAAA,CAAE,SAAA+K,SAAOpF,GAAG;MAAA,IAAAqF,eAAA;MAAA,IAAAC,IAAA;QAAAC,IAAA;QAAAC,KAAA;QAAA7B,QAAA;QAAA8B,KAAA;QAAAC,MAAA,GAAA7V,SAAA;MAAA,OAAAzL,mBAAA,GAAAqW,IAAA,UAAAkL,UAAAC,SAAA;QAAA,kBAAAA,SAAA,CAAAhL,IAAA,GAAAgL,SAAA,CAAA/K,IAAA;UAAA;YACdyK,IAAI,GAAG1C,oBAAoB,CAAC5C,GAAG,CAAC;YAAA,MAChCsF,IAAI,KAAKvV,SAAS;cAAA6V,SAAA,CAAA/K,IAAA;cAAA;YAAA;YAAA+K,SAAA,CAAA/K,IAAA;YAAA,OACChW,OAAO,CAACE,KAAK,CAACwe,MAAM,CAACzO,UAAU,CAACgB,IAAI,CAACkK,GAAG,EAAE,UAAC6F,CAAC;cAAA,OAAKA,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC;YAAA,EAAC,CAAC;UAAA;YAA/EP,IAAI,GAAAK,SAAA,CAAA9K,IAAA;YACVwK,IAAI,GAAGlQ,WAAW,CAACmQ,IAAI,EAAEA,IAAI,CAAC;YAC9B3C,oBAAoB,CAAC5C,GAAG,CAAC,GAAGsF,IAAI;UAAC;YAAA,KAAAE,KAAA,GAAAE,MAAA,CAAA5V,MAAA,EALd6T,QAAQ,OAAApO,KAAA,CAAAiQ,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;cAAR9B,QAAQ,CAAA8B,KAAA,QAAAC,MAAA,CAAAD,KAAA;YAAA;YAAA,OAAAG,SAAA,CAAA7K,MAAA,WAOxB,CAAAsK,eAAA,GAAAxgB,OAAO,CAACE,KAAK,EAACwe,MAAM,CAAAzJ,KAAA,CAAAuL,eAAA,GAACC,IAAI,EAAAlV,MAAA,CAAKuT,QAAQ,EAAC;UAAA;UAAA;YAAA,OAAAiC,SAAA,CAAA5K,IAAA;QAAA;MAAA,GAAAoK,QAAA;IAAA,CACjD;IAAA,SAAA/E,WAAA0F,IAAA;MAAA,OAAAZ,WAAA,CAAArL,KAAA,OAAAjK,SAAA;IAAA;IAAA,OAAAwQ,UAAA;EAAA;EACDU,cAAc,EAAE,SAAAA,eAACf,GAAG,EAAkB;IAClC,IAAI,OAAO9G,WAAW,KAAK,UAAU,EACjC,MAAM,IAAI7Q,QAAQ,CAAC,6CAA6C,CAAC;IACrE,IAAIid,IAAI,GAAG1C,oBAAoB,CAAC5C,GAAG,CAAC;IACpC,IAAIsF,IAAI,KAAKvV,SAAS,EAAE;MACpB,IAAMwV,IAAI,GAAGrM,WAAW,CAACpE,UAAU,CAACgB,IAAI,CAACkK,GAAG,EAAE,UAAC6F,CAAC;QAAA,OAAKA,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC;MAAA,EAAC,CAAC;MACtER,IAAI,GAAGlQ,WAAW,CAACmQ,IAAI,EAAEA,IAAI,CAAC;MAC9B3C,oBAAoB,CAAC5C,GAAG,CAAC,GAAGsF,IAAI;IACpC;IAAC,SAAAU,KAAA,GAAAnW,SAAA,CAAAC,MAAA,EARoB6T,QAAQ,OAAApO,KAAA,CAAAyQ,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAARtC,QAAQ,CAAAsC,KAAA,QAAApW,SAAA,CAAAoW,KAAA;IAAA;IAS7B,OAAO/M,WAAW,CAAAY,KAAA,UAACwL,IAAI,EAAAlV,MAAA,CAAKuT,QAAQ,EAAC;EACzC,CAAC;EACDuC,cAAc,EAAEtd;AACpB,CAAC;AACDjE,MAAM,CAACwhB,gBAAgB,CAACthB,OAAO,CAACE,KAAK,EAAE;EACnCkgB,UAAU,EAAE;IACRmB,YAAY,EAAE,KAAK;IACnBzZ,GAAG,WAAAA,IAAA,EAAG;MACF,OAAOuM,WAAW;IACtB,CAAC;IACDrM,GAAG,WAAAA,IAACwZ,GAAG,EAAE;MACL,IAAI,CAACnN,WAAW,EACZA,WAAW,GAAGmN,GAAG;IACzB;EACJ,CAAC;EACDnB,cAAc,EAAE;IACZkB,YAAY,EAAE,KAAK;IACnBzZ,GAAG,WAAAA,IAAA,EAAG;MACF,OAAOwM,eAAe;IAC1B,CAAC;IACDtM,GAAG,WAAAA,IAACwZ,GAAG,EAAE;MACL,IAAI,CAAClN,eAAe,EAChBA,eAAe,GAAGkN,GAAG;IAC7B;EACJ;AACJ,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}