{"ast":null,"code":"import { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, concatBytes, utf8ToBytes } from '@stacks/common';\nimport { ClarityType, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv } from './keys';\nexport var STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);\nexport function hashStructuredData(structuredData) {\n  return sha256(serializeCV(structuredData));\n}\nvar hash256BytesLength = 32;\nfunction isDomain(value) {\n  if (value.type !== ClarityType.Tuple) return false;\n  if (!['name', 'version', 'chain-id'].every(function (key) {\n    return key in value.data;\n  })) return false;\n  if (!['name', 'version'].every(function (key) {\n    return value.data[key].type === ClarityType.StringASCII;\n  })) return false;\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\nexport function encodeStructuredData(_ref) {\n  var message = _ref.message,\n    domain = _ref.domain;\n  var structuredDataHash = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\");\n  }\n  var domainHash = hashStructuredData(domain);\n  return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);\n}\nexport function decodeStructuredDataSignature(signature) {\n  var encodedMessageBytes = typeof signature === 'string' ? utf8ToBytes(signature) : signature;\n  var domainHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length, STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  var messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  return {\n    domainHash: domainHash,\n    messageHash: messageHash\n  };\n}\nexport function signStructuredData(_ref2) {\n  var message = _ref2.message,\n    domain = _ref2.domain,\n    privateKey = _ref2.privateKey;\n  var structuredDataHash = bytesToHex(sha256(encodeStructuredData({\n    message: message,\n    domain: domain\n  })));\n  var _signMessageHashRsv = signMessageHashRsv({\n      messageHash: structuredDataHash,\n      privateKey: privateKey\n    }),\n    data = _signMessageHashRsv.data;\n  return {\n    data: data,\n    type: StacksMessageType.StructuredDataSignature\n  };\n}","map":{"version":3,"names":["sha256","bytesToHex","concatBytes","utf8ToBytes","ClarityType","serializeCV","StacksMessageType","signMessageHashRsv","STRUCTURED_DATA_PREFIX","Uint8Array","hashStructuredData","structuredData","hash256BytesLength","isDomain","value","type","Tuple","every","key","data","StringASCII","UInt","encodeStructuredData","_ref","message","domain","structuredDataHash","Error","domainHash","decodeStructuredDataSignature","signature","encodedMessageBytes","slice","length","messageHash","signStructuredData","_ref2","privateKey","_signMessageHashRsv","StructuredDataSignature"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\structuredDataSignature.ts"],"sourcesContent":["import { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, concatBytes, utf8ToBytes } from '@stacks/common';\n\nimport { ClarityType, ClarityValue, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv, StacksPrivateKey } from './keys';\n\n// Refer to SIP018 https://github.com/stacksgov/sips/\n// > asciiToBytes('SIP018')\nexport const STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);\n\nexport function hashStructuredData(structuredData: ClarityValue): Uint8Array {\n  return sha256(serializeCV(structuredData));\n}\n\nconst hash256BytesLength = 32;\n\nfunction isDomain(value: ClarityValue): boolean {\n  if (value.type !== ClarityType.Tuple) return false;\n  // Check that the tuple has at least 'name', 'version' and 'chain-id'\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  // Check each key is of the right type\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))\n    return false;\n\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\n\nexport function encodeStructuredData({\n  message,\n  domain,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n}): Uint8Array {\n  const structuredDataHash: Uint8Array = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\n      \"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\"\n    );\n  }\n  const domainHash: Uint8Array = hashStructuredData(domain);\n\n  return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);\n}\n\nexport type DecodedStructuredData = {\n  domainHash: Uint8Array;\n  messageHash: Uint8Array;\n};\n\nexport function decodeStructuredDataSignature(\n  signature: string | Uint8Array\n): DecodedStructuredData {\n  const encodedMessageBytes: Uint8Array =\n    typeof signature === 'string' ? utf8ToBytes(signature) : signature;\n  const domainHash = encodedMessageBytes.slice(\n    STRUCTURED_DATA_PREFIX.length,\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  const messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  return {\n    domainHash,\n    messageHash,\n  };\n}\n\nexport interface StructuredDataSignature {\n  readonly type: StacksMessageType.StructuredDataSignature;\n  data: string;\n}\n\n/**\n * Signs a structured message (ClarityValue) and a domain (ClarityValue) using a private key.\n * The resulting signature along with the original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signStructuredData({\n  message,\n  domain,\n  privateKey,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n  privateKey: StacksPrivateKey;\n}): StructuredDataSignature {\n  const structuredDataHash: string = bytesToHex(sha256(encodeStructuredData({ message, domain })));\n\n  const { data } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey,\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}