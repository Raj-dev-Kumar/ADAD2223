{"ast":null,"code":"import _objectSpread from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/rajde/gitrep/deploy/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { bytesToHex, concatArray, hexToBytes, intToBigInt, writeUInt32BE } from '@stacks/common';\nimport { AnchorMode, anchorModeFromNameOrValue, AuthType, DEFAULT_CHAIN_ID, PayloadType, PostConditionMode, PubKeyEncoding, StacksMessageType, TransactionVersion } from './constants';\nimport { deserializeAuthorization, intoInitialSighashAuth, isSingleSig, nextSignature, serializeAuthorization, setFee as _setFee, setNonce as _setNonce, setSponsor as _setSponsor, setSponsorNonce as _setSponsorNonce, verifyOrigin as _verifyOrigin } from './authorization';\nimport { createTransactionAuthField } from './signature';\nimport { cloneDeep, txidFromData } from './utils';\nimport { deserializePayload, serializePayload } from './payload';\nimport { createLPList, deserializeLPList, serializeLPList } from './types';\nimport { isCompressed } from './keys';\nimport { BytesReader } from './bytesReader';\nimport { SerializationError, SigningError } from './errors';\nexport var StacksTransaction = /*#__PURE__*/function () {\n  function StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {\n    _classCallCheck(this, StacksTransaction);\n    this.version = version;\n    this.auth = auth;\n    if ('amount' in payload) {\n      this.payload = _objectSpread(_objectSpread({}, payload), {}, {\n        amount: intToBigInt(payload.amount, false)\n      });\n    } else {\n      this.payload = payload;\n    }\n    this.chainId = chainId !== null && chainId !== void 0 ? chainId : DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode !== null && postConditionMode !== void 0 ? postConditionMode : PostConditionMode.Deny;\n    this.postConditions = postConditions !== null && postConditions !== void 0 ? postConditions : createLPList([]);\n    if (anchorMode) {\n      this.anchorMode = anchorModeFromNameOrValue(anchorMode);\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.CoinbaseToAltRecipient:\n        case PayloadType.PoisonMicroblock:\n          {\n            this.anchorMode = AnchorMode.OnChainOnly;\n            break;\n          }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.VersionedSmartContract:\n        case PayloadType.TokenTransfer:\n          {\n            this.anchorMode = AnchorMode.Any;\n            break;\n          }\n      }\n    }\n  }\n  _createClass(StacksTransaction, [{\n    key: \"signBegin\",\n    value: function signBegin() {\n      var tx = cloneDeep(this);\n      tx.auth = intoInitialSighashAuth(tx.auth);\n      return tx.txid();\n    }\n  }, {\n    key: \"verifyBegin\",\n    value: function verifyBegin() {\n      var tx = cloneDeep(this);\n      tx.auth = intoInitialSighashAuth(tx.auth);\n      return tx.txid();\n    }\n  }, {\n    key: \"verifyOrigin\",\n    value: function verifyOrigin() {\n      return _verifyOrigin(this.auth, this.verifyBegin());\n    }\n  }, {\n    key: \"signNextOrigin\",\n    value: function signNextOrigin(sigHash, privateKey) {\n      if (this.auth.spendingCondition === undefined) {\n        throw new Error('\"auth.spendingCondition\" is undefined');\n      }\n      if (this.auth.authType === undefined) {\n        throw new Error('\"auth.authType\" is undefined');\n      }\n      return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n    }\n  }, {\n    key: \"signNextSponsor\",\n    value: function signNextSponsor(sigHash, privateKey) {\n      if (this.auth.authType === AuthType.Sponsored) {\n        return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);\n      } else {\n        throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n      }\n    }\n  }, {\n    key: \"appendPubkey\",\n    value: function appendPubkey(publicKey) {\n      var cond = this.auth.spendingCondition;\n      if (cond && !isSingleSig(cond)) {\n        var compressed = isCompressed(publicKey);\n        cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));\n      } else {\n        throw new Error(\"Can't append public key to a singlesig condition\");\n      }\n    }\n  }, {\n    key: \"signAndAppend\",\n    value: function signAndAppend(condition, curSigHash, authType, privateKey) {\n      var _nextSignature = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey),\n        nextSig = _nextSignature.nextSig,\n        nextSigHash = _nextSignature.nextSigHash;\n      if (isSingleSig(condition)) {\n        condition.signature = nextSig;\n      } else {\n        var compressed = bytesToHex(privateKey.data).endsWith('01');\n        condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));\n      }\n      return nextSigHash;\n    }\n  }, {\n    key: \"txid\",\n    value: function txid() {\n      var serialized = this.serialize();\n      return txidFromData(serialized);\n    }\n  }, {\n    key: \"setSponsor\",\n    value: function setSponsor(sponsorSpendingCondition) {\n      if (this.auth.authType != AuthType.Sponsored) {\n        throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n      }\n      this.auth = _setSponsor(this.auth, sponsorSpendingCondition);\n    }\n  }, {\n    key: \"setFee\",\n    value: function setFee(amount) {\n      this.auth = _setFee(this.auth, amount);\n    }\n  }, {\n    key: \"setNonce\",\n    value: function setNonce(nonce) {\n      this.auth = _setNonce(this.auth, nonce);\n    }\n  }, {\n    key: \"setSponsorNonce\",\n    value: function setSponsorNonce(nonce) {\n      if (this.auth.authType != AuthType.Sponsored) {\n        throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n      }\n      this.auth = _setSponsorNonce(this.auth, nonce);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      if (this.version === undefined) {\n        throw new SerializationError('\"version\" is undefined');\n      }\n      if (this.chainId === undefined) {\n        throw new SerializationError('\"chainId\" is undefined');\n      }\n      if (this.auth === undefined) {\n        throw new SerializationError('\"auth\" is undefined');\n      }\n      if (this.anchorMode === undefined) {\n        throw new SerializationError('\"anchorMode\" is undefined');\n      }\n      if (this.payload === undefined) {\n        throw new SerializationError('\"payload\" is undefined');\n      }\n      var bytesArray = [];\n      bytesArray.push(this.version);\n      var chainIdBytes = new Uint8Array(4);\n      writeUInt32BE(chainIdBytes, this.chainId, 0);\n      bytesArray.push(chainIdBytes);\n      bytesArray.push(serializeAuthorization(this.auth));\n      bytesArray.push(this.anchorMode);\n      bytesArray.push(this.postConditionMode);\n      bytesArray.push(serializeLPList(this.postConditions));\n      bytesArray.push(serializePayload(this.payload));\n      return concatArray(bytesArray);\n    }\n  }]);\n  return StacksTransaction;\n}();\nexport function deserializeTransaction(data) {\n  var bytesReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bytesReader = new BytesReader(hexToBytes(data.slice(2)));\n    } else {\n      bytesReader = new BytesReader(hexToBytes(data));\n    }\n  } else if (data instanceof Uint8Array) {\n    bytesReader = new BytesReader(data);\n  } else {\n    bytesReader = data;\n  }\n  var version = bytesReader.readUInt8Enum(TransactionVersion, function (n) {\n    throw new Error(\"Could not parse \".concat(n, \" as TransactionVersion\"));\n  });\n  var chainId = bytesReader.readUInt32BE();\n  var auth = deserializeAuthorization(bytesReader);\n  var anchorMode = bytesReader.readUInt8Enum(AnchorMode, function (n) {\n    throw new Error(\"Could not parse \".concat(n, \" as AnchorMode\"));\n  });\n  var postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, function (n) {\n    throw new Error(\"Could not parse \".concat(n, \" as PostConditionMode\"));\n  });\n  var postConditions = deserializeLPList(bytesReader, StacksMessageType.PostCondition);\n  var payload = deserializePayload(bytesReader);\n  return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);\n}","map":{"version":3,"names":["bytesToHex","concatArray","hexToBytes","intToBigInt","writeUInt32BE","AnchorMode","anchorModeFromNameOrValue","AuthType","DEFAULT_CHAIN_ID","PayloadType","PostConditionMode","PubKeyEncoding","StacksMessageType","TransactionVersion","deserializeAuthorization","intoInitialSighashAuth","isSingleSig","nextSignature","serializeAuthorization","setFee","setNonce","setSponsor","setSponsorNonce","verifyOrigin","createTransactionAuthField","cloneDeep","txidFromData","deserializePayload","serializePayload","createLPList","deserializeLPList","serializeLPList","isCompressed","BytesReader","SerializationError","SigningError","StacksTransaction","version","auth","payload","postConditions","postConditionMode","anchorMode","chainId","_classCallCheck","_objectSpread","amount","Deny","payloadType","Coinbase","CoinbaseToAltRecipient","PoisonMicroblock","OnChainOnly","ContractCall","SmartContract","VersionedSmartContract","TokenTransfer","Any","_createClass","key","value","signBegin","tx","txid","verifyBegin","signNextOrigin","sigHash","privateKey","spendingCondition","undefined","Error","authType","signAndAppend","Standard","signNextSponsor","Sponsored","sponsorSpendingCondition","appendPubkey","publicKey","cond","compressed","fields","push","Compressed","Uncompressed","condition","curSigHash","_nextSignature","fee","nonce","nextSig","nextSigHash","signature","data","endsWith","serialized","serialize","bytesArray","chainIdBytes","Uint8Array","deserializeTransaction","bytesReader","slice","toLowerCase","readUInt8Enum","n","concat","readUInt32BE","PostCondition"],"sources":["C:\\Users\\rajde\\gitrep\\deploy\\frontend\\node_modules\\@stacks\\transactions\\src\\transaction.ts"],"sourcesContent":["import {\n  bytesToHex,\n  concatArray,\n  hexToBytes,\n  IntegerType,\n  intToBigInt,\n  writeUInt32BE,\n} from '@stacks/common';\nimport {\n  AnchorMode,\n  anchorModeFromNameOrValue,\n  AnchorModeName,\n  AuthType,\n  ChainID,\n  DEFAULT_CHAIN_ID,\n  PayloadType,\n  PostConditionMode,\n  PubKeyEncoding,\n  StacksMessageType,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  Authorization,\n  deserializeAuthorization,\n  intoInitialSighashAuth,\n  isSingleSig,\n  nextSignature,\n  serializeAuthorization,\n  setFee,\n  setNonce,\n  setSponsor,\n  setSponsorNonce,\n  SpendingConditionOpts,\n  verifyOrigin,\n} from './authorization';\nimport { createTransactionAuthField } from './signature';\n\nimport { cloneDeep, txidFromData } from './utils';\n\nimport { deserializePayload, Payload, PayloadInput, serializePayload } from './payload';\n\nimport { createLPList, deserializeLPList, LengthPrefixedList, serializeLPList } from './types';\n\nimport { isCompressed, StacksPrivateKey, StacksPublicKey } from './keys';\n\nimport { BytesReader } from './bytesReader';\n\nimport { SerializationError, SigningError } from './errors';\n\nexport class StacksTransaction {\n  version: TransactionVersion;\n  chainId: ChainID;\n  auth: Authorization;\n  anchorMode: AnchorMode;\n  payload: Payload;\n  postConditionMode: PostConditionMode;\n  postConditions: LengthPrefixedList;\n\n  constructor(\n    version: TransactionVersion,\n    auth: Authorization,\n    payload: PayloadInput,\n    postConditions?: LengthPrefixedList,\n    postConditionMode?: PostConditionMode,\n    anchorMode?: AnchorModeName | AnchorMode,\n    chainId?: ChainID\n  ) {\n    this.version = version;\n    this.auth = auth;\n    if ('amount' in payload) {\n      this.payload = {\n        ...payload,\n        amount: intToBigInt(payload.amount, false),\n      };\n    } else {\n      this.payload = payload;\n    }\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorModeFromNameOrValue(anchorMode);\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.CoinbaseToAltRecipient:\n        case PayloadType.PoisonMicroblock: {\n          this.anchorMode = AnchorMode.OnChainOnly;\n          break;\n        }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.VersionedSmartContract:\n        case PayloadType.TokenTransfer: {\n          this.anchorMode = AnchorMode.Any;\n          break;\n        }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = intoInitialSighashAuth(tx.auth);\n    return tx.txid();\n  }\n\n  verifyOrigin(): string {\n    return verifyOrigin(this.auth, this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.authType === AuthType.Sponsored) {\n      return this.signAndAppend(\n        this.auth.sponsorSpendingCondition,\n        sigHash,\n        AuthType.Sponsored,\n        privateKey\n      );\n    } else {\n      throw new Error('\"auth.sponsorSpendingCondition\" is undefined');\n    }\n  }\n\n  appendPubkey(publicKey: StacksPublicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          publicKey\n        )\n      );\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(\n    condition: SpendingConditionOpts,\n    curSigHash: string,\n    authType: AuthType,\n    privateKey: StacksPrivateKey\n  ): string {\n    const { nextSig, nextSigHash } = nextSignature(\n      curSigHash,\n      authType,\n      condition.fee,\n      condition.nonce,\n      privateKey\n    );\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = bytesToHex(privateKey.data).endsWith('01');\n      condition.fields.push(\n        createTransactionAuthField(\n          compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed,\n          nextSig\n        )\n      );\n    }\n\n    return nextSigHash;\n  }\n\n  txid(): string {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingConditionOpts) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsor(this.auth, sponsorSpendingCondition);\n  }\n\n  /**\n   * Set the total fee to be paid for this transaction\n   *\n   * @param fee - the fee amount in microstacks\n   */\n  setFee(amount: IntegerType) {\n    this.auth = setFee(this.auth, amount);\n  }\n\n  /**\n   * Set the transaction nonce\n   *\n   * @param nonce - the nonce value\n   */\n  setNonce(nonce: IntegerType) {\n    this.auth = setNonce(this.auth, nonce);\n  }\n\n  /**\n   * Set the transaction sponsor nonce\n   *\n   * @param nonce - the sponsor nonce value\n   */\n  setSponsorNonce(nonce: IntegerType) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth = setSponsorNonce(this.auth, nonce);\n  }\n\n  serialize(): Uint8Array {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bytesArray = [];\n\n    bytesArray.push(this.version);\n    const chainIdBytes = new Uint8Array(4);\n    writeUInt32BE(chainIdBytes, this.chainId, 0);\n    bytesArray.push(chainIdBytes);\n    bytesArray.push(serializeAuthorization(this.auth));\n    bytesArray.push(this.anchorMode);\n    bytesArray.push(this.postConditionMode);\n    bytesArray.push(serializeLPList(this.postConditions));\n    bytesArray.push(serializePayload(this.payload));\n\n    return concatArray(bytesArray);\n  }\n}\n\n/**\n * @param data Uint8Array or hex string\n */\nexport function deserializeTransaction(data: BytesReader | Uint8Array | string) {\n  let bytesReader: BytesReader;\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bytesReader = new BytesReader(hexToBytes(data.slice(2)));\n    } else {\n      bytesReader = new BytesReader(hexToBytes(data));\n    }\n  } else if (data instanceof Uint8Array) {\n    bytesReader = new BytesReader(data);\n  } else {\n    bytesReader = data;\n  }\n  const version = bytesReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bytesReader.readUInt32BE();\n  const auth = deserializeAuthorization(bytesReader);\n  const anchorMode = bytesReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bytesReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bytesReader);\n\n  return new StacksTransaction(\n    version,\n    auth,\n    payload,\n    postConditions,\n    postConditionMode,\n    anchorMode,\n    chainId\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}