{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nvar _assert_1 = require(\"@noble/hashes/_assert\");\nvar pbkdf2_1 = require(\"@noble/hashes/pbkdf2\");\nvar sha256_1 = require(\"@noble/hashes/sha256\");\nvar sha512_1 = require(\"@noble/hashes/sha512\");\nvar utils_1 = require(\"@noble/hashes/utils\");\nvar base_1 = require(\"@scure/base\");\n// Japanese wordlist\nvar isJapanese = function isJapanese(wordlist) {\n  return wordlist[0] === \"\\u3042\\u3044\\u3053\\u304F\\u3057\\u3093\";\n};\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\nfunction nfkd(str) {\n  if (typeof str !== 'string') throw new TypeError(\"Invalid mnemonic type: \".concat(typeof str));\n  return str.normalize('NFKD');\n}\nfunction normalize(str) {\n  var norm = nfkd(str);\n  var words = norm.split(' ');\n  if (![12, 15, 18, 21, 24].includes(words.length)) throw new Error('Invalid mnemonic');\n  return {\n    nfkd: norm,\n    words: words\n  };\n}\nfunction assertEntropy(entropy) {\n  _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction generateMnemonic(wordlist) {\n  var strength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 128;\n  _assert_1.default.number(strength);\n  if (strength % 32 !== 0 || strength > 256) throw new TypeError('Invalid entropy');\n  return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nvar calcChecksum = function calcChecksum(entropy) {\n  // Checksum is ent.length/4 bits long\n  var bitsLeft = 8 - entropy.length / 4;\n  // Zero rightmost \"bitsLeft\" bits in byte\n  // For example: bitsLeft=4 val=10111101 -> 10110000\n  return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n  if (!Array.isArray(wordlist) || wordlist.length !== Math.pow(2, 11) || typeof wordlist[0] !== 'string') throw new Error('Worlist: expected array of 2048 strings');\n  wordlist.forEach(function (i) {\n    if (typeof i !== 'string') throw new Error(\"Wordlist: non-string element: \".concat(i));\n  });\n  return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  var _normalize = normalize(mnemonic),\n    words = _normalize.words;\n  var entropy = getCoder(wordlist).decode(words);\n  assertEntropy(entropy);\n  return entropy;\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction entropyToMnemonic(entropy, wordlist) {\n  assertEntropy(entropy);\n  var words = getCoder(wordlist).encode(entropy);\n  return words.join(isJapanese(wordlist) ? \"\\u3000\" : ' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\nexports.validateMnemonic = validateMnemonic;\nvar salt = function salt(passphrase) {\n  return nfkd(\"mnemonic\".concat(passphrase));\n};\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeed(mnemonic) {\n  var passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n    c: 2048,\n    dkLen: 64\n  });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeedSync(mnemonic) {\n  var passphrase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n    c: 2048,\n    dkLen: 64\n  });\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;","map":{"version":3,"names":["Object","defineProperty","exports","value","mnemonicToSeedSync","mnemonicToSeed","validateMnemonic","entropyToMnemonic","mnemonicToEntropy","generateMnemonic","_assert_1","require","pbkdf2_1","sha256_1","sha512_1","utils_1","base_1","isJapanese","wordlist","nfkd","str","TypeError","concat","normalize","norm","words","split","includes","length","Error","assertEntropy","entropy","default","bytes","strength","arguments","undefined","number","randomBytes","calcChecksum","bitsLeft","Uint8Array","sha256","getCoder","Array","isArray","Math","pow","forEach","i","utils","chain","checksum","radix2","alphabet","mnemonic","_normalize","decode","encode","join","e","salt","passphrase","pbkdf2Async","sha512","c","dkLen","pbkdf2"],"sources":["C:/Users/rajde/gitrep/deploy/frontend/node_modules/@scure/bip39/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nconst _assert_1 = require(\"@noble/hashes/_assert\");\nconst pbkdf2_1 = require(\"@noble/hashes/pbkdf2\");\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst sha512_1 = require(\"@noble/hashes/sha512\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst base_1 = require(\"@scure/base\");\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction assertEntropy(entropy) {\n    _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction generateMnemonic(wordlist, strength = 128) {\n    _assert_1.default.number(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([((0, sha256_1.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2 ** 11 || typeof wordlist[0] !== 'string')\n        throw new Error('Worlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.validateMnemonic = validateMnemonic;\nconst salt = (passphrase) => nfkd(`mnemonic${passphrase}`);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeed(mnemonic, passphrase = '') {\n    return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}